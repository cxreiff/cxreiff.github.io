{"mappings":"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","sources":["<anon>","src/features/posts/postsContent.component.tsx","node_modules/.pnpm/react-markdown@8.0.5_@preact+compat@17.1.2_@types+react@17.0.53/node_modules/react-markdown/lib/react-markdown.js","node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/index.js","node_modules/.pnpm/is-buffer@2.0.5/node_modules/is-buffer/index.js","node_modules/.pnpm/vfile-message@3.1.4/node_modules/vfile-message/lib/index.js","node_modules/.pnpm/unist-util-stringify-position@3.0.3/node_modules/unist-util-stringify-position/lib/index.js","node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minpath.browser.js","node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minproc.browser.js","node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minurl.browser.js","node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minurl.shared.js","node_modules/.pnpm/unified@10.1.2/node_modules/unified/lib/index.js","node_modules/.pnpm/bail@2.0.2/node_modules/bail/index.js","node_modules/.pnpm/extend@3.0.2/node_modules/extend/index.js","node_modules/.pnpm/is-plain-obj@4.1.0/node_modules/is-plain-obj/index.js","node_modules/.pnpm/trough@2.1.0/node_modules/trough/index.js","node_modules/.pnpm/remark-parse@10.0.1/node_modules/remark-parse/index.js","node_modules/.pnpm/remark-parse@10.0.1/node_modules/remark-parse/lib/index.js","node_modules/.pnpm/mdast-util-from-markdown@1.3.0/node_modules/mdast-util-from-markdown/lib/index.js","node_modules/.pnpm/mdast-util-to-string@3.1.1/node_modules/mdast-util-to-string/lib/index.js","node_modules/.pnpm/micromark@3.1.0/node_modules/micromark/lib/parse.js","node_modules/.pnpm/micromark-util-combine-extensions@1.0.0/node_modules/micromark-util-combine-extensions/index.js","node_modules/.pnpm/micromark-util-chunked@1.0.0/node_modules/micromark-util-chunked/index.js","node_modules/.pnpm/micromark@3.1.0/node_modules/micromark/lib/initialize/content.js","node_modules/.pnpm/micromark-factory-space@1.0.0/node_modules/micromark-factory-space/index.js","node_modules/.pnpm/micromark-util-character@1.1.0/node_modules/micromark-util-character/index.js","node_modules/.pnpm/micromark-util-character@1.1.0/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js","node_modules/.pnpm/micromark@3.1.0/node_modules/micromark/lib/initialize/document.js","node_modules/.pnpm/micromark@3.1.0/node_modules/micromark/lib/initialize/flow.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/blank-line.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/content.js","node_modules/.pnpm/micromark-util-subtokenize@1.0.2/node_modules/micromark-util-subtokenize/index.js","node_modules/.pnpm/micromark@3.1.0/node_modules/micromark/lib/initialize/text.js","node_modules/.pnpm/micromark@3.1.0/node_modules/micromark/lib/create-tokenizer.js","node_modules/.pnpm/micromark-util-resolve-all@1.0.0/node_modules/micromark-util-resolve-all/index.js","node_modules/.pnpm/micromark@3.1.0/node_modules/micromark/lib/constructs.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/attention.js","node_modules/.pnpm/micromark-util-classify-character@1.0.0/node_modules/micromark-util-classify-character/index.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/autolink.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/block-quote.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/character-escape.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/character-reference.js","node_modules/.pnpm/decode-named-character-reference@1.0.2/node_modules/decode-named-character-reference/index.js","node_modules/.pnpm/character-entities@2.0.2/node_modules/character-entities/index.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/code-fenced.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/code-indented.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/code-text.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/definition.js","node_modules/.pnpm/micromark-factory-destination@1.0.0/node_modules/micromark-factory-destination/index.js","node_modules/.pnpm/micromark-factory-label@1.0.2/node_modules/micromark-factory-label/index.js","node_modules/.pnpm/micromark-factory-title@1.0.2/node_modules/micromark-factory-title/index.js","node_modules/.pnpm/micromark-factory-whitespace@1.0.0/node_modules/micromark-factory-whitespace/index.js","node_modules/.pnpm/micromark-util-normalize-identifier@1.0.0/node_modules/micromark-util-normalize-identifier/index.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/hard-break-escape.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/heading-atx.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/html-flow.js","node_modules/.pnpm/micromark-util-html-tag-name@1.1.0/node_modules/micromark-util-html-tag-name/index.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/html-text.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/label-end.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/label-start-image.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/label-start-link.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/line-ending.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/list.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/thematic-break.js","node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/setext-underline.js","node_modules/.pnpm/micromark@3.1.0/node_modules/micromark/lib/preprocess.js","node_modules/.pnpm/micromark@3.1.0/node_modules/micromark/lib/postprocess.js","node_modules/.pnpm/micromark-util-decode-numeric-character-reference@1.0.0/node_modules/micromark-util-decode-numeric-character-reference/index.js","node_modules/.pnpm/micromark-util-decode-string@1.0.2/node_modules/micromark-util-decode-string/index.js","node_modules/.pnpm/remark-rehype@10.1.0/node_modules/remark-rehype/lib/index.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/index.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/footer.js","node_modules/.pnpm/micromark-util-sanitize-uri@1.1.0/node_modules/micromark-util-sanitize-uri/index.js","node_modules/.pnpm/micromark-util-encode@1.0.1/node_modules/micromark-util-encode/index.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/state.js","node_modules/.pnpm/unist-util-visit@4.1.2/node_modules/unist-util-visit/lib/index.js","node_modules/.pnpm/unist-util-visit-parents@5.1.3/node_modules/unist-util-visit-parents/lib/index.js","node_modules/.pnpm/unist-util-is@5.2.0/node_modules/unist-util-is/lib/index.js","node_modules/.pnpm/unist-util-visit-parents@5.1.3/node_modules/unist-util-visit-parents/lib/color.browser.js","node_modules/.pnpm/unist-util-position@4.0.4/node_modules/unist-util-position/lib/index.js","node_modules/.pnpm/unist-util-generated@2.0.1/node_modules/unist-util-generated/lib/index.js","node_modules/.pnpm/mdast-util-definitions@5.1.2/node_modules/mdast-util-definitions/lib/index.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/index.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/blockquote.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/break.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/code.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/delete.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/emphasis.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/footnote.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/heading.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/html.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/image-reference.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/revert.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/image.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/inline-code.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/link-reference.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/link.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/list-item.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/list.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/paragraph.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/root.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/strong.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/table.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/table-row.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/table-cell.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/text.js","node_modules/.pnpm/trim-lines@3.0.1/node_modules/trim-lines/index.js","node_modules/.pnpm/mdast-util-to-hast@12.3.0/node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js","node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js","node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithThrowingShims.js","node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/index.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/merge.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/schema.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/xlink.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/create.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/normalize.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/defined-info.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/info.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/types.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/xml.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/xmlns.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/case-insensitive-transform.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/case-sensitive-transform.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/aria.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/html.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/svg.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/find.js","node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/hast-to-react.js","node_modules/.pnpm/react-markdown@8.0.5_@preact+compat@17.1.2_@types+react@17.0.53/node_modules/react-markdown/lib/rehype-filter.js","node_modules/.pnpm/react-markdown@8.0.5_@preact+compat@17.1.2_@types+react@17.0.53/node_modules/react-markdown/lib/ast-to-react.js","node_modules/.pnpm/hast-util-whitespace@2.0.1/node_modules/hast-util-whitespace/index.js","node_modules/.pnpm/space-separated-tokens@2.0.2/node_modules/space-separated-tokens/index.js","node_modules/.pnpm/comma-separated-tokens@2.0.3/node_modules/comma-separated-tokens/index.js","node_modules/.pnpm/style-to-object@0.4.1/node_modules/style-to-object/index.mjs","node_modules/.pnpm/style-to-object@0.4.1/node_modules/style-to-object/index.js","node_modules/.pnpm/inline-style-parser@0.1.1/node_modules/inline-style-parser/index.js","node_modules/.pnpm/react-markdown@8.0.5_@preact+compat@17.1.2_@types+react@17.0.53/node_modules/react-markdown/lib/uri-transformer.js","src/features/posts/postsContent.module.scss"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true, configurable: true});\n}\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar parcelRequire = $parcel$global[\"parcelRequire3b68\"];\nparcelRequire.register(\"bCSQh\", function(module, exports) {\n\n$parcel$defineInteropFlag(module.exports);\n\n$parcel$export(module.exports, \"default\", () => $5b827356140ac14a$export$2e2bcd8739ae039);\n\nvar $eiFRM = parcelRequire(\"eiFRM\");\n\nvar $hvI8U = parcelRequire(\"hvI8U\");\n\nvar $g4uyC = parcelRequire(\"g4uyC\");\n\nvar $hTxeE = parcelRequire(\"hTxeE\");\n\nvar $ee91V = parcelRequire(\"ee91V\");\n\nvar $la7Ay = parcelRequire(\"la7Ay\");\n\nvar $cqg0o = parcelRequire(\"cqg0o\");\n\nvar $5gZKO = parcelRequire(\"5gZKO\");\n\nvar $b6AxM = parcelRequire(\"b6AxM\");\nconst $5b827356140ac14a$var$PostsContent = ()=>{\n    const { id: id = \"\" } = (0, $hvI8U.useParams)();\n    const { content: content, data: { title: title, date: date } } = (0, $5gZKO.default)[id];\n    const theme = (0, $hTxeE.useAppSelector)((state)=>state.theme.theme);\n    return /*#__PURE__*/ (0, $eiFRM.jsxs)(\"section\", {\n        children: [\n            /*#__PURE__*/ (0, $eiFRM.jsx)((0, $la7Ay.Card), {\n                primary: title,\n                secondary: /*#__PURE__*/ (0, $eiFRM.jsx)(\"time\", {\n                    children: new Date(date).toDateString()\n                })\n            }),\n            /*#__PURE__*/ (0, $eiFRM.jsx)((0, $g4uyC.ReactMarkdown), {\n                className: (0, (/*@__PURE__*/$parcel$interopDefault($b6AxM))).posts_content,\n                children: content,\n                components: {\n                    code ({ inline: inline, className: className, children: children, ...props }) {\n                        const match = /language-(\\w+)/.exec(className || \"\");\n                        return /*#__PURE__*/ (0, $eiFRM.jsx)((0, $cqg0o.SyntaxHighlighter), {\n                            className: (0, (/*@__PURE__*/$parcel$interopDefault($b6AxM))).posts_content_code,\n                            children: String(children).replace(/\\n$/, \"\"),\n                            language: !inline && match ? match[1] : \"text\",\n                            ...props,\n                            style: theme === (0, $ee91V.Theme).DARKMODE ? (0, $cqg0o.styleDark) : (0, $cqg0o.styleLight)\n                        });\n                    }\n                }\n            })\n        ]\n    });\n};\nvar $5b827356140ac14a$export$2e2bcd8739ae039 = $5b827356140ac14a$var$PostsContent;\n\n});\nparcelRequire.register(\"g4uyC\", function(module, exports) {\n\n$parcel$export(module.exports, \"ReactMarkdown\", () => $bb34b91bb72ef434$export$83ef7ab426386201);\n/**\n * @typedef {import('react').ReactNode} ReactNode\n * @typedef {import('react').ReactElement<{}>} ReactElement\n * @typedef {import('unified').PluggableList} PluggableList\n * @typedef {import('hast').Root} Root\n * @typedef {import('./rehype-filter.js').Options} FilterOptions\n * @typedef {import('./ast-to-react.js').Options} TransformOptions\n *\n * @typedef CoreOptions\n * @property {string} children\n *\n * @typedef PluginOptions\n * @property {PluggableList} [remarkPlugins=[]]\n * @property {PluggableList} [rehypePlugins=[]]\n * @property {import('remark-rehype').Options | undefined} [remarkRehypeOptions={}]\n *\n * @typedef LayoutOptions\n * @property {string} [className]\n *\n * @typedef {CoreOptions & PluginOptions & LayoutOptions & FilterOptions & TransformOptions} ReactMarkdownOptions\n *\n * @typedef Deprecation\n * @property {string} id\n * @property {string} [to]\n */ \nvar $3TwHq = parcelRequire(\"3TwHq\");\n\nvar $8EANy = parcelRequire(\"8EANy\");\n\nvar $27vyP = parcelRequire(\"27vyP\");\n\nvar $73kRC = parcelRequire(\"73kRC\");\n\nvar $kJTlh = parcelRequire(\"kJTlh\");\n\nvar $4RND8 = parcelRequire(\"4RND8\");\n\nvar $aY292 = parcelRequire(\"aY292\");\n\nvar $1p9m5 = parcelRequire(\"1p9m5\");\n\nvar $hM85M = parcelRequire(\"hM85M\");\nconst $bb34b91bb72ef434$var$own = {}.hasOwnProperty;\nconst $bb34b91bb72ef434$var$changelog = \"https://github.com/remarkjs/react-markdown/blob/main/changelog.md\";\n/** @type {Record<string, Deprecation>} */ const $bb34b91bb72ef434$var$deprecated = {\n    plugins: {\n        to: \"remarkPlugins\",\n        id: \"change-plugins-to-remarkplugins\"\n    },\n    renderers: {\n        to: \"components\",\n        id: \"change-renderers-to-components\"\n    },\n    astPlugins: {\n        id: \"remove-buggy-html-in-markdown-parser\"\n    },\n    allowDangerousHtml: {\n        id: \"remove-buggy-html-in-markdown-parser\"\n    },\n    escapeHtml: {\n        id: \"remove-buggy-html-in-markdown-parser\"\n    },\n    source: {\n        to: \"children\",\n        id: \"change-source-to-children\"\n    },\n    allowNode: {\n        to: \"allowElement\",\n        id: \"replace-allownode-allowedtypes-and-disallowedtypes\"\n    },\n    allowedTypes: {\n        to: \"allowedElements\",\n        id: \"replace-allownode-allowedtypes-and-disallowedtypes\"\n    },\n    disallowedTypes: {\n        to: \"disallowedElements\",\n        id: \"replace-allownode-allowedtypes-and-disallowedtypes\"\n    },\n    includeNodeIndex: {\n        to: \"includeElementIndex\",\n        id: \"change-includenodeindex-to-includeelementindex\"\n    }\n};\nfunction $bb34b91bb72ef434$export$83ef7ab426386201(options) {\n    for(const key in $bb34b91bb72ef434$var$deprecated)if ($bb34b91bb72ef434$var$own.call($bb34b91bb72ef434$var$deprecated, key) && $bb34b91bb72ef434$var$own.call(options, key)) {\n        const deprecation = $bb34b91bb72ef434$var$deprecated[key];\n        console.warn(`[react-markdown] Warning: please ${deprecation.to ? `use \\`${deprecation.to}\\` instead of` : \"remove\"} \\`${key}\\` (see <${$bb34b91bb72ef434$var$changelog}#${deprecation.id}> for more info)`);\n        delete $bb34b91bb72ef434$var$deprecated[key];\n    }\n    const processor = (0, $27vyP.unified)().use((0, $73kRC.default)).use(options.remarkPlugins || []).use((0, $kJTlh.default), {\n        ...options.remarkRehypeOptions,\n        allowDangerousHtml: true\n    }).use(options.rehypePlugins || []).use((0, $1p9m5.default), options);\n    const file = new (0, $8EANy.VFile)();\n    if (typeof options.children === \"string\") file.value = options.children;\n    else if (options.children !== undefined && options.children !== null) console.warn(`[react-markdown] Warning: please pass a string as \\`children\\` (not: \\`${options.children}\\`)`);\n    const hastNode = processor.runSync(processor.parse(file), file);\n    if (hastNode.type !== \"root\") throw new TypeError(\"Expected a `root` node\");\n    /** @type {ReactElement} */ let result = (0, $3TwHq.default).createElement((0, $3TwHq.default).Fragment, {}, (0, $hM85M.childrenToReact)({\n        options: options,\n        schema: (0, $aY292.html),\n        listDepth: 0\n    }, hastNode));\n    if (options.className) result = (0, $3TwHq.default).createElement(\"div\", {\n        className: options.className\n    }, result);\n    return result;\n}\n$bb34b91bb72ef434$export$83ef7ab426386201.propTypes = {\n    // Core options:\n    children: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).string,\n    // Layout options:\n    className: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).string,\n    // Filter options:\n    allowElement: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).func,\n    allowedElements: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).arrayOf((0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).string),\n    disallowedElements: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).arrayOf((0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).string),\n    unwrapDisallowed: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).bool,\n    // Plugin options:\n    remarkPlugins: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).arrayOf((0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).oneOfType([\n        (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).object,\n        (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).func,\n        (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).arrayOf((0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).oneOfType([\n            (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).bool,\n            (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).string,\n            (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).object,\n            (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).func,\n            (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).arrayOf(// prettier-ignore\n            // type-coverage:ignore-next-line\n            (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).any)\n        ]))\n    ])),\n    rehypePlugins: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).arrayOf((0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).oneOfType([\n        (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).object,\n        (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).func,\n        (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).arrayOf((0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).oneOfType([\n            (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).bool,\n            (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).string,\n            (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).object,\n            (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).func,\n            (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).arrayOf(// prettier-ignore\n            // type-coverage:ignore-next-line\n            (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).any)\n        ]))\n    ])),\n    // Transform options:\n    sourcePos: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).bool,\n    rawSourcePos: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).bool,\n    skipHtml: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).bool,\n    includeElementIndex: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).bool,\n    transformLinkUri: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).oneOfType([\n        (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).func,\n        (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).bool\n    ]),\n    linkTarget: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).oneOfType([\n        (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).func,\n        (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).string\n    ]),\n    transformImageUri: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).func,\n    components: (0, (/*@__PURE__*/$parcel$interopDefault($4RND8))).object\n};\n\n});\nparcelRequire.register(\"8EANy\", function(module, exports) {\n\n$parcel$export(module.exports, \"VFile\", () => $64ce9a830b94da6b$export$93dff69eb10dc7ce);\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('./minurl.shared.js').URL} URL\n * @typedef {import('../index.js').Data} Data\n * @typedef {import('../index.js').Value} Value\n */ /**\n * @typedef {Record<string, unknown> & {type: string, position?: Position | undefined}} NodeLike\n *\n * @typedef {'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'base64url' | 'latin1' | 'binary' | 'hex'} BufferEncoding\n *   Encodings supported by the buffer class.\n *\n *   This is a copy of the types from Node, copied to prevent Node globals from\n *   being needed.\n *   Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>\n *\n * @typedef {Options | URL | Value | VFile} Compatible\n *   Things that can be passed to the constructor.\n *\n * @typedef VFileCoreOptions\n *   Set multiple values.\n * @property {Value | null | undefined} [value]\n *   Set `value`.\n * @property {string | null | undefined} [cwd]\n *   Set `cwd`.\n * @property {Array<string> | null | undefined} [history]\n *   Set `history`.\n * @property {URL | string | null | undefined} [path]\n *   Set `path`.\n * @property {string | null | undefined} [basename]\n *   Set `basename`.\n * @property {string | null | undefined} [stem]\n *   Set `stem`.\n * @property {string | null | undefined} [extname]\n *   Set `extname`.\n * @property {string | null | undefined} [dirname]\n *   Set `dirname`.\n * @property {Data | null | undefined} [data]\n *   Set `data`.\n *\n * @typedef Map\n *   Raw source map.\n *\n *   See:\n *   <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.\n * @property {number} version\n *   Which version of the source map spec this map is following.\n * @property {Array<string>} sources\n *   An array of URLs to the original source files.\n * @property {Array<string>} names\n *   An array of identifiers which can be referenced by individual mappings.\n * @property {string | undefined} [sourceRoot]\n *   The URL root from which all sources are relative.\n * @property {Array<string> | undefined} [sourcesContent]\n *   An array of contents of the original source files.\n * @property {string} mappings\n *   A string of base64 VLQs which contain the actual mappings.\n * @property {string} file\n *   The generated file this source map is associated with.\n *\n * @typedef {{[key: string]: unknown} & VFileCoreOptions} Options\n *   Configuration.\n *\n *   A bunch of keys that will be shallow copied over to the new file.\n *\n * @typedef {Record<string, unknown>} ReporterSettings\n *   Configuration for reporters.\n */ /**\n * @template {ReporterSettings} Settings\n *   Options type.\n * @callback Reporter\n *   Type for a reporter.\n * @param {Array<VFile>} files\n *   Files to report.\n * @param {Settings} options\n *   Configuration.\n * @returns {string}\n *   Report.\n */ \nvar $1Tv42 = parcelRequire(\"1Tv42\");\n\nvar $c9gcl = parcelRequire(\"c9gcl\");\n\nvar $acHbX = parcelRequire(\"acHbX\");\n\nvar $cz21B = parcelRequire(\"cz21B\");\nparcelRequire(\"guBlg\");\nvar $jfDid = parcelRequire(\"jfDid\");\nvar $guBlg = parcelRequire(\"guBlg\");\n/**\n * Order of setting (least specific to most), we need this because otherwise\n * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n * stem can be set.\n *\n * @type {Array<'basename' | 'dirname' | 'extname' | 'history' | 'path' | 'stem'>}\n */ const $64ce9a830b94da6b$var$order = [\n    \"history\",\n    \"path\",\n    \"basename\",\n    \"stem\",\n    \"extname\",\n    \"dirname\"\n];\nclass $64ce9a830b94da6b$export$93dff69eb10dc7ce {\n    /**\n   * Create a new virtual file.\n   *\n   * `options` is treated as:\n   *\n   * *   `string` or `Buffer`  `{value: options}`\n   * *   `URL`  `{path: options}`\n   * *   `VFile`  shallow copies its data over to the new file\n   * *   `object`  all fields are shallow copied over to the new file\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * You cannot set `dirname` or `extname` without setting either `history`,\n   * `path`, `basename`, or `stem` too.\n   *\n   * @param {Compatible | null | undefined} [value]\n   *   File value.\n   * @returns\n   *   New instance.\n   */ constructor(value){\n        /** @type {Options | VFile} */ let options;\n        if (!value) options = {};\n        else if (typeof value === \"string\" || $64ce9a830b94da6b$var$buffer(value)) options = {\n            value: value\n        };\n        else if ((0, $jfDid.isUrl)(value)) options = {\n            path: value\n        };\n        else options = value;\n        /**\n     * Place to store custom information (default: `{}`).\n     *\n     * Its OK to store custom data directly on the file but moving it to\n     * `data` is recommended.\n     *\n     * @type {Data}\n     */ this.data = {};\n        /**\n     * List of messages associated with the file.\n     *\n     * @type {Array<VFileMessage>}\n     */ this.messages = [];\n        /**\n     * List of filepaths the file moved between.\n     *\n     * The first is the original path and the last is the current path.\n     *\n     * @type {Array<string>}\n     */ this.history = [];\n        /**\n     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).\n     *\n     * @type {string}\n     */ this.cwd = (0, $cz21B.proc).cwd();\n        /* eslint-disable no-unused-expressions */ /**\n     * Raw value.\n     *\n     * @type {Value}\n     */ this.value;\n        // The below are non-standard, they are well-known.\n        // As in, used in several tools.\n        /**\n     * Whether a file was saved to disk.\n     *\n     * This is used by vfile reporters.\n     *\n     * @type {boolean}\n     */ this.stored;\n        /**\n     * Custom, non-string, compiled, representation.\n     *\n     * This is used by unified to store non-string results.\n     * One example is when turning markdown into React nodes.\n     *\n     * @type {unknown}\n     */ this.result;\n        /**\n     * Source map.\n     *\n     * This type is equivalent to the `RawSourceMap` type from the `source-map`\n     * module.\n     *\n     * @type {Map | null | undefined}\n     */ this.map;\n        /* eslint-enable no-unused-expressions */ // Set path related properties in the correct order.\n        let index = -1;\n        while(++index < $64ce9a830b94da6b$var$order.length){\n            const prop = $64ce9a830b94da6b$var$order[index];\n            // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n            // `vfile`s too.\n            if (prop in options && options[prop] !== undefined && options[prop] !== null) // @ts-expect-error: TS doesnt understand basic reality.\n            this[prop] = prop === \"history\" ? [\n                ...options[prop]\n            ] : options[prop];\n        }\n        /** @type {string} */ let prop;\n        // Set non-path related properties.\n        for(prop in options)// @ts-expect-error: fine to set other things.\n        if (!$64ce9a830b94da6b$var$order.includes(prop)) // @ts-expect-error: fine to set other things.\n        this[prop] = options[prop];\n    }\n    /**\n   * Get the full path (example: `'~/index.min.js'`).\n   *\n   * @returns {string}\n   */ get path() {\n        return this.history[this.history.length - 1];\n    }\n    /**\n   * Set the full path (example: `'~/index.min.js'`).\n   *\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   *\n   * @param {string | URL} path\n   */ set path(path) {\n        if ((0, $jfDid.isUrl)(path)) path = (0, $guBlg.urlToPath)(path);\n        $64ce9a830b94da6b$var$assertNonEmpty(path, \"path\");\n        if (this.path !== path) this.history.push(path);\n    }\n    /**\n   * Get the parent path (example: `'~'`).\n   */ get dirname() {\n        return typeof this.path === \"string\" ? (0, $acHbX.path).dirname(this.path) : undefined;\n    }\n    /**\n   * Set the parent path (example: `'~'`).\n   *\n   * Cannot be set if theres no `path` yet.\n   */ set dirname(dirname) {\n        $64ce9a830b94da6b$var$assertPath(this.basename, \"dirname\");\n        this.path = (0, $acHbX.path).join(dirname || \"\", this.basename);\n    }\n    /**\n   * Get the basename (including extname) (example: `'index.min.js'`).\n   */ get basename() {\n        return typeof this.path === \"string\" ? (0, $acHbX.path).basename(this.path) : undefined;\n    }\n    /**\n   * Set basename (including extname) (`'index.min.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */ set basename(basename) {\n        $64ce9a830b94da6b$var$assertNonEmpty(basename, \"basename\");\n        $64ce9a830b94da6b$var$assertPart(basename, \"basename\");\n        this.path = (0, $acHbX.path).join(this.dirname || \"\", basename);\n    }\n    /**\n   * Get the extname (including dot) (example: `'.js'`).\n   */ get extname() {\n        return typeof this.path === \"string\" ? (0, $acHbX.path).extname(this.path) : undefined;\n    }\n    /**\n   * Set the extname (including dot) (example: `'.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be set if theres no `path` yet.\n   */ set extname(extname) {\n        $64ce9a830b94da6b$var$assertPart(extname, \"extname\");\n        $64ce9a830b94da6b$var$assertPath(this.dirname, \"extname\");\n        if (extname) {\n            if (extname.charCodeAt(0) !== 46 /* `.` */ ) throw new Error(\"`extname` must start with `.`\");\n            if (extname.includes(\".\", 1)) throw new Error(\"`extname` cannot contain multiple dots\");\n        }\n        this.path = (0, $acHbX.path).join(this.dirname, this.stem + (extname || \"\"));\n    }\n    /**\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\n   */ get stem() {\n        return typeof this.path === \"string\" ? (0, $acHbX.path).basename(this.path, this.extname) : undefined;\n    }\n    /**\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */ set stem(stem) {\n        $64ce9a830b94da6b$var$assertNonEmpty(stem, \"stem\");\n        $64ce9a830b94da6b$var$assertPart(stem, \"stem\");\n        this.path = (0, $acHbX.path).join(this.dirname || \"\", stem + (this.extname || \"\"));\n    }\n    /**\n   * Serialize the file.\n   *\n   * @param {BufferEncoding | null | undefined} [encoding='utf8']\n   *   Character encoding to understand `value` as when its a `Buffer`\n   *   (default: `'utf8'`).\n   * @returns {string}\n   *   Serialized file.\n   */ toString(encoding) {\n        return (this.value || \"\").toString(encoding || undefined);\n    }\n    /**\n   * Create a warning message associated with the file.\n   *\n   * Its `fatal` is set to `false` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */ message(reason, place, origin) {\n        const message = new (0, $c9gcl.VFileMessage)(reason, place, origin);\n        if (this.path) {\n            message.name = this.path + \":\" + message.name;\n            message.file = this.path;\n        }\n        message.fatal = false;\n        this.messages.push(message);\n        return message;\n    }\n    /**\n   * Create an info message associated with the file.\n   *\n   * Its `fatal` is set to `null` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */ info(reason, place, origin) {\n        const message = this.message(reason, place, origin);\n        message.fatal = null;\n        return message;\n    }\n    /**\n   * Create a fatal error associated with the file.\n   *\n   * Its `fatal` is set to `true` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * >  **Note**: a fatal error means that a file is no longer processable.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {never}\n   *   Message.\n   * @throws {VFileMessage}\n   *   Message.\n   */ fail(reason, place, origin) {\n        const message = this.message(reason, place, origin);\n        message.fatal = true;\n        throw message;\n    }\n}\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string | null | undefined} part\n *   File path part.\n * @param {string} name\n *   Part name.\n * @returns {void}\n *   Nothing.\n */ function $64ce9a830b94da6b$var$assertPart(part, name) {\n    if (part && part.includes((0, $acHbX.path).sep)) throw new Error(\"`\" + name + \"` cannot be a path: did not expect `\" + (0, $acHbX.path).sep + \"`\");\n}\n/**\n * Assert that `part` is not empty.\n *\n * @param {string | undefined} part\n *   Thing.\n * @param {string} name\n *   Part name.\n * @returns {asserts part is string}\n *   Nothing.\n */ function $64ce9a830b94da6b$var$assertNonEmpty(part, name) {\n    if (!part) throw new Error(\"`\" + name + \"` cannot be empty\");\n}\n/**\n * Assert `path` exists.\n *\n * @param {string | undefined} path\n *   Path.\n * @param {string} name\n *   Dependency name.\n * @returns {asserts path is string}\n *   Nothing.\n */ function $64ce9a830b94da6b$var$assertPath(path, name) {\n    if (!path) throw new Error(\"Setting `\" + name + \"` requires `path` to be set too\");\n}\n/**\n * Assert `value` is a buffer.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Buffer}\n *   Whether `value` is a Node.js buffer.\n */ function $64ce9a830b94da6b$var$buffer(value) {\n    return (0, (/*@__PURE__*/$parcel$interopDefault($1Tv42)))(value);\n}\n\n});\nparcelRequire.register(\"1Tv42\", function(module, exports) {\n/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ module.exports = function isBuffer(obj) {\n    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n};\n\n});\n\nparcelRequire.register(\"c9gcl\", function(module, exports) {\n\n$parcel$export(module.exports, \"VFileMessage\", () => $8d82e3e29a1417e2$export$752e5c445fe834ef);\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {object & {type: string, position?: Position | undefined}} NodeLike\n */ \nvar $gHjNW = parcelRequire(\"gHjNW\");\nclass $8d82e3e29a1417e2$export$752e5c445fe834ef extends Error {\n    /**\n   * Create a message for `reason` at `place` from `origin`.\n   *\n   * When an error is passed in as `reason`, the `stack` is copied.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   *\n   *   >  **Note**: you should use markdown.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns\n   *   Instance of `VFileMessage`.\n   */ // To do: next major: expose `undefined` everywhere instead of `null`.\n    constructor(reason, place, origin){\n        /** @type {[string | null, string | null]} */ const parts = [\n            null,\n            null\n        ];\n        /** @type {Position} */ let position = {\n            // @ts-expect-error: we always follows the structure of `position`.\n            start: {\n                line: null,\n                column: null\n            },\n            // @ts-expect-error: \"\n            end: {\n                line: null,\n                column: null\n            }\n        };\n        super();\n        if (typeof place === \"string\") {\n            origin = place;\n            place = undefined;\n        }\n        if (typeof origin === \"string\") {\n            const index = origin.indexOf(\":\");\n            if (index === -1) parts[1] = origin;\n            else {\n                parts[0] = origin.slice(0, index);\n                parts[1] = origin.slice(index + 1);\n            }\n        }\n        if (place) {\n            // Node.\n            if (\"type\" in place || \"position\" in place) {\n                if (place.position) // To do: next major: deep clone.\n                // @ts-expect-error: looks like a position.\n                position = place.position;\n            } else if (\"start\" in place || \"end\" in place) // @ts-expect-error: looks like a position.\n            // To do: next major: deep clone.\n            position = place;\n            else if (\"line\" in place || \"column\" in place) // To do: next major: deep clone.\n            position.start = place;\n        }\n        // Fields from `Error`.\n        /**\n     * Serialized positional info of error.\n     *\n     * On normal errors, this would be something like `ParseError`, buit in\n     * `VFile` messages we use this space to show where an error happened.\n     */ this.name = (0, $gHjNW.stringifyPosition)(place) || \"1:1\";\n        /**\n     * Reason for message.\n     *\n     * @type {string}\n     */ this.message = typeof reason === \"object\" ? reason.message : reason;\n        /**\n     * Stack of message.\n     *\n     * This is used by normal errors to show where something happened in\n     * programming code, irrelevant for `VFile` messages,\n     *\n     * @type {string}\n     */ this.stack = \"\";\n        if (typeof reason === \"object\" && reason.stack) this.stack = reason.stack;\n        /**\n     * Reason for message.\n     *\n     * >  **Note**: you should use markdown.\n     *\n     * @type {string}\n     */ this.reason = this.message;\n        /* eslint-disable no-unused-expressions */ /**\n     * State of problem.\n     *\n     * * `true`  marks associated file as no longer processable (error)\n     * * `false`  necessitates a (potential) change (warning)\n     * * `null | undefined`  for things that might not need changing (info)\n     *\n     * @type {boolean | null | undefined}\n     */ this.fatal;\n        /**\n     * Starting line of error.\n     *\n     * @type {number | null}\n     */ this.line = position.start.line;\n        /**\n     * Starting column of error.\n     *\n     * @type {number | null}\n     */ this.column = position.start.column;\n        /**\n     * Full unist position.\n     *\n     * @type {Position | null}\n     */ this.position = position;\n        /**\n     * Namespace of message (example: `'my-package'`).\n     *\n     * @type {string | null}\n     */ this.source = parts[0];\n        /**\n     * Category of message (example: `'my-rule'`).\n     *\n     * @type {string | null}\n     */ this.ruleId = parts[1];\n        /**\n     * Path of a file (used throughout the `VFile` ecosystem).\n     *\n     * @type {string | null}\n     */ this.file;\n        // The following fields are well known.\n        // Not standard.\n        // Feel free to add other non-standard fields to your messages.\n        /**\n     * Specify the source value thats being reported, which is deemed\n     * incorrect.\n     *\n     * @type {string | null}\n     */ this.actual;\n        /**\n     * Suggest acceptable values that can be used instead of `actual`.\n     *\n     * @type {Array<string> | null}\n     */ this.expected;\n        /**\n     * Link to docs for the message.\n     *\n     * >  **Note**: this must be an absolute URL that can be passed as `x`\n     * > to `new URL(x)`.\n     *\n     * @type {string | null}\n     */ this.url;\n        /**\n     * Long form description of the message (you should use markdown).\n     *\n     * @type {string | null}\n     */ this.note;\n    /* eslint-enable no-unused-expressions */ }\n}\n$8d82e3e29a1417e2$export$752e5c445fe834ef.prototype.file = \"\";\n$8d82e3e29a1417e2$export$752e5c445fe834ef.prototype.name = \"\";\n$8d82e3e29a1417e2$export$752e5c445fe834ef.prototype.reason = \"\";\n$8d82e3e29a1417e2$export$752e5c445fe834ef.prototype.message = \"\";\n$8d82e3e29a1417e2$export$752e5c445fe834ef.prototype.stack = \"\";\n$8d82e3e29a1417e2$export$752e5c445fe834ef.prototype.fatal = null;\n$8d82e3e29a1417e2$export$752e5c445fe834ef.prototype.column = null;\n$8d82e3e29a1417e2$export$752e5c445fe834ef.prototype.line = null;\n$8d82e3e29a1417e2$export$752e5c445fe834ef.prototype.source = null;\n$8d82e3e29a1417e2$export$752e5c445fe834ef.prototype.ruleId = null;\n$8d82e3e29a1417e2$export$752e5c445fe834ef.prototype.position = null;\n\n});\nparcelRequire.register(\"gHjNW\", function(module, exports) {\n\n$parcel$export(module.exports, \"stringifyPosition\", () => $c2800647e46698b3$export$c304dd45fe166145);\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */ /**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */ /**\n * Serialize the positional info of a point, position (start and end points),\n * or node.\n *\n * @param {Node | NodeLike | Position | PositionLike | Point | PointLike | null | undefined} [value]\n *   Node, position, or point.\n * @returns {string}\n *   Pretty printed positional info of a node (`string`).\n *\n *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)\n *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for\n *   column, `s` for `start`, and `e` for end.\n *   An empty string (`''`) is returned if the given value is neither `node`,\n *   `position`, nor `point`.\n */ function $c2800647e46698b3$export$c304dd45fe166145(value) {\n    // Nothing.\n    if (!value || typeof value !== \"object\") return \"\";\n    // Node.\n    if (\"position\" in value || \"type\" in value) return $c2800647e46698b3$var$position(value.position);\n    // Position.\n    if (\"start\" in value || \"end\" in value) return $c2800647e46698b3$var$position(value);\n    // Point.\n    if (\"line\" in value || \"column\" in value) return $c2800647e46698b3$var$point(value);\n    // ?\n    return \"\";\n}\n/**\n * @param {Point | PointLike | null | undefined} point\n * @returns {string}\n */ function $c2800647e46698b3$var$point(point) {\n    return $c2800647e46698b3$var$index(point && point.line) + \":\" + $c2800647e46698b3$var$index(point && point.column);\n}\n/**\n * @param {Position | PositionLike | null | undefined} pos\n * @returns {string}\n */ function $c2800647e46698b3$var$position(pos) {\n    return $c2800647e46698b3$var$point(pos && pos.start) + \"-\" + $c2800647e46698b3$var$point(pos && pos.end);\n}\n/**\n * @param {number | null | undefined} value\n * @returns {number}\n */ function $c2800647e46698b3$var$index(value) {\n    return value && typeof value === \"number\" ? value : 1;\n}\n\n});\n\n\nparcelRequire.register(\"acHbX\", function(module, exports) {\n\n$parcel$export(module.exports, \"path\", () => $76dc8763f1906fc2$export$bb654e07daaf8c3a);\n// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Nodes internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nconst $76dc8763f1906fc2$export$bb654e07daaf8c3a = {\n    basename: $76dc8763f1906fc2$var$basename,\n    dirname: $76dc8763f1906fc2$var$dirname,\n    extname: $76dc8763f1906fc2$var$extname,\n    join: $76dc8763f1906fc2$var$join,\n    sep: \"/\"\n};\n/* eslint-disable max-depth, complexity */ /**\n * Get the basename from a path.\n *\n * @param {string} path\n *   File path.\n * @param {string | undefined} [ext]\n *   Extension to strip.\n * @returns {string}\n *   Stem or basename.\n */ function $76dc8763f1906fc2$var$basename(path, ext) {\n    if (ext !== undefined && typeof ext !== \"string\") throw new TypeError('\"ext\" argument must be a string');\n    $76dc8763f1906fc2$var$assertPath(path);\n    let start = 0;\n    let end = -1;\n    let index = path.length;\n    /** @type {boolean | undefined} */ let seenNonSlash;\n    if (ext === undefined || ext.length === 0 || ext.length > path.length) {\n        while(index--){\n            if (path.charCodeAt(index) === 47 /* `/` */ ) // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now.\n            {\n                if (seenNonSlash) {\n                    start = index + 1;\n                    break;\n                }\n            } else if (end < 0) {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component.\n                seenNonSlash = true;\n                end = index + 1;\n            }\n        }\n        return end < 0 ? \"\" : path.slice(start, end);\n    }\n    if (ext === path) return \"\";\n    let firstNonSlashEnd = -1;\n    let extIndex = ext.length - 1;\n    while(index--){\n        if (path.charCodeAt(index) === 47 /* `/` */ ) // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        {\n            if (seenNonSlash) {\n                start = index + 1;\n                break;\n            }\n        } else {\n            if (firstNonSlashEnd < 0) {\n                // We saw the first non-path separator, remember this index in case\n                // we need it if the extension ends up not matching.\n                seenNonSlash = true;\n                firstNonSlashEnd = index + 1;\n            }\n            if (extIndex > -1) {\n                // Try to match the explicit extension.\n                if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n                    if (extIndex < 0) // We matched the extension, so mark this as the end of our path\n                    // component\n                    end = index;\n                } else {\n                    // Extension does not match, so our result is the entire path\n                    // component\n                    extIndex = -1;\n                    end = firstNonSlashEnd;\n                }\n            }\n        }\n    }\n    if (start === end) end = firstNonSlashEnd;\n    else if (end < 0) end = path.length;\n    return path.slice(start, end);\n}\n/**\n * Get the dirname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */ function $76dc8763f1906fc2$var$dirname(path) {\n    $76dc8763f1906fc2$var$assertPath(path);\n    if (path.length === 0) return \".\";\n    let end = -1;\n    let index = path.length;\n    /** @type {boolean | undefined} */ let unmatchedSlash;\n    // Prefix `--` is important to not run on `0`.\n    while(--index){\n        if (path.charCodeAt(index) === 47 /* `/` */ ) {\n            if (unmatchedSlash) {\n                end = index;\n                break;\n            }\n        } else if (!unmatchedSlash) // We saw the first non-path separator\n        unmatchedSlash = true;\n    }\n    return end < 0 ? path.charCodeAt(0) === 47 /* `/` */  ? \"/\" : \".\" : end === 1 && path.charCodeAt(0) === 47 /* `/` */  ? \"//\" : path.slice(0, end);\n}\n/**\n * Get an extname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   Extname.\n */ function $76dc8763f1906fc2$var$extname(path) {\n    $76dc8763f1906fc2$var$assertPath(path);\n    let index = path.length;\n    let end = -1;\n    let startPart = 0;\n    let startDot = -1;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find.\n    let preDotState = 0;\n    /** @type {boolean | undefined} */ let unmatchedSlash;\n    while(index--){\n        const code = path.charCodeAt(index);\n        if (code === 47 /* `/` */ ) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now.\n            if (unmatchedSlash) {\n                startPart = index + 1;\n                break;\n            }\n            continue;\n        }\n        if (end < 0) {\n            // We saw the first non-path separator, mark this as the end of our\n            // extension.\n            unmatchedSlash = true;\n            end = index + 1;\n        }\n        if (code === 46 /* `.` */ ) {\n            // If this is our first dot, mark it as the start of our extension.\n            if (startDot < 0) startDot = index;\n            else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot > -1) // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension.\n        preDotState = -1;\n    }\n    if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.\n    preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) return \"\";\n    return path.slice(startDot, end);\n}\n/**\n * Join segments from a path.\n *\n * @param {Array<string>} segments\n *   Path segments.\n * @returns {string}\n *   File path.\n */ function $76dc8763f1906fc2$var$join(...segments) {\n    let index = -1;\n    /** @type {string | undefined} */ let joined;\n    while(++index < segments.length){\n        $76dc8763f1906fc2$var$assertPath(segments[index]);\n        if (segments[index]) joined = joined === undefined ? segments[index] : joined + \"/\" + segments[index];\n    }\n    return joined === undefined ? \".\" : $76dc8763f1906fc2$var$normalize(joined);\n}\n/**\n * Normalize a basic file path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */ // Note: `normalize` is not exposed as `path.normalize`, so some code is\n// manually removed from it.\nfunction $76dc8763f1906fc2$var$normalize(path) {\n    $76dc8763f1906fc2$var$assertPath(path);\n    const absolute = path.charCodeAt(0) === 47 /* `/` */ ;\n    // Normalize the path according to POSIX rules.\n    let value = $76dc8763f1906fc2$var$normalizeString(path, !absolute);\n    if (value.length === 0 && !absolute) value = \".\";\n    if (value.length > 0 && path.charCodeAt(path.length - 1) === 47 /* / */ ) value += \"/\";\n    return absolute ? \"/\" + value : value;\n}\n/**\n * Resolve `.` and `..` elements in a path with directory names.\n *\n * @param {string} path\n *   File path.\n * @param {boolean} allowAboveRoot\n *   Whether `..` can move above root.\n * @returns {string}\n *   File path.\n */ function $76dc8763f1906fc2$var$normalizeString(path, allowAboveRoot) {\n    let result = \"\";\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let index = -1;\n    /** @type {number | undefined} */ let code;\n    /** @type {number} */ let lastSlashIndex;\n    while(++index <= path.length){\n        if (index < path.length) code = path.charCodeAt(index);\n        else if (code === 47 /* `/` */ ) break;\n        else code = 47 /* `/` */ ;\n        if (code === 47 /* `/` */ ) {\n            if (lastSlash === index - 1 || dots === 1) ;\n            else if (lastSlash !== index - 1 && dots === 2) {\n                if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 /* `.` */  || result.charCodeAt(result.length - 2) !== 46 /* `.` */ ) {\n                    if (result.length > 2) {\n                        lastSlashIndex = result.lastIndexOf(\"/\");\n                        if (lastSlashIndex !== result.length - 1) {\n                            if (lastSlashIndex < 0) {\n                                result = \"\";\n                                lastSegmentLength = 0;\n                            } else {\n                                result = result.slice(0, lastSlashIndex);\n                                lastSegmentLength = result.length - 1 - result.lastIndexOf(\"/\");\n                            }\n                            lastSlash = index;\n                            dots = 0;\n                            continue;\n                        }\n                    } else if (result.length > 0) {\n                        result = \"\";\n                        lastSegmentLength = 0;\n                        lastSlash = index;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    result = result.length > 0 ? result + \"/..\" : \"..\";\n                    lastSegmentLength = 2;\n                }\n            } else {\n                if (result.length > 0) result += \"/\" + path.slice(lastSlash + 1, index);\n                else result = path.slice(lastSlash + 1, index);\n                lastSegmentLength = index - lastSlash - 1;\n            }\n            lastSlash = index;\n            dots = 0;\n        } else if (code === 46 /* `.` */  && dots > -1) dots++;\n        else dots = -1;\n    }\n    return result;\n}\n/**\n * Make sure `path` is a string.\n *\n * @param {string} path\n *   File path.\n * @returns {asserts path is string}\n *   Nothing.\n */ function $76dc8763f1906fc2$var$assertPath(path) {\n    if (typeof path !== \"string\") throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(path));\n} /* eslint-enable max-depth, complexity */ \n\n});\n\nparcelRequire.register(\"cz21B\", function(module, exports) {\n\n$parcel$export(module.exports, \"proc\", () => $925a52fec1b90daa$export$97a5aaf482767187);\n// Somewhat based on:\n// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.\n// But I dont think one tiny line of code can be copyrighted. \nconst $925a52fec1b90daa$export$97a5aaf482767187 = {\n    cwd: $925a52fec1b90daa$var$cwd\n};\nfunction $925a52fec1b90daa$var$cwd() {\n    return \"/\";\n}\n\n});\n\nparcelRequire.register(\"guBlg\", function(module, exports) {\n\n$parcel$export(module.exports, \"urlToPath\", () => $c01c6a0463602ee5$export$9b2b676c902de799);\n$parcel$export(module.exports, \"isUrl\", () => (parcelRequire(\"jfDid\")).isUrl);\n/// <reference lib=\"dom\" />\n\nvar $jfDid = parcelRequire(\"jfDid\");\nfunction $c01c6a0463602ee5$export$9b2b676c902de799(path) {\n    if (typeof path === \"string\") path = new URL(path);\n    else if (!(0, $jfDid.isUrl)(path)) {\n        /** @type {NodeJS.ErrnoException} */ const error = new TypeError('The \"path\" argument must be of type string or an instance of URL. Received `' + path + \"`\");\n        error.code = \"ERR_INVALID_ARG_TYPE\";\n        throw error;\n    }\n    if (path.protocol !== \"file:\") {\n        /** @type {NodeJS.ErrnoException} */ const error = new TypeError(\"The URL must be of scheme file\");\n        error.code = \"ERR_INVALID_URL_SCHEME\";\n        throw error;\n    }\n    return $c01c6a0463602ee5$var$getPathFromURLPosix(path);\n}\n/**\n * Get a path from a POSIX URL.\n *\n * @param {URL} url\n *   URL.\n * @returns {string}\n *   File path.\n */ function $c01c6a0463602ee5$var$getPathFromURLPosix(url) {\n    if (url.hostname !== \"\") {\n        /** @type {NodeJS.ErrnoException} */ const error = new TypeError('File URL host must be \"localhost\" or empty on darwin');\n        error.code = \"ERR_INVALID_FILE_URL_HOST\";\n        throw error;\n    }\n    const pathname = url.pathname;\n    let index = -1;\n    while(++index < pathname.length)if (pathname.charCodeAt(index) === 37 /* `%` */  && pathname.charCodeAt(index + 1) === 50 /* `2` */ ) {\n        const third = pathname.charCodeAt(index + 2);\n        if (third === 70 /* `F` */  || third === 102 /* `f` */ ) {\n            /** @type {NodeJS.ErrnoException} */ const error = new TypeError(\"File URL path must not include encoded / characters\");\n            error.code = \"ERR_INVALID_FILE_URL_PATH\";\n            throw error;\n        }\n    }\n    return decodeURIComponent(pathname);\n}\n\n});\nparcelRequire.register(\"jfDid\", function(module, exports) {\n\n$parcel$export(module.exports, \"isUrl\", () => $e03de5c8a9f67c93$export$8304a22d431f958);\n/**\n * @typedef URL\n * @property {string} hash\n * @property {string} host\n * @property {string} hostname\n * @property {string} href\n * @property {string} origin\n * @property {string} password\n * @property {string} pathname\n * @property {string} port\n * @property {string} protocol\n * @property {string} search\n * @property {any} searchParams\n * @property {string} username\n * @property {() => string} toString\n * @property {() => string} toJSON\n */ /**\n * Check if `fileUrlOrPath` looks like a URL.\n *\n * @param {unknown} fileUrlOrPath\n *   File path or URL.\n * @returns {fileUrlOrPath is URL}\n *   Whether its a URL.\n */ // From: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js#L1501>\nfunction $e03de5c8a9f67c93$export$8304a22d431f958(fileUrlOrPath) {\n    return fileUrlOrPath !== null && typeof fileUrlOrPath === \"object\" && // @ts-expect-error: indexable.\n    fileUrlOrPath.href && // @ts-expect-error: indexable.\n    fileUrlOrPath.origin;\n}\n\n});\n\n\n\nparcelRequire.register(\"27vyP\", function(module, exports) {\n\n$parcel$export(module.exports, \"unified\", () => $18b4b78c0087b74e$export$7cc1b2fe10c52bb);\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */ \nvar $dEvVi = parcelRequire(\"dEvVi\");\n\nvar $1Tv42 = parcelRequire(\"1Tv42\");\n\nvar $eWaCG = parcelRequire(\"eWaCG\");\n\nvar $4ld8y = parcelRequire(\"4ld8y\");\n\nvar $gpg7e = parcelRequire(\"gpg7e\");\n\nvar $8EANy = parcelRequire(\"8EANy\");\nconst $18b4b78c0087b74e$export$7cc1b2fe10c52bb = $18b4b78c0087b74e$var$base().freeze();\nconst $18b4b78c0087b74e$var$own = {}.hasOwnProperty;\n// Function to create the first processor.\n/**\n * @returns {Processor}\n */ function $18b4b78c0087b74e$var$base() {\n    const transformers = (0, $gpg7e.trough)();\n    /** @type {Processor['attachers']} */ const attachers = [];\n    /** @type {Record<string, unknown>} */ let namespace = {};\n    /** @type {boolean|undefined} */ let frozen;\n    let freezeIndex = -1;\n    // Data management.\n    // @ts-expect-error: overloads are handled.\n    processor.data = data;\n    processor.Parser = undefined;\n    processor.Compiler = undefined;\n    // Lock.\n    processor.freeze = freeze;\n    // Plugins.\n    processor.attachers = attachers;\n    // @ts-expect-error: overloads are handled.\n    processor.use = use;\n    // API.\n    processor.parse = parse;\n    processor.stringify = stringify;\n    // @ts-expect-error: overloads are handled.\n    processor.run = run;\n    processor.runSync = runSync;\n    // @ts-expect-error: overloads are handled.\n    processor.process = process;\n    processor.processSync = processSync;\n    // Expose.\n    return processor;\n    // Create a new processor based on the processor in the current scope.\n    /** @type {Processor} */ function processor() {\n        const destination = $18b4b78c0087b74e$var$base();\n        let index = -1;\n        while(++index < attachers.length)destination.use(...attachers[index]);\n        destination.data((0, (/*@__PURE__*/$parcel$interopDefault($eWaCG)))(true, {}, namespace));\n        return destination;\n    }\n    /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */ function data(key, value) {\n        if (typeof key === \"string\") {\n            // Set `key`.\n            if (arguments.length === 2) {\n                $18b4b78c0087b74e$var$assertUnfrozen(\"data\", frozen);\n                namespace[key] = value;\n                return processor;\n            }\n            // Get `key`.\n            return $18b4b78c0087b74e$var$own.call(namespace, key) && namespace[key] || null;\n        }\n        // Set space.\n        if (key) {\n            $18b4b78c0087b74e$var$assertUnfrozen(\"data\", frozen);\n            namespace = key;\n            return processor;\n        }\n        // Get space.\n        return namespace;\n    }\n    /** @type {Processor['freeze']} */ function freeze() {\n        if (frozen) return processor;\n        while(++freezeIndex < attachers.length){\n            const [attacher, ...options] = attachers[freezeIndex];\n            if (options[0] === false) continue;\n            if (options[0] === true) options[0] = undefined;\n            /** @type {Transformer|void} */ const transformer = attacher.call(processor, ...options);\n            if (typeof transformer === \"function\") transformers.use(transformer);\n        }\n        frozen = true;\n        freezeIndex = Number.POSITIVE_INFINITY;\n        return processor;\n    }\n    /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */ function use(value, ...options) {\n        /** @type {Record<string, unknown>|undefined} */ let settings;\n        $18b4b78c0087b74e$var$assertUnfrozen(\"use\", frozen);\n        if (value === null || value === undefined) ;\n        else if (typeof value === \"function\") addPlugin(value, ...options);\n        else if (typeof value === \"object\") {\n            if (Array.isArray(value)) addList(value);\n            else addPreset(value);\n        } else throw new TypeError(\"Expected usable value, not `\" + value + \"`\");\n        if (settings) namespace.settings = Object.assign(namespace.settings || {}, settings);\n        return processor;\n        /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */ function add(value) {\n            if (typeof value === \"function\") addPlugin(value);\n            else if (typeof value === \"object\") {\n                if (Array.isArray(value)) {\n                    const [plugin, ...options] = value;\n                    addPlugin(plugin, ...options);\n                } else addPreset(value);\n            } else throw new TypeError(\"Expected usable value, not `\" + value + \"`\");\n        }\n        /**\n     * @param {Preset} result\n     * @returns {void}\n     */ function addPreset(result) {\n            addList(result.plugins);\n            if (result.settings) settings = Object.assign(settings || {}, result.settings);\n        }\n        /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */ function addList(plugins) {\n            let index = -1;\n            if (plugins === null || plugins === undefined) ;\n            else if (Array.isArray(plugins)) while(++index < plugins.length){\n                const thing = plugins[index];\n                add(thing);\n            }\n            else throw new TypeError(\"Expected a list of plugins, not `\" + plugins + \"`\");\n        }\n        /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */ function addPlugin(plugin, value) {\n            let index = -1;\n            /** @type {Processor['attachers'][number]|undefined} */ let entry;\n            while(++index < attachers.length)if (attachers[index][0] === plugin) {\n                entry = attachers[index];\n                break;\n            }\n            if (entry) {\n                if ((0, $4ld8y.default)(entry[1]) && (0, $4ld8y.default)(value)) value = (0, (/*@__PURE__*/$parcel$interopDefault($eWaCG)))(true, entry[1], value);\n                entry[1] = value;\n            } else // @ts-expect-error: fine.\n            attachers.push([\n                ...arguments\n            ]);\n        }\n    }\n    /** @type {Processor['parse']} */ function parse(doc) {\n        processor.freeze();\n        const file = $18b4b78c0087b74e$var$vfile(doc);\n        const Parser = processor.Parser;\n        $18b4b78c0087b74e$var$assertParser(\"parse\", Parser);\n        if ($18b4b78c0087b74e$var$newable(Parser, \"parse\")) // @ts-expect-error: `newable` checks this.\n        return new Parser(String(file), file).parse();\n        // @ts-expect-error: `newable` checks this.\n        return Parser(String(file), file) // eslint-disable-line new-cap\n        ;\n    }\n    /** @type {Processor['stringify']} */ function stringify(node, doc) {\n        processor.freeze();\n        const file = $18b4b78c0087b74e$var$vfile(doc);\n        const Compiler = processor.Compiler;\n        $18b4b78c0087b74e$var$assertCompiler(\"stringify\", Compiler);\n        $18b4b78c0087b74e$var$assertNode(node);\n        if ($18b4b78c0087b74e$var$newable(Compiler, \"compile\")) // @ts-expect-error: `newable` checks this.\n        return new Compiler(node, file).compile();\n        // @ts-expect-error: `newable` checks this.\n        return Compiler(node, file) // eslint-disable-line new-cap\n        ;\n    }\n    /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */ function run(node, doc, callback) {\n        $18b4b78c0087b74e$var$assertNode(node);\n        processor.freeze();\n        if (!callback && typeof doc === \"function\") {\n            callback = doc;\n            doc = undefined;\n        }\n        if (!callback) return new Promise(executor);\n        executor(null, callback);\n        /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */ function executor(resolve, reject) {\n            // @ts-expect-error: `doc` cant be a callback anymore, we checked.\n            transformers.run(node, $18b4b78c0087b74e$var$vfile(doc), done);\n            /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */ function done(error, tree, file) {\n                tree = tree || node;\n                if (error) reject(error);\n                else if (resolve) resolve(tree);\n                else // @ts-expect-error: `callback` is defined if `resolve` is not.\n                callback(null, tree, file);\n            }\n        }\n    }\n    /** @type {Processor['runSync']} */ function runSync(node, file) {\n        /** @type {Node|undefined} */ let result;\n        /** @type {boolean|undefined} */ let complete;\n        processor.run(node, file, done);\n        $18b4b78c0087b74e$var$assertDone(\"runSync\", \"run\", complete);\n        // @ts-expect-error: we either bailed on an error or have a tree.\n        return result;\n        /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */ function done(error, tree) {\n            (0, $dEvVi.bail)(error);\n            result = tree;\n            complete = true;\n        }\n    }\n    /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */ function process(doc, callback) {\n        processor.freeze();\n        $18b4b78c0087b74e$var$assertParser(\"process\", processor.Parser);\n        $18b4b78c0087b74e$var$assertCompiler(\"process\", processor.Compiler);\n        if (!callback) return new Promise(executor);\n        executor(null, callback);\n        /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */ function executor(resolve, reject) {\n            const file = $18b4b78c0087b74e$var$vfile(doc);\n            processor.run(processor.parse(file), file, (error, tree, file)=>{\n                if (error || !tree || !file) done(error);\n                else {\n                    /** @type {unknown} */ const result = processor.stringify(tree, file);\n                    if (result === undefined || result === null) ;\n                    else if ($18b4b78c0087b74e$var$looksLikeAVFileValue(result)) file.value = result;\n                    else file.result = result;\n                    done(error, file);\n                }\n            });\n            /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */ function done(error, file) {\n                if (error || !file) reject(error);\n                else if (resolve) resolve(file);\n                else // @ts-expect-error: `callback` is defined if `resolve` is not.\n                callback(null, file);\n            }\n        }\n    }\n    /** @type {Processor['processSync']} */ function processSync(doc) {\n        /** @type {boolean|undefined} */ let complete;\n        processor.freeze();\n        $18b4b78c0087b74e$var$assertParser(\"processSync\", processor.Parser);\n        $18b4b78c0087b74e$var$assertCompiler(\"processSync\", processor.Compiler);\n        const file = $18b4b78c0087b74e$var$vfile(doc);\n        processor.process(file, done);\n        $18b4b78c0087b74e$var$assertDone(\"processSync\", \"process\", complete);\n        return file;\n        /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */ function done(error) {\n            complete = true;\n            (0, $dEvVi.bail)(error);\n        }\n    }\n}\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */ function $18b4b78c0087b74e$var$newable(value, name) {\n    return typeof value === \"function\" && // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    value.prototype && // A function with keys in its prototype is probably a constructor.\n    // Classes prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    // type-coverage:ignore-next-line\n    ($18b4b78c0087b74e$var$keys(value.prototype) || name in value.prototype);\n}\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */ function $18b4b78c0087b74e$var$keys(value) {\n    /** @type {string} */ let key;\n    for(key in value){\n        if ($18b4b78c0087b74e$var$own.call(value, key)) return true;\n    }\n    return false;\n}\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */ function $18b4b78c0087b74e$var$assertParser(name, value) {\n    if (typeof value !== \"function\") throw new TypeError(\"Cannot `\" + name + \"` without `Parser`\");\n}\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */ function $18b4b78c0087b74e$var$assertCompiler(name, value) {\n    if (typeof value !== \"function\") throw new TypeError(\"Cannot `\" + name + \"` without `Compiler`\");\n}\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */ function $18b4b78c0087b74e$var$assertUnfrozen(name, frozen) {\n    if (frozen) throw new Error(\"Cannot call `\" + name + \"` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.\");\n}\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */ function $18b4b78c0087b74e$var$assertNode(node) {\n    // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n    // type-coverage:ignore-next-line\n    if (!(0, $4ld8y.default)(node) || typeof node.type !== \"string\") throw new TypeError(\"Expected node, got `\" + node + \"`\");\n}\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */ function $18b4b78c0087b74e$var$assertDone(name, asyncName, complete) {\n    if (!complete) throw new Error(\"`\" + name + \"` finished async. Use `\" + asyncName + \"` instead\");\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */ function $18b4b78c0087b74e$var$vfile(value) {\n    return $18b4b78c0087b74e$var$looksLikeAVFile(value) ? value : new (0, $8EANy.VFile)(value);\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */ function $18b4b78c0087b74e$var$looksLikeAVFile(value) {\n    return Boolean(value && typeof value === \"object\" && \"message\" in value && \"messages\" in value);\n}\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */ function $18b4b78c0087b74e$var$looksLikeAVFileValue(value) {\n    return typeof value === \"string\" || (0, (/*@__PURE__*/$parcel$interopDefault($1Tv42)))(value);\n}\n\n});\nparcelRequire.register(\"dEvVi\", function(module, exports) {\n\n$parcel$export(module.exports, \"bail\", () => $9f07c614b2a686d3$export$dd911e13ecb11e05);\n/**\n * Throw a given error.\n *\n * @param {Error|null|undefined} [error]\n *   Maybe error.\n * @returns {asserts error is null|undefined}\n */ function $9f07c614b2a686d3$export$dd911e13ecb11e05(error) {\n    if (error) throw error;\n}\n\n});\n\nparcelRequire.register(\"eWaCG\", function(module, exports) {\n\"use strict\";\nvar $adfeb8f4e98e800c$var$hasOwn = Object.prototype.hasOwnProperty;\nvar $adfeb8f4e98e800c$var$toStr = Object.prototype.toString;\nvar $adfeb8f4e98e800c$var$defineProperty = Object.defineProperty;\nvar $adfeb8f4e98e800c$var$gOPD = Object.getOwnPropertyDescriptor;\nvar $adfeb8f4e98e800c$var$isArray = function isArray(arr) {\n    if (typeof Array.isArray === \"function\") return Array.isArray(arr);\n    return $adfeb8f4e98e800c$var$toStr.call(arr) === \"[object Array]\";\n};\nvar $adfeb8f4e98e800c$var$isPlainObject = function isPlainObject(obj) {\n    if (!obj || $adfeb8f4e98e800c$var$toStr.call(obj) !== \"[object Object]\") return false;\n    var hasOwnConstructor = $adfeb8f4e98e800c$var$hasOwn.call(obj, \"constructor\");\n    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && $adfeb8f4e98e800c$var$hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\");\n    // Not own constructor property must be Object\n    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) return false;\n    // Own properties are enumerated firstly, so to speed up,\n    // if last one is own, then all properties are own.\n    var key;\n    for(key in obj);\n    return typeof key === \"undefined\" || $adfeb8f4e98e800c$var$hasOwn.call(obj, key);\n};\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar $adfeb8f4e98e800c$var$setProperty = function setProperty(target, options) {\n    if ($adfeb8f4e98e800c$var$defineProperty && options.name === \"__proto__\") $adfeb8f4e98e800c$var$defineProperty(target, options.name, {\n        enumerable: true,\n        configurable: true,\n        value: options.newValue,\n        writable: true\n    });\n    else target[options.name] = options.newValue;\n};\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar $adfeb8f4e98e800c$var$getProperty = function getProperty(obj, name) {\n    if (name === \"__proto__\") {\n        if (!$adfeb8f4e98e800c$var$hasOwn.call(obj, name)) return void 0;\n        else if ($adfeb8f4e98e800c$var$gOPD) // In early versions of node, obj['__proto__'] is buggy when obj has\n        // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n        return $adfeb8f4e98e800c$var$gOPD(obj, name).value;\n    }\n    return obj[name];\n};\nmodule.exports = function extend() {\n    var options, name, src, copy, copyIsArray, clone;\n    var target = arguments[0];\n    var i = 1;\n    var length = arguments.length;\n    var deep = false;\n    // Handle a deep copy situation\n    if (typeof target === \"boolean\") {\n        deep = target;\n        target = arguments[1] || {};\n        // skip the boolean and the target\n        i = 2;\n    }\n    if (target == null || typeof target !== \"object\" && typeof target !== \"function\") target = {};\n    for(; i < length; ++i){\n        options = arguments[i];\n        // Only deal with non-null/undefined values\n        if (options != null) // Extend the base object\n        for(name in options){\n            src = $adfeb8f4e98e800c$var$getProperty(target, name);\n            copy = $adfeb8f4e98e800c$var$getProperty(options, name);\n            // Prevent never-ending loop\n            if (target !== copy) {\n                // Recurse if we're merging plain objects or arrays\n                if (deep && copy && ($adfeb8f4e98e800c$var$isPlainObject(copy) || (copyIsArray = $adfeb8f4e98e800c$var$isArray(copy)))) {\n                    if (copyIsArray) {\n                        copyIsArray = false;\n                        clone = src && $adfeb8f4e98e800c$var$isArray(src) ? src : [];\n                    } else clone = src && $adfeb8f4e98e800c$var$isPlainObject(src) ? src : {};\n                    // Never move original objects, clone them\n                    $adfeb8f4e98e800c$var$setProperty(target, {\n                        name: name,\n                        newValue: extend(deep, clone, copy)\n                    });\n                // Don't bring in undefined values\n                } else if (typeof copy !== \"undefined\") $adfeb8f4e98e800c$var$setProperty(target, {\n                    name: name,\n                    newValue: copy\n                });\n            }\n        }\n    }\n    // Return the modified object\n    return target;\n};\n\n});\n\nparcelRequire.register(\"4ld8y\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $329350557b958064$export$2e2bcd8739ae039);\nfunction $329350557b958064$export$2e2bcd8739ae039(value) {\n    if (typeof value !== \"object\" || value === null) return false;\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n\n});\n\nparcelRequire.register(\"gpg7e\", function(module, exports) {\n\n$parcel$export(module.exports, \"trough\", () => $bf1b7b5cf378e900$export$91b56f5ca106aa43);\n/**\n * @typedef {(error?: Error|null|undefined, ...output: Array<any>) => void} Callback\n * @typedef {(...input: Array<any>) => any} Middleware\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add `fn` (middleware) to the list.\n * @typedef {{run: Run, use: Use}} Pipeline\n *   Middleware.\n */ /**\n * Create new middleware.\n *\n * @returns {Pipeline}\n */ function $bf1b7b5cf378e900$export$91b56f5ca106aa43() {\n    /** @type {Array<Middleware>} */ const fns = [];\n    /** @type {Pipeline} */ const pipeline = {\n        run: run,\n        use: use\n    };\n    return pipeline;\n    /** @type {Run} */ function run(...values) {\n        let middlewareIndex = -1;\n        /** @type {Callback} */ const callback = values.pop();\n        if (typeof callback !== \"function\") throw new TypeError(\"Expected function as last argument, not \" + callback);\n        next(null, ...values);\n        /**\n     * Run the next `fn`, or were done.\n     *\n     * @param {Error|null|undefined} error\n     * @param {Array<any>} output\n     */ function next(error, ...output) {\n            const fn = fns[++middlewareIndex];\n            let index = -1;\n            if (error) {\n                callback(error);\n                return;\n            }\n            // Copy non-nullish input into values.\n            while(++index < values.length)if (output[index] === null || output[index] === undefined) output[index] = values[index];\n            // Save the newly created `output` for the next call.\n            values = output;\n            // Next or done.\n            if (fn) $bf1b7b5cf378e900$export$4997ffc0176396a6(fn, next)(...output);\n            else callback(null, ...output);\n        }\n    }\n    /** @type {Use} */ function use(middelware) {\n        if (typeof middelware !== \"function\") throw new TypeError(\"Expected `middelware` to be a function, not \" + middelware);\n        fns.push(middelware);\n        return pipeline;\n    }\n}\nfunction $bf1b7b5cf378e900$export$4997ffc0176396a6(middleware, callback) {\n    /** @type {boolean} */ let called;\n    return wrapped;\n    /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */ function wrapped(...parameters) {\n        const fnExpectsCallback = middleware.length > parameters.length;\n        /** @type {any} */ let result;\n        if (fnExpectsCallback) parameters.push(done);\n        try {\n            result = middleware.apply(this, parameters);\n        } catch (error) {\n            const exception = /** @type {Error} */ error;\n            // Well, this is quite the pickle.\n            // `middleware` received a callback and called it synchronously, but that\n            // threw an error.\n            // The only thing left to do is to throw the thing instead.\n            if (fnExpectsCallback && called) throw exception;\n            return done(exception);\n        }\n        if (!fnExpectsCallback) {\n            if (result instanceof Promise) result.then(then, done);\n            else if (result instanceof Error) done(result);\n            else then(result);\n        }\n    }\n    /**\n   * Call `callback`, only once.\n   * @type {Callback}\n   */ function done(error, ...output) {\n        if (!called) {\n            called = true;\n            callback(error, ...output);\n        }\n    }\n    /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */ function then(value) {\n        done(null, value);\n    }\n}\n\n});\n\n\nparcelRequire.register(\"73kRC\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $5228ff543a462260$export$2e2bcd8739ae039);\n\nvar $dMaXS = parcelRequire(\"dMaXS\");\nvar $5228ff543a462260$export$2e2bcd8739ae039 = (0, $dMaXS.default);\n\n});\nparcelRequire.register(\"dMaXS\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $a07843732b3ecc17$export$2e2bcd8739ae039);\n/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-from-markdown').Options} Options\n */ \nvar $1YdnK = parcelRequire(\"1YdnK\");\nfunction $a07843732b3ecc17$export$2e2bcd8739ae039(options) {\n    /** @type {import('unified').ParserFunction<Root>} */ const parser = (doc)=>{\n        // Assume options.\n        const settings = /** @type {Options} */ this.data(\"settings\");\n        return (0, $1YdnK.fromMarkdown)(doc, Object.assign({}, settings, options, {\n            // Note: these options are not in the readme.\n            // The goal is for them to be set by plugins on `data` instead of being\n            // passed by users.\n            extensions: this.data(\"micromarkExtensions\") || [],\n            mdastExtensions: this.data(\"fromMarkdownExtensions\") || []\n        }));\n    };\n    Object.assign(this, {\n        Parser: parser\n    });\n}\n\n});\nparcelRequire.register(\"1YdnK\", function(module, exports) {\n\n$parcel$export(module.exports, \"fromMarkdown\", () => $16f5c6747a84503c$export$d744d789c09bfde6);\n/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('../index.js').CompileData} CompileData\n */ /**\n * @typedef {Root | Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n *\n * @typedef {Omit<UnistParent, 'type' | 'children'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */ /**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | undefined | null | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isnt closed properly.\n */ /**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Node | Fragment>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {<Key extends keyof CompileData>(key: Key) => CompileData[Key]} getData\n *   Get data from the key/value store.\n * @property {<Key extends keyof CompileData>(key: Key, value?: CompileData[Key]) => void} setData\n *   Set data into the key/value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<Kind extends Node>(this: CompileContext, node: Kind, token: Token, onError?: OnEnterError) => Kind} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */ // To do: micromark: create a registry of tokens?\n// To do: next major: dont return given `Node` from `enter`.\n// To do: next major: remove setter/getter.\n\nvar $2lcqI = parcelRequire(\"2lcqI\");\n\nvar $cTtHt = parcelRequire(\"cTtHt\");\n\nvar $lw7ce = parcelRequire(\"lw7ce\");\n\nvar $3gGaD = parcelRequire(\"3gGaD\");\n\nvar $gZtaX = parcelRequire(\"gZtaX\");\n\nvar $8OH7a = parcelRequire(\"8OH7a\");\n\nvar $3ac70 = parcelRequire(\"3ac70\");\n\nvar $3HEPL = parcelRequire(\"3HEPL\");\n\nvar $gHjNW = parcelRequire(\"gHjNW\");\nconst $16f5c6747a84503c$var$own = {}.hasOwnProperty;\nconst $16f5c6747a84503c$export$d744d789c09bfde6 = /**\n   * @type {(\n   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &\n   *   ((value: Value, options?: Options | null | undefined) => Root)\n   * )}\n   */ /**\n   * @param {Value} value\n   * @param {Encoding | Options | null | undefined} [encoding]\n   * @param {Options | null | undefined} [options]\n   * @returns {Root}\n   */ function(value, encoding, options) {\n    if (typeof encoding !== \"string\") {\n        options = encoding;\n        encoding = undefined;\n    }\n    return $16f5c6747a84503c$var$compiler(options)((0, $3gGaD.postprocess)(// @ts-expect-error: micromark types need to accept `null`.\n    (0, $cTtHt.parse)(options).document().write((0, $lw7ce.preprocess)()(value, encoding, true))));\n};\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */ function $16f5c6747a84503c$var$compiler(options) {\n    /** @type {Config} */ const config = {\n        transforms: [],\n        canContainEols: [\n            \"emphasis\",\n            \"fragment\",\n            \"heading\",\n            \"paragraph\",\n            \"strong\"\n        ],\n        enter: {\n            autolink: opener(link),\n            autolinkProtocol: onenterdata,\n            autolinkEmail: onenterdata,\n            atxHeading: opener(heading),\n            blockQuote: opener(blockQuote),\n            characterEscape: onenterdata,\n            characterReference: onenterdata,\n            codeFenced: opener(codeFlow),\n            codeFencedFenceInfo: buffer,\n            codeFencedFenceMeta: buffer,\n            codeIndented: opener(codeFlow, buffer),\n            codeText: opener(codeText, buffer),\n            codeTextData: onenterdata,\n            data: onenterdata,\n            codeFlowValue: onenterdata,\n            definition: opener(definition),\n            definitionDestinationString: buffer,\n            definitionLabelString: buffer,\n            definitionTitleString: buffer,\n            emphasis: opener(emphasis),\n            hardBreakEscape: opener(hardBreak),\n            hardBreakTrailing: opener(hardBreak),\n            htmlFlow: opener(html, buffer),\n            htmlFlowData: onenterdata,\n            htmlText: opener(html, buffer),\n            htmlTextData: onenterdata,\n            image: opener(image),\n            label: buffer,\n            link: opener(link),\n            listItem: opener(listItem),\n            listItemValue: onenterlistitemvalue,\n            listOrdered: opener(list, onenterlistordered),\n            listUnordered: opener(list),\n            paragraph: opener(paragraph),\n            reference: onenterreference,\n            referenceString: buffer,\n            resourceDestinationString: buffer,\n            resourceTitleString: buffer,\n            setextHeading: opener(heading),\n            strong: opener(strong),\n            thematicBreak: opener(thematicBreak)\n        },\n        exit: {\n            atxHeading: closer(),\n            atxHeadingSequence: onexitatxheadingsequence,\n            autolink: closer(),\n            autolinkEmail: onexitautolinkemail,\n            autolinkProtocol: onexitautolinkprotocol,\n            blockQuote: closer(),\n            characterEscapeValue: onexitdata,\n            characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n            characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n            characterReferenceValue: onexitcharacterreferencevalue,\n            codeFenced: closer(onexitcodefenced),\n            codeFencedFence: onexitcodefencedfence,\n            codeFencedFenceInfo: onexitcodefencedfenceinfo,\n            codeFencedFenceMeta: onexitcodefencedfencemeta,\n            codeFlowValue: onexitdata,\n            codeIndented: closer(onexitcodeindented),\n            codeText: closer(onexitcodetext),\n            codeTextData: onexitdata,\n            data: onexitdata,\n            definition: closer(),\n            definitionDestinationString: onexitdefinitiondestinationstring,\n            definitionLabelString: onexitdefinitionlabelstring,\n            definitionTitleString: onexitdefinitiontitlestring,\n            emphasis: closer(),\n            hardBreakEscape: closer(onexithardbreak),\n            hardBreakTrailing: closer(onexithardbreak),\n            htmlFlow: closer(onexithtmlflow),\n            htmlFlowData: onexitdata,\n            htmlText: closer(onexithtmltext),\n            htmlTextData: onexitdata,\n            image: closer(onexitimage),\n            label: onexitlabel,\n            labelText: onexitlabeltext,\n            lineEnding: onexitlineending,\n            link: closer(onexitlink),\n            listItem: closer(),\n            listOrdered: closer(),\n            listUnordered: closer(),\n            paragraph: closer(),\n            referenceString: onexitreferencestring,\n            resourceDestinationString: onexitresourcedestinationstring,\n            resourceTitleString: onexitresourcetitlestring,\n            resource: onexitresource,\n            setextHeading: closer(onexitsetextheading),\n            setextHeadingLineSequence: onexitsetextheadinglinesequence,\n            setextHeadingText: onexitsetextheadingtext,\n            strong: closer(),\n            thematicBreak: closer()\n        }\n    };\n    $16f5c6747a84503c$var$configure(config, (options || {}).mdastExtensions || []);\n    /** @type {CompileData} */ const data = {};\n    return compile;\n    /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */ function compile(events) {\n        /** @type {Root} */ let tree = {\n            type: \"root\",\n            children: []\n        };\n        /** @type {Omit<CompileContext, 'sliceSerialize'>} */ const context = {\n            stack: [\n                tree\n            ],\n            tokenStack: [],\n            config: config,\n            enter: enter,\n            exit: exit,\n            buffer: buffer,\n            resume: resume,\n            setData: setData,\n            getData: getData\n        };\n        /** @type {Array<number>} */ const listStack = [];\n        let index = -1;\n        while(++index < events.length)// We preprocess lists to add `listItem` tokens, and to infer whether\n        // items the list itself are spread out.\n        if (events[index][1].type === \"listOrdered\" || events[index][1].type === \"listUnordered\") {\n            if (events[index][0] === \"enter\") listStack.push(index);\n            else {\n                const tail = listStack.pop();\n                index = prepareList(events, tail, index);\n            }\n        }\n        index = -1;\n        while(++index < events.length){\n            const handler = config[events[index][0]];\n            if ($16f5c6747a84503c$var$own.call(handler, events[index][1].type)) handler[events[index][1].type].call(Object.assign({\n                sliceSerialize: events[index][2].sliceSerialize\n            }, context), events[index][1]);\n        }\n        // Handle tokens still being open.\n        if (context.tokenStack.length > 0) {\n            const tail = context.tokenStack[context.tokenStack.length - 1];\n            const handler = tail[1] || $16f5c6747a84503c$var$defaultOnError;\n            handler.call(context, undefined, tail[0]);\n        }\n        // Figure out `root` position.\n        tree.position = {\n            start: $16f5c6747a84503c$var$point(events.length > 0 ? events[0][1].start : {\n                line: 1,\n                column: 1,\n                offset: 0\n            }),\n            end: $16f5c6747a84503c$var$point(events.length > 0 ? events[events.length - 2][1].end : {\n                line: 1,\n                column: 1,\n                offset: 0\n            })\n        };\n        // Call transforms.\n        index = -1;\n        while(++index < config.transforms.length)tree = config.transforms[index](tree) || tree;\n        return tree;\n    }\n    /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */ function prepareList(events, start, length) {\n        let index = start - 1;\n        let containerBalance = -1;\n        let listSpread = false;\n        /** @type {Token | undefined} */ let listItem;\n        /** @type {number | undefined} */ let lineIndex;\n        /** @type {number | undefined} */ let firstBlankLineIndex;\n        /** @type {boolean | undefined} */ let atMarker;\n        while(++index <= length){\n            const event = events[index];\n            if (event[1].type === \"listUnordered\" || event[1].type === \"listOrdered\" || event[1].type === \"blockQuote\") {\n                if (event[0] === \"enter\") containerBalance++;\n                else containerBalance--;\n                atMarker = undefined;\n            } else if (event[1].type === \"lineEndingBlank\") {\n                if (event[0] === \"enter\") {\n                    if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) firstBlankLineIndex = index;\n                    atMarker = undefined;\n                }\n            } else if (event[1].type === \"linePrefix\" || event[1].type === \"listItemValue\" || event[1].type === \"listItemMarker\" || event[1].type === \"listItemPrefix\" || event[1].type === \"listItemPrefixWhitespace\") ;\n            else atMarker = undefined;\n            if (!containerBalance && event[0] === \"enter\" && event[1].type === \"listItemPrefix\" || containerBalance === -1 && event[0] === \"exit\" && (event[1].type === \"listUnordered\" || event[1].type === \"listOrdered\")) {\n                if (listItem) {\n                    let tailIndex = index;\n                    lineIndex = undefined;\n                    while(tailIndex--){\n                        const tailEvent = events[tailIndex];\n                        if (tailEvent[1].type === \"lineEnding\" || tailEvent[1].type === \"lineEndingBlank\") {\n                            if (tailEvent[0] === \"exit\") continue;\n                            if (lineIndex) {\n                                events[lineIndex][1].type = \"lineEndingBlank\";\n                                listSpread = true;\n                            }\n                            tailEvent[1].type = \"lineEnding\";\n                            lineIndex = tailIndex;\n                        } else if (tailEvent[1].type === \"linePrefix\" || tailEvent[1].type === \"blockQuotePrefix\" || tailEvent[1].type === \"blockQuotePrefixWhitespace\" || tailEvent[1].type === \"blockQuoteMarker\" || tailEvent[1].type === \"listItemIndent\") ;\n                        else break;\n                    }\n                    if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) // @ts-expect-error Patched.\n                    listItem._spread = true;\n                    // Fix position.\n                    listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n                    events.splice(lineIndex || index, 0, [\n                        \"exit\",\n                        listItem,\n                        event[2]\n                    ]);\n                    index++;\n                    length++;\n                }\n                // Create a new list item.\n                if (event[1].type === \"listItemPrefix\") {\n                    listItem = {\n                        type: \"listItem\",\n                        // @ts-expect-error Patched\n                        _spread: false,\n                        start: Object.assign({}, event[1].start)\n                    };\n                    // @ts-expect-error: `listItem` is most definitely defined, TS...\n                    events.splice(index, 0, [\n                        \"enter\",\n                        listItem,\n                        event[2]\n                    ]);\n                    index++;\n                    length++;\n                    firstBlankLineIndex = undefined;\n                    atMarker = true;\n                }\n            }\n        }\n        // @ts-expect-error Patched.\n        events[start][1]._spread = listSpread;\n        return length;\n    }\n    /**\n   * Set data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @param {CompileData[Key]} [value]\n   *   New value.\n   * @returns {void}\n   *   Nothing.\n   */ function setData(key, value) {\n        data[key] = value;\n    }\n    /**\n   * Get data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @returns {CompileData[Key]}\n   *   Value.\n   */ function getData(key) {\n        return data[key];\n    }\n    /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Node} create\n   *   Create a node.\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */ function opener(create, and) {\n        return open;\n        /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */ function open(token) {\n            enter.call(this, create(token), token);\n            if (and) and.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @returns {void}\n   */ function buffer() {\n        this.stack.push({\n            type: \"fragment\",\n            children: []\n        });\n    }\n    /**\n   * @template {Node} Kind\n   *   Node type.\n   * @this {CompileContext}\n   *   Context.\n   * @param {Kind} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {Kind}\n   *   The given node.\n   */ function enter(node, token, errorHandler) {\n        const parent = this.stack[this.stack.length - 1];\n        // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n        parent.children.push(node);\n        this.stack.push(node);\n        this.tokenStack.push([\n            token,\n            errorHandler\n        ]);\n        // @ts-expect-error: `end` will be patched later.\n        node.position = {\n            start: $16f5c6747a84503c$var$point(token.start)\n        };\n        return node;\n    }\n    /**\n   * Create a closer handle.\n   *\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */ function closer(and) {\n        return close;\n        /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */ function close(token) {\n            if (and) and.call(this, token);\n            exit.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {Node}\n   *   The closed node.\n   */ function exit(token, onExitError) {\n        const node = this.stack.pop();\n        const open = this.tokenStack.pop();\n        if (!open) throw new Error(\"Cannot close `\" + token.type + \"` (\" + (0, $gHjNW.stringifyPosition)({\n            start: token.start,\n            end: token.end\n        }) + \"): its not open\");\n        else if (open[0].type !== token.type) {\n            if (onExitError) onExitError.call(this, token, open[0]);\n            else {\n                const handler = open[1] || $16f5c6747a84503c$var$defaultOnError;\n                handler.call(this, token, open[0]);\n            }\n        }\n        node.position.end = $16f5c6747a84503c$var$point(token.end);\n        return node;\n    }\n    /**\n   * @this {CompileContext}\n   * @returns {string}\n   */ function resume() {\n        return (0, $2lcqI.toString)(this.stack.pop());\n    }\n    //\n    // Handlers.\n    //\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterlistordered() {\n        setData(\"expectingFirstListItemValue\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterlistitemvalue(token) {\n        if (getData(\"expectingFirstListItemValue\")) {\n            const ancestor = this.stack[this.stack.length - 2];\n            ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);\n            setData(\"expectingFirstListItemValue\");\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfenceinfo() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        node.lang = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfencemeta() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        node.meta = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfence() {\n        // Exit if this is the closing fence.\n        if (getData(\"flowCodeInside\")) return;\n        this.buffer();\n        setData(\"flowCodeInside\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefenced() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, \"\");\n        setData(\"flowCodeInside\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodeindented() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        node.value = data.replace(/(\\r?\\n|\\r)$/g, \"\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitionlabelstring(token) {\n        const label = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        node.label = label;\n        node.identifier = (0, $3ac70.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitiontitlestring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        node.title = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitiondestinationstring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        node.url = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitatxheadingsequence(token) {\n        const node = this.stack[this.stack.length - 1];\n        if (!node.depth) {\n            const depth = this.sliceSerialize(token).length;\n            node.depth = depth;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheadingtext() {\n        setData(\"setextHeadingSlurpLineEnding\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheadinglinesequence(token) {\n        const node = this.stack[this.stack.length - 1];\n        node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheading() {\n        setData(\"setextHeadingSlurpLineEnding\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterdata(token) {\n        const node = this.stack[this.stack.length - 1];\n        let tail = node.children[node.children.length - 1];\n        if (!tail || tail.type !== \"text\") {\n            // Add a new text node.\n            tail = text();\n            // @ts-expect-error: well add `end` later.\n            tail.position = {\n                start: $16f5c6747a84503c$var$point(token.start)\n            };\n            // @ts-expect-error: Assume `parent` accepts `text`.\n            node.children.push(tail);\n        }\n        this.stack.push(tail);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdata(token) {\n        const tail = this.stack.pop();\n        tail.value += this.sliceSerialize(token);\n        tail.position.end = $16f5c6747a84503c$var$point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlineending(token) {\n        const context = this.stack[this.stack.length - 1];\n        // If were at a hard break, include the line ending in there.\n        if (getData(\"atHardBreak\")) {\n            const tail = context.children[context.children.length - 1];\n            tail.position.end = $16f5c6747a84503c$var$point(token.end);\n            setData(\"atHardBreak\");\n            return;\n        }\n        if (!getData(\"setextHeadingSlurpLineEnding\") && config.canContainEols.includes(context.type)) {\n            onenterdata.call(this, token);\n            onexitdata.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithardbreak() {\n        setData(\"atHardBreak\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithtmlflow() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithtmltext() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodetext() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlink() {\n        const node = this.stack[this.stack.length - 1];\n        // Note: there are also `identifier` and `label` fields on this link node!\n        // These are used / cleaned here.\n        // To do: clean.\n        if (getData(\"inReference\")) {\n            /** @type {ReferenceType} */ const referenceType = getData(\"referenceType\") || \"shortcut\";\n            node.type += \"Reference\";\n            // @ts-expect-error: mutate.\n            node.referenceType = referenceType;\n            // @ts-expect-error: mutate.\n            delete node.url;\n            delete node.title;\n        } else {\n            // @ts-expect-error: mutate.\n            delete node.identifier;\n            // @ts-expect-error: mutate.\n            delete node.label;\n        }\n        setData(\"referenceType\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitimage() {\n        const node = this.stack[this.stack.length - 1];\n        // Note: there are also `identifier` and `label` fields on this link node!\n        // These are used / cleaned here.\n        // To do: clean.\n        if (getData(\"inReference\")) {\n            /** @type {ReferenceType} */ const referenceType = getData(\"referenceType\") || \"shortcut\";\n            node.type += \"Reference\";\n            // @ts-expect-error: mutate.\n            node.referenceType = referenceType;\n            // @ts-expect-error: mutate.\n            delete node.url;\n            delete node.title;\n        } else {\n            // @ts-expect-error: mutate.\n            delete node.identifier;\n            // @ts-expect-error: mutate.\n            delete node.label;\n        }\n        setData(\"referenceType\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlabeltext(token) {\n        const string = this.sliceSerialize(token);\n        const ancestor = this.stack[this.stack.length - 2];\n        // @ts-expect-error: stash this on the node, as it might become a reference\n        // later.\n        ancestor.label = (0, $8OH7a.decodeString)(string);\n        // @ts-expect-error: same as above.\n        ancestor.identifier = (0, $3ac70.normalizeIdentifier)(string).toLowerCase();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlabel() {\n        const fragment = this.stack[this.stack.length - 1];\n        const value = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        // Assume a reference.\n        setData(\"inReference\", true);\n        if (node.type === \"link\") {\n            /** @type {Array<StaticPhrasingContent>} */ // @ts-expect-error: Assume static phrasing content.\n            const children = fragment.children;\n            node.children = children;\n        } else node.alt = value;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresourcedestinationstring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        node.url = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresourcetitlestring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        node.title = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresource() {\n        setData(\"inReference\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterreference() {\n        setData(\"referenceType\", \"collapsed\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitreferencestring(token) {\n        const label = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        // @ts-expect-error: stash this on the node, as it might become a reference\n        // later.\n        node.label = label;\n        // @ts-expect-error: same as above.\n        node.identifier = (0, $3ac70.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n        setData(\"referenceType\", \"full\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcharacterreferencemarker(token) {\n        setData(\"characterReferenceType\", token.type);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcharacterreferencevalue(token) {\n        const data = this.sliceSerialize(token);\n        const type = getData(\"characterReferenceType\");\n        /** @type {string} */ let value;\n        if (type) {\n            value = (0, $gZtaX.decodeNumericCharacterReference)(data, type === \"characterReferenceMarkerNumeric\" ? 10 : 16);\n            setData(\"characterReferenceType\");\n        } else {\n            const result = (0, $3HEPL.decodeNamedCharacterReference)(data);\n            value = result;\n        }\n        const tail = this.stack.pop();\n        tail.value += value;\n        tail.position.end = $16f5c6747a84503c$var$point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitautolinkprotocol(token) {\n        onexitdata.call(this, token);\n        const node = this.stack[this.stack.length - 1];\n        node.url = this.sliceSerialize(token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitautolinkemail(token) {\n        onexitdata.call(this, token);\n        const node = this.stack[this.stack.length - 1];\n        node.url = \"mailto:\" + this.sliceSerialize(token);\n    }\n    //\n    // Creaters.\n    //\n    /** @returns {Blockquote} */ function blockQuote() {\n        return {\n            type: \"blockquote\",\n            children: []\n        };\n    }\n    /** @returns {Code} */ function codeFlow() {\n        return {\n            type: \"code\",\n            lang: null,\n            meta: null,\n            value: \"\"\n        };\n    }\n    /** @returns {InlineCode} */ function codeText() {\n        return {\n            type: \"inlineCode\",\n            value: \"\"\n        };\n    }\n    /** @returns {Definition} */ function definition() {\n        return {\n            type: \"definition\",\n            identifier: \"\",\n            label: null,\n            title: null,\n            url: \"\"\n        };\n    }\n    /** @returns {Emphasis} */ function emphasis() {\n        return {\n            type: \"emphasis\",\n            children: []\n        };\n    }\n    /** @returns {Heading} */ function heading() {\n        // @ts-expect-error `depth` will be set later.\n        return {\n            type: \"heading\",\n            depth: undefined,\n            children: []\n        };\n    }\n    /** @returns {Break} */ function hardBreak() {\n        return {\n            type: \"break\"\n        };\n    }\n    /** @returns {HTML} */ function html() {\n        return {\n            type: \"html\",\n            value: \"\"\n        };\n    }\n    /** @returns {Image} */ function image() {\n        return {\n            type: \"image\",\n            title: null,\n            url: \"\",\n            alt: null\n        };\n    }\n    /** @returns {Link} */ function link() {\n        return {\n            type: \"link\",\n            title: null,\n            url: \"\",\n            children: []\n        };\n    }\n    /**\n   * @param {Token} token\n   * @returns {List}\n   */ function list(token) {\n        return {\n            type: \"list\",\n            ordered: token.type === \"listOrdered\",\n            start: null,\n            // @ts-expect-error Patched.\n            spread: token._spread,\n            children: []\n        };\n    }\n    /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */ function listItem(token) {\n        return {\n            type: \"listItem\",\n            // @ts-expect-error Patched.\n            spread: token._spread,\n            checked: null,\n            children: []\n        };\n    }\n    /** @returns {Paragraph} */ function paragraph() {\n        return {\n            type: \"paragraph\",\n            children: []\n        };\n    }\n    /** @returns {Strong} */ function strong() {\n        return {\n            type: \"strong\",\n            children: []\n        };\n    }\n    /** @returns {Text} */ function text() {\n        return {\n            type: \"text\",\n            value: \"\"\n        };\n    }\n    /** @returns {ThematicBreak} */ function thematicBreak() {\n        return {\n            type: \"thematicBreak\"\n        };\n    }\n}\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */ function $16f5c6747a84503c$var$point(d) {\n    return {\n        line: d.line,\n        column: d.column,\n        offset: d.offset\n    };\n}\n/**\n * @param {Config} combined\n * @param {Array<Extension | Array<Extension>>} extensions\n * @returns {void}\n */ function $16f5c6747a84503c$var$configure(combined, extensions) {\n    let index = -1;\n    while(++index < extensions.length){\n        const value = extensions[index];\n        if (Array.isArray(value)) $16f5c6747a84503c$var$configure(combined, value);\n        else $16f5c6747a84503c$var$extension(combined, value);\n    }\n}\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {void}\n */ function $16f5c6747a84503c$var$extension(combined, extension) {\n    /** @type {keyof Extension} */ let key;\n    for(key in extension)if ($16f5c6747a84503c$var$own.call(extension, key)) {\n        if (key === \"canContainEols\") {\n            const right = extension[key];\n            if (right) combined[key].push(...right);\n        } else if (key === \"transforms\") {\n            const right = extension[key];\n            if (right) combined[key].push(...right);\n        } else if (key === \"enter\" || key === \"exit\") {\n            const right = extension[key];\n            if (right) Object.assign(combined[key], right);\n        }\n    }\n}\n/** @type {OnEnterError} */ function $16f5c6747a84503c$var$defaultOnError(left, right) {\n    if (left) throw new Error(\"Cannot close `\" + left.type + \"` (\" + (0, $gHjNW.stringifyPosition)({\n        start: left.start,\n        end: left.end\n    }) + \"): a different token (`\" + right.type + \"`, \" + (0, $gHjNW.stringifyPosition)({\n        start: right.start,\n        end: right.end\n    }) + \") is open\");\n    else throw new Error(\"Cannot close document, a token (`\" + right.type + \"`, \" + (0, $gHjNW.stringifyPosition)({\n        start: right.start,\n        end: right.end\n    }) + \") is still open\");\n}\n\n});\nparcelRequire.register(\"2lcqI\", function(module, exports) {\n\n$parcel$export(module.exports, \"toString\", () => $1b472f46fc8ca74f$export$f84e8e69fd4488a5);\n/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s.\n */ /**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the nodes plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} value\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */ function $1b472f46fc8ca74f$export$f84e8e69fd4488a5(value, options) {\n    const includeImageAlt = (options || {}).includeImageAlt;\n    return $1b472f46fc8ca74f$var$one(value, typeof includeImageAlt === \"boolean\" ? includeImageAlt : true);\n}\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @returns {string}\n *   Serialized node.\n */ function $1b472f46fc8ca74f$var$one(value, includeImageAlt) {\n    return $1b472f46fc8ca74f$var$node(value) && (\"value\" in value && value.value || includeImageAlt && \"alt\" in value && value.alt || \"children\" in value && $1b472f46fc8ca74f$var$all(value.children, includeImageAlt)) || Array.isArray(value) && $1b472f46fc8ca74f$var$all(value, includeImageAlt) || \"\";\n}\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @returns {string}\n *   Serialized nodes.\n */ function $1b472f46fc8ca74f$var$all(values, includeImageAlt) {\n    /** @type {Array<string>} */ const result = [];\n    let index = -1;\n    while(++index < values.length)result[index] = $1b472f46fc8ca74f$var$one(values[index], includeImageAlt);\n    return result.join(\"\");\n}\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Node}\n *   Whether `value` is a node.\n */ function $1b472f46fc8ca74f$var$node(value) {\n    return Boolean(value && typeof value === \"object\");\n}\n\n});\n\nparcelRequire.register(\"cTtHt\", function(module, exports) {\n\n$parcel$export(module.exports, \"parse\", () => $9631a8efb162102f$export$98e6a39c04603d36);\n/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').FullNormalizedExtension} FullNormalizedExtension\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').ParseContext} ParseContext\n * @typedef {import('micromark-util-types').Create} Create\n */ \nvar $9UGYc = parcelRequire(\"9UGYc\");\n\nvar $2oNzp = parcelRequire(\"2oNzp\");\n\nvar $lAK8r = parcelRequire(\"lAK8r\");\n\nvar $gxpzI = parcelRequire(\"gxpzI\");\n\nvar $l2tD0 = parcelRequire(\"l2tD0\");\n\nvar $8MiTe = parcelRequire(\"8MiTe\");\n\nvar $6HWiY = parcelRequire(\"6HWiY\");\nfunction $9631a8efb162102f$export$98e6a39c04603d36(options = {}) {\n    /** @type {FullNormalizedExtension} */ // @ts-expect-error `defaultConstructs` is full, so the result will be too.\n    const constructs = (0, $9UGYc.combineExtensions)(// @ts-expect-error Same as above.\n    [\n        $6HWiY\n    ].concat(options.extensions || []));\n    /** @type {ParseContext} */ const parser = {\n        defined: [],\n        lazy: {},\n        constructs: constructs,\n        content: create((0, $2oNzp.content)),\n        document: create((0, $lAK8r.document)),\n        flow: create((0, $gxpzI.flow)),\n        string: create((0, $l2tD0.string)),\n        text: create((0, $l2tD0.text))\n    };\n    return parser;\n    /**\n   * @param {InitialConstruct} initial\n   */ function create(initial) {\n        return creator;\n        /** @type {Create} */ function creator(from) {\n            return (0, $8MiTe.createTokenizer)(parser, initial, from);\n        }\n    }\n}\n\n});\nparcelRequire.register(\"9UGYc\", function(module, exports) {\n\n$parcel$export(module.exports, \"combineExtensions\", () => $737aacf765ba6d74$export$86a865d89ef3c690);\n/**\n * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */ \nvar $2Qp1S = parcelRequire(\"2Qp1S\");\nconst $737aacf765ba6d74$var$hasOwnProperty = {}.hasOwnProperty;\nfunction $737aacf765ba6d74$export$86a865d89ef3c690(extensions) {\n    /** @type {NormalizedExtension} */ const all = {};\n    let index = -1;\n    while(++index < extensions.length)$737aacf765ba6d74$var$syntaxExtension(all, extensions[index]);\n    return all;\n}\n/**\n * Merge `extension` into `all`.\n *\n * @param {NormalizedExtension} all Extension to merge into.\n * @param {Extension} extension Extension to merge.\n * @returns {void}\n */ function $737aacf765ba6d74$var$syntaxExtension(all, extension) {\n    /** @type {string} */ let hook;\n    for(hook in extension){\n        const maybe = $737aacf765ba6d74$var$hasOwnProperty.call(all, hook) ? all[hook] : undefined;\n        const left = maybe || (all[hook] = {});\n        const right = extension[hook];\n        /** @type {string} */ let code;\n        for(code in right){\n            if (!$737aacf765ba6d74$var$hasOwnProperty.call(left, code)) left[code] = [];\n            const value = right[code];\n            $737aacf765ba6d74$var$constructs(// @ts-expect-error Looks like a list.\n            left[code], Array.isArray(value) ? value : value ? [\n                value\n            ] : []);\n        }\n    }\n}\n/**\n * Merge `list` into `existing` (both lists of constructs).\n * Mutates `existing`.\n *\n * @param {unknown[]} existing\n * @param {unknown[]} list\n * @returns {void}\n */ function $737aacf765ba6d74$var$constructs(existing, list) {\n    let index = -1;\n    /** @type {unknown[]} */ const before = [];\n    while(++index < list.length)(list[index].add === \"after\" ? existing : before).push(list[index]);\n    (0, $2Qp1S.splice)(existing, 0, 0, before);\n}\nfunction $737aacf765ba6d74$export$eaf8c406dfb0a620(htmlExtensions) {\n    /** @type {HtmlExtension} */ const handlers = {};\n    let index = -1;\n    while(++index < htmlExtensions.length)$737aacf765ba6d74$var$htmlExtension(handlers, htmlExtensions[index]);\n    return handlers;\n}\n/**\n * Merge `extension` into `all`.\n *\n * @param {HtmlExtension} all Extension to merge into.\n * @param {HtmlExtension} extension Extension to merge.\n * @returns {void}\n */ function $737aacf765ba6d74$var$htmlExtension(all, extension) {\n    /** @type {string} */ let hook;\n    for(hook in extension){\n        const maybe = $737aacf765ba6d74$var$hasOwnProperty.call(all, hook) ? all[hook] : undefined;\n        const left = maybe || (all[hook] = {});\n        const right = extension[hook];\n        /** @type {string} */ let type;\n        if (right) for(type in right)left[type] = right[type];\n    }\n}\n\n});\nparcelRequire.register(\"2Qp1S\", function(module, exports) {\n\n$parcel$export(module.exports, \"splice\", () => $2123da67b38b8197$export$869882364835d202);\n$parcel$export(module.exports, \"push\", () => $2123da67b38b8197$export$4cbf152802aa238);\n/**\n * Like `Array#splice`, but smarter for giant arrays.\n *\n * `Array#splice` takes all items to be inserted as individual argument which\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\n *\n * Otherwise, this does not return the removed items, and takes `items` as an\n * array instead of rest parameters.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {number} start\n * @param {number} remove\n * @param {T[]} items\n * @returns {void}\n */ function $2123da67b38b8197$export$869882364835d202(list, start, remove, items) {\n    const end = list.length;\n    let chunkStart = 0;\n    /** @type {unknown[]} */ let parameters // Make start between zero and `end` (included).\n    ;\n    if (start < 0) start = -start > end ? 0 : end + start;\n    else start = start > end ? end : start;\n    remove = remove > 0 ? remove : 0 // No need to chunk the items if theres only a couple (10k) items.\n    ;\n    if (items.length < 10000) {\n        parameters = Array.from(items);\n        parameters.unshift(start, remove) // @ts-expect-error Hush, its fine.\n        ;\n        [].splice.apply(list, parameters);\n    } else {\n        // Delete `remove` items starting from `start`\n        if (remove) [].splice.apply(list, [\n            start,\n            remove\n        ]) // Insert the items in chunks to not cause stack overflows.\n        ;\n        while(chunkStart < items.length){\n            parameters = items.slice(chunkStart, chunkStart + 10000);\n            parameters.unshift(start, 0) // @ts-expect-error Hush, its fine.\n            ;\n            [].splice.apply(list, parameters);\n            chunkStart += 10000;\n            start += 10000;\n        }\n    }\n}\nfunction $2123da67b38b8197$export$4cbf152802aa238(list, items) {\n    if (list.length > 0) {\n        $2123da67b38b8197$export$869882364835d202(list, list.length, 0, items);\n        return list;\n    }\n    return items;\n}\n\n});\n\n\nparcelRequire.register(\"2oNzp\", function(module, exports) {\n\n$parcel$export(module.exports, \"content\", () => $1bf446438b8bfa65$export$a7db06668cad9adb);\n/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\nconst $1bf446438b8bfa65$export$a7db06668cad9adb = {\n    tokenize: $1bf446438b8bfa65$var$initializeContent\n};\n/** @type {Initializer} */ function $1bf446438b8bfa65$var$initializeContent(effects) {\n    const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);\n    /** @type {Token} */ let previous;\n    return contentStart;\n    /** @type {State} */ function afterContentStartConstruct(code) {\n        if (code === null) {\n            effects.consume(code);\n            return;\n        }\n        effects.enter(\"lineEnding\");\n        effects.consume(code);\n        effects.exit(\"lineEnding\");\n        return (0, $jH5RB.factorySpace)(effects, contentStart, \"linePrefix\");\n    }\n    /** @type {State} */ function paragraphInitial(code) {\n        effects.enter(\"paragraph\");\n        return lineStart(code);\n    }\n    /** @type {State} */ function lineStart(code) {\n        const token = effects.enter(\"chunkText\", {\n            contentType: \"text\",\n            previous: previous\n        });\n        if (previous) previous.next = token;\n        previous = token;\n        return data(code);\n    }\n    /** @type {State} */ function data(code) {\n        if (code === null) {\n            effects.exit(\"chunkText\");\n            effects.exit(\"paragraph\");\n            effects.consume(code);\n            return;\n        }\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            effects.consume(code);\n            effects.exit(\"chunkText\");\n            return lineStart;\n        } // Data.\n        effects.consume(code);\n        return data;\n    }\n}\n\n});\nparcelRequire.register(\"jH5RB\", function(module, exports) {\n\n$parcel$export(module.exports, \"factorySpace\", () => $e56694df1d786fea$export$ae105c1eb063a0a2);\n/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $iUvtM = parcelRequire(\"iUvtM\");\nfunction $e56694df1d786fea$export$ae105c1eb063a0a2(effects, ok, type, max) {\n    const limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n    let size = 0;\n    return start;\n    /** @type {State} */ function start(code) {\n        if ((0, $iUvtM.markdownSpace)(code)) {\n            effects.enter(type);\n            return prefix(code);\n        }\n        return ok(code);\n    }\n    /** @type {State} */ function prefix(code) {\n        if ((0, $iUvtM.markdownSpace)(code) && size++ < limit) {\n            effects.consume(code);\n            return prefix;\n        }\n        effects.exit(type);\n        return ok(code);\n    }\n}\n\n});\nparcelRequire.register(\"iUvtM\", function(module, exports) {\n\n$parcel$export(module.exports, \"asciiAlpha\", () => $dc45e01a14bb512b$export$d65d6b62c24d5436);\n$parcel$export(module.exports, \"asciiDigit\", () => $dc45e01a14bb512b$export$ca8b5b1a6c320e6e);\n$parcel$export(module.exports, \"asciiHexDigit\", () => $dc45e01a14bb512b$export$eca2752363989806);\n$parcel$export(module.exports, \"asciiAlphanumeric\", () => $dc45e01a14bb512b$export$75c76db11865a9f4);\n$parcel$export(module.exports, \"asciiPunctuation\", () => $dc45e01a14bb512b$export$35794a7d1db99380);\n$parcel$export(module.exports, \"asciiAtext\", () => $dc45e01a14bb512b$export$4397998b34fe597d);\n$parcel$export(module.exports, \"asciiControl\", () => $dc45e01a14bb512b$export$67dbf494fc8394df);\n$parcel$export(module.exports, \"markdownLineEndingOrSpace\", () => $dc45e01a14bb512b$export$a30284361b3814b7);\n$parcel$export(module.exports, \"markdownLineEnding\", () => $dc45e01a14bb512b$export$34a1dff1c0936953);\n$parcel$export(module.exports, \"markdownSpace\", () => $dc45e01a14bb512b$export$2c6cf65c1127992a);\n$parcel$export(module.exports, \"unicodeWhitespace\", () => $dc45e01a14bb512b$export$a0ff789c034ffdf4);\n$parcel$export(module.exports, \"unicodePunctuation\", () => $dc45e01a14bb512b$export$aa04114dd888a7a0);\n/**\n * @typedef {import('micromark-util-types').Code} Code\n */ \nvar $7No4A = parcelRequire(\"7No4A\");\nconst $dc45e01a14bb512b$export$d65d6b62c24d5436 = $dc45e01a14bb512b$var$regexCheck(/[A-Za-z]/);\nconst $dc45e01a14bb512b$export$ca8b5b1a6c320e6e = $dc45e01a14bb512b$var$regexCheck(/\\d/);\nconst $dc45e01a14bb512b$export$eca2752363989806 = $dc45e01a14bb512b$var$regexCheck(/[\\dA-Fa-f]/);\nconst $dc45e01a14bb512b$export$75c76db11865a9f4 = $dc45e01a14bb512b$var$regexCheck(/[\\dA-Za-z]/);\nconst $dc45e01a14bb512b$export$35794a7d1db99380 = $dc45e01a14bb512b$var$regexCheck(/[!-/:-@[-`{-~]/);\nconst $dc45e01a14bb512b$export$4397998b34fe597d = $dc45e01a14bb512b$var$regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\nfunction $dc45e01a14bb512b$export$67dbf494fc8394df(code) {\n    return(// Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127));\n}\nfunction $dc45e01a14bb512b$export$a30284361b3814b7(code) {\n    return code !== null && (code < 0 || code === 32);\n}\nfunction $dc45e01a14bb512b$export$34a1dff1c0936953(code) {\n    return code !== null && code < -2;\n}\nfunction $dc45e01a14bb512b$export$2c6cf65c1127992a(code) {\n    return code === -2 || code === -1 || code === 32;\n}\nconst $dc45e01a14bb512b$export$a0ff789c034ffdf4 = $dc45e01a14bb512b$var$regexCheck(/\\s/);\nconst $dc45e01a14bb512b$export$aa04114dd888a7a0 = $dc45e01a14bb512b$var$regexCheck((0, $7No4A.unicodePunctuationRegex));\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */ function $dc45e01a14bb512b$var$regexCheck(regex) {\n    return check;\n    /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */ function check(code) {\n        return code !== null && regex.test(String.fromCharCode(code));\n    }\n}\n\n});\nparcelRequire.register(\"7No4A\", function(module, exports) {\n\n$parcel$export(module.exports, \"unicodePunctuationRegex\", () => $5acfc86363294f46$export$85b5101f24802e8c);\n// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\nconst $5acfc86363294f46$export$85b5101f24802e8c = /[!-/:-@[-`{-~\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\n\n});\n\n\n\n\nparcelRequire.register(\"lAK8r\", function(module, exports) {\n\n$parcel$export(module.exports, \"document\", () => $fb80bf3aef2e1300$export$5a7bfc01df82fcd1);\n/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Point} Point\n */ /**\n * @typedef {Record<string, unknown>} StackState\n * @typedef {[Construct, StackState]} StackItem\n */ \nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\n\nvar $2Qp1S = parcelRequire(\"2Qp1S\");\nconst $fb80bf3aef2e1300$export$5a7bfc01df82fcd1 = {\n    tokenize: $fb80bf3aef2e1300$var$initializeDocument\n};\n/** @type {Construct} */ const $fb80bf3aef2e1300$var$containerConstruct = {\n    tokenize: $fb80bf3aef2e1300$var$tokenizeContainer\n};\n/** @type {Initializer} */ function $fb80bf3aef2e1300$var$initializeDocument(effects) {\n    const self = this;\n    /** @type {Array<StackItem>} */ const stack = [];\n    let continued = 0;\n    /** @type {TokenizeContext|undefined} */ let childFlow;\n    /** @type {Token|undefined} */ let childToken;\n    /** @type {number} */ let lineStartOffset;\n    return start;\n    /** @type {State} */ function start(code) {\n        // First we iterate through the open blocks, starting with the root\n        // document, and descending through last children down to the last open\n        // block.\n        // Each block imposes a condition that the line must satisfy if the block is\n        // to remain open.\n        // For example, a block quote requires a `>` character.\n        // A paragraph requires a non-blank line.\n        // In this phase we may match all or just some of the open blocks.\n        // But we cannot close unmatched blocks yet, because we may have a lazy\n        // continuation line.\n        if (continued < stack.length) {\n            const item = stack[continued];\n            self.containerState = item[1];\n            return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code);\n        } // Done.\n        return checkNewContainers(code);\n    }\n    /** @type {State} */ function documentContinue(code) {\n        continued++ // Note: this field is called `_closeFlow` but it also closes containers.\n        ;\n        // Perhaps a good idea to rename it but its already used in the wild by\n        // extensions.\n        if (self.containerState._closeFlow) {\n            self.containerState._closeFlow = undefined;\n            if (childFlow) closeFlow();\n             // Note: this algorithm for moving events around is similar to the\n            // algorithm when dealing with lazy lines in `writeToChild`.\n            const indexBeforeExits = self.events.length;\n            let indexBeforeFlow = indexBeforeExits;\n            /** @type {Point|undefined} */ let point // Find the flow chunk.\n            ;\n            while(indexBeforeFlow--)if (self.events[indexBeforeFlow][0] === \"exit\" && self.events[indexBeforeFlow][1].type === \"chunkFlow\") {\n                point = self.events[indexBeforeFlow][1].end;\n                break;\n            }\n            exitContainers(continued) // Fix positions.\n            ;\n            let index = indexBeforeExits;\n            while(index < self.events.length){\n                self.events[index][1].end = Object.assign({}, point);\n                index++;\n            } // Inject the exits earlier (theyre still also at the end).\n            (0, $2Qp1S.splice)(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits)) // Discard the duplicate exits.\n            ;\n            self.events.length = index;\n            return checkNewContainers(code);\n        }\n        return start(code);\n    }\n    /** @type {State} */ function checkNewContainers(code) {\n        // Next, after consuming the continuation markers for existing blocks, we\n        // look for new block starts (e.g. `>` for a block quote).\n        // If we encounter a new block start, we close any blocks unmatched in\n        // step 1 before creating the new block as a child of the last matched\n        // block.\n        if (continued === stack.length) {\n            // No need to `check` whether theres a container, of `exitContainers`\n            // would be moot.\n            // We can instead immediately `attempt` to parse one.\n            if (!childFlow) return documentContinued(code);\n             // If we have concrete content, such as block HTML or fenced code,\n            // we cant have containers pierce into them, so we can immediately\n            // start.\n            if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) return flowStart(code);\n             // If we do have flow, it could still be a blank line,\n            // but wed be interrupting it w/ a new container if theres a current\n            // construct.\n            self.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);\n        } // Check if there is a new container.\n        self.containerState = {};\n        return effects.check($fb80bf3aef2e1300$var$containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code);\n    }\n    /** @type {State} */ function thereIsANewContainer(code) {\n        if (childFlow) closeFlow();\n        exitContainers(continued);\n        return documentContinued(code);\n    }\n    /** @type {State} */ function thereIsNoNewContainer(code) {\n        self.parser.lazy[self.now().line] = continued !== stack.length;\n        lineStartOffset = self.now().offset;\n        return flowStart(code);\n    }\n    /** @type {State} */ function documentContinued(code) {\n        // Try new containers.\n        self.containerState = {};\n        return effects.attempt($fb80bf3aef2e1300$var$containerConstruct, containerContinue, flowStart)(code);\n    }\n    /** @type {State} */ function containerContinue(code) {\n        continued++;\n        stack.push([\n            self.currentConstruct,\n            self.containerState\n        ]) // Try another.\n        ;\n        return documentContinued(code);\n    }\n    /** @type {State} */ function flowStart(code) {\n        if (code === null) {\n            if (childFlow) closeFlow();\n            exitContainers(0);\n            effects.consume(code);\n            return;\n        }\n        childFlow = childFlow || self.parser.flow(self.now());\n        effects.enter(\"chunkFlow\", {\n            contentType: \"flow\",\n            previous: childToken,\n            _tokenizer: childFlow\n        });\n        return flowContinue(code);\n    }\n    /** @type {State} */ function flowContinue(code) {\n        if (code === null) {\n            writeToChild(effects.exit(\"chunkFlow\"), true);\n            exitContainers(0);\n            effects.consume(code);\n            return;\n        }\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            effects.consume(code);\n            writeToChild(effects.exit(\"chunkFlow\")) // Get ready for the next line.\n            ;\n            continued = 0;\n            self.interrupt = undefined;\n            return start;\n        }\n        effects.consume(code);\n        return flowContinue;\n    }\n    /**\n   * @param {Token} token\n   * @param {boolean} [eof]\n   * @returns {void}\n   */ function writeToChild(token, eof) {\n        const stream = self.sliceStream(token);\n        if (eof) stream.push(null);\n        token.previous = childToken;\n        if (childToken) childToken.next = token;\n        childToken = token;\n        childFlow.defineSkip(token.start);\n        childFlow.write(stream) // Alright, so we just added a lazy line:\n        ;\n        //\n        // ```markdown\n        // > a\n        // b.\n        //\n        // Or:\n        //\n        // > ~~~c\n        // d\n        //\n        // Or:\n        //\n        // > | e |\n        // f\n        // ```\n        //\n        // The construct in the second example (fenced code) does not accept lazy\n        // lines, so it marked itself as done at the end of its first line, and\n        // then the content construct parses `d`.\n        // Most constructs in markdown match on the first line: if the first line\n        // forms a construct, a non-lazy line cant unmake it.\n        //\n        // The construct in the third example is potentially a GFM table, and\n        // those are *weird*.\n        // It *could* be a table, from the first line, if the following line\n        // matches a condition.\n        // In this case, that second line is lazy, which unmakes the first line\n        // and turns the whole into one content block.\n        //\n        // Weve now parsed the non-lazy and the lazy line, and can figure out\n        // whether the lazy line started a new flow block.\n        // If it did, we exit the current containers between the two flow blocks.\n        if (self.parser.lazy[token.start.line]) {\n            let index = childFlow.events.length;\n            while(index--){\n                if (// The token starts before the line ending\n                childFlow.events[index][1].start.offset < lineStartOffset && // and either is not ended yet\n                (!childFlow.events[index][1].end || // or ends after it.\n                childFlow.events[index][1].end.offset > lineStartOffset)) // Exit: theres still something open, which means its a lazy line\n                // part of something.\n                return;\n            } // Note: this algorithm for moving events around is similar to the\n            // algorithm when closing flow in `documentContinue`.\n            const indexBeforeExits = self.events.length;\n            let indexBeforeFlow = indexBeforeExits;\n            /** @type {boolean|undefined} */ let seen;\n            /** @type {Point|undefined} */ let point // Find the previous chunk (the one before the lazy line).\n            ;\n            while(indexBeforeFlow--)if (self.events[indexBeforeFlow][0] === \"exit\" && self.events[indexBeforeFlow][1].type === \"chunkFlow\") {\n                if (seen) {\n                    point = self.events[indexBeforeFlow][1].end;\n                    break;\n                }\n                seen = true;\n            }\n            exitContainers(continued) // Fix positions.\n            ;\n            index = indexBeforeExits;\n            while(index < self.events.length){\n                self.events[index][1].end = Object.assign({}, point);\n                index++;\n            } // Inject the exits earlier (theyre still also at the end).\n            (0, $2Qp1S.splice)(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits)) // Discard the duplicate exits.\n            ;\n            self.events.length = index;\n        }\n    }\n    /**\n   * @param {number} size\n   * @returns {void}\n   */ function exitContainers(size) {\n        let index = stack.length // Exit open containers.\n        ;\n        while(index-- > size){\n            const entry = stack[index];\n            self.containerState = entry[1];\n            entry[0].exit.call(self, effects);\n        }\n        stack.length = size;\n    }\n    function closeFlow() {\n        childFlow.write([\n            null\n        ]);\n        childToken = undefined;\n        childFlow = undefined;\n        self.containerState._closeFlow = undefined;\n    }\n}\n/** @type {Tokenizer} */ function $fb80bf3aef2e1300$var$tokenizeContainer(effects, ok, nok) {\n    return (0, $jH5RB.factorySpace)(effects, effects.attempt(this.parser.constructs.document, ok, nok), \"linePrefix\", this.parser.constructs.disable.null.includes(\"codeIndented\") ? undefined : 4);\n}\n\n});\n\nparcelRequire.register(\"gxpzI\", function(module, exports) {\n\n$parcel$export(module.exports, \"flow\", () => $c0a39111b1e2f39f$export$ccc7b0636abaffc3);\n/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $7jf0e = parcelRequire(\"7jf0e\");\nvar $iJpmS = parcelRequire(\"iJpmS\");\n\nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nconst $c0a39111b1e2f39f$export$ccc7b0636abaffc3 = {\n    tokenize: $c0a39111b1e2f39f$var$initializeFlow\n};\n/** @type {Initializer} */ function $c0a39111b1e2f39f$var$initializeFlow(effects) {\n    const self = this;\n    const initial = effects.attempt(// Try to parse a blank line.\n    (0, $7jf0e.blankLine), atBlankEnding, effects.attempt(this.parser.constructs.flowInitial, afterConstruct, (0, $jH5RB.factorySpace)(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt((0, $iJpmS.content), afterConstruct)), \"linePrefix\")));\n    return initial;\n    /** @type {State} */ function atBlankEnding(code) {\n        if (code === null) {\n            effects.consume(code);\n            return;\n        }\n        effects.enter(\"lineEndingBlank\");\n        effects.consume(code);\n        effects.exit(\"lineEndingBlank\");\n        self.currentConstruct = undefined;\n        return initial;\n    }\n    /** @type {State} */ function afterConstruct(code) {\n        if (code === null) {\n            effects.consume(code);\n            return;\n        }\n        effects.enter(\"lineEnding\");\n        effects.consume(code);\n        effects.exit(\"lineEnding\");\n        self.currentConstruct = undefined;\n        return initial;\n    }\n}\n\n});\nparcelRequire.register(\"7jf0e\", function(module, exports) {\n\n$parcel$export(module.exports, \"blankLine\", () => $5525f1ffc20239bb$export$d50d28ce3ab2a612);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\nconst $5525f1ffc20239bb$export$d50d28ce3ab2a612 = {\n    tokenize: $5525f1ffc20239bb$var$tokenizeBlankLine,\n    partial: true\n};\n/** @type {Tokenizer} */ function $5525f1ffc20239bb$var$tokenizeBlankLine(effects, ok, nok) {\n    return (0, $jH5RB.factorySpace)(effects, afterWhitespace, \"linePrefix\");\n    /** @type {State} */ function afterWhitespace(code) {\n        return code === null || (0, $iUvtM.markdownLineEnding)(code) ? ok(code) : nok(code);\n    }\n}\n\n});\n\nparcelRequire.register(\"iJpmS\", function(module, exports) {\n\n$parcel$export(module.exports, \"content\", () => $da301b88381bfdbf$export$a7db06668cad9adb);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\n\nvar $jsYfy = parcelRequire(\"jsYfy\");\nconst $da301b88381bfdbf$export$a7db06668cad9adb = {\n    tokenize: $da301b88381bfdbf$var$tokenizeContent,\n    resolve: $da301b88381bfdbf$var$resolveContent\n};\n/** @type {Construct} */ const $da301b88381bfdbf$var$continuationConstruct = {\n    tokenize: $da301b88381bfdbf$var$tokenizeContinuation,\n    partial: true\n};\n/**\n * Content is transparent: its parsed right now. That way, definitions are also\n * parsed right now: before text in paragraphs (specifically, media) are parsed.\n *\n * @type {Resolver}\n */ function $da301b88381bfdbf$var$resolveContent(events) {\n    (0, $jsYfy.subtokenize)(events);\n    return events;\n}\n/** @type {Tokenizer} */ function $da301b88381bfdbf$var$tokenizeContent(effects, ok) {\n    /** @type {Token} */ let previous;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"content\");\n        previous = effects.enter(\"chunkContent\", {\n            contentType: \"content\"\n        });\n        return data(code);\n    }\n    /** @type {State} */ function data(code) {\n        if (code === null) return contentEnd(code);\n        if ((0, $iUvtM.markdownLineEnding)(code)) return effects.check($da301b88381bfdbf$var$continuationConstruct, contentContinue, contentEnd)(code);\n         // Data.\n        effects.consume(code);\n        return data;\n    }\n    /** @type {State} */ function contentEnd(code) {\n        effects.exit(\"chunkContent\");\n        effects.exit(\"content\");\n        return ok(code);\n    }\n    /** @type {State} */ function contentContinue(code) {\n        effects.consume(code);\n        effects.exit(\"chunkContent\");\n        previous.next = effects.enter(\"chunkContent\", {\n            contentType: \"content\",\n            previous: previous\n        });\n        previous = previous.next;\n        return data;\n    }\n}\n/** @type {Tokenizer} */ function $da301b88381bfdbf$var$tokenizeContinuation(effects, ok, nok) {\n    const self = this;\n    return startLookahead;\n    /** @type {State} */ function startLookahead(code) {\n        effects.exit(\"chunkContent\");\n        effects.enter(\"lineEnding\");\n        effects.consume(code);\n        effects.exit(\"lineEnding\");\n        return (0, $jH5RB.factorySpace)(effects, prefixed, \"linePrefix\");\n    }\n    /** @type {State} */ function prefixed(code) {\n        if (code === null || (0, $iUvtM.markdownLineEnding)(code)) return nok(code);\n        const tail = self.events[self.events.length - 1];\n        if (!self.parser.constructs.disable.null.includes(\"codeIndented\") && tail && tail[1].type === \"linePrefix\" && tail[2].sliceSerialize(tail[1], true).length >= 4) return ok(code);\n        return effects.interrupt(self.parser.constructs.flow, nok, ok)(code);\n    }\n}\n\n});\nparcelRequire.register(\"jsYfy\", function(module, exports) {\n\n$parcel$export(module.exports, \"subtokenize\", () => $e2bf5e361d23365c$export$12949d1dd00fddf4);\n/**\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Event} Event\n */ \nvar $2Qp1S = parcelRequire(\"2Qp1S\");\nfunction $e2bf5e361d23365c$export$12949d1dd00fddf4(events) {\n    /** @type {Record<string, number>} */ const jumps = {};\n    let index = -1;\n    /** @type {Event} */ let event;\n    /** @type {number|undefined} */ let lineIndex;\n    /** @type {number} */ let otherIndex;\n    /** @type {Event} */ let otherEvent;\n    /** @type {Event[]} */ let parameters;\n    /** @type {Event[]} */ let subevents;\n    /** @type {boolean|undefined} */ let more;\n    while(++index < events.length){\n        while(index in jumps)index = jumps[index];\n        event = events[index] // Add a hook for the GFM tasklist extension, which needs to know if text\n        ;\n        // is in the first content of a list item.\n        if (index && event[1].type === \"chunkFlow\" && events[index - 1][1].type === \"listItemPrefix\") {\n            subevents = event[1]._tokenizer.events;\n            otherIndex = 0;\n            if (otherIndex < subevents.length && subevents[otherIndex][1].type === \"lineEndingBlank\") otherIndex += 2;\n            if (otherIndex < subevents.length && subevents[otherIndex][1].type === \"content\") while(++otherIndex < subevents.length){\n                if (subevents[otherIndex][1].type === \"content\") break;\n                if (subevents[otherIndex][1].type === \"chunkText\") {\n                    subevents[otherIndex][1]._isInFirstContentOfListItem = true;\n                    otherIndex++;\n                }\n            }\n        } // Enter.\n        if (event[0] === \"enter\") {\n            if (event[1].contentType) {\n                Object.assign(jumps, $e2bf5e361d23365c$var$subcontent(events, index));\n                index = jumps[index];\n                more = true;\n            }\n        } else if (event[1]._container) {\n            otherIndex = index;\n            lineIndex = undefined;\n            while(otherIndex--){\n                otherEvent = events[otherIndex];\n                if (otherEvent[1].type === \"lineEnding\" || otherEvent[1].type === \"lineEndingBlank\") {\n                    if (otherEvent[0] === \"enter\") {\n                        if (lineIndex) events[lineIndex][1].type = \"lineEndingBlank\";\n                        otherEvent[1].type = \"lineEnding\";\n                        lineIndex = otherIndex;\n                    }\n                } else break;\n            }\n            if (lineIndex) {\n                // Fix position.\n                event[1].end = Object.assign({}, events[lineIndex][1].start) // Switch container exit w/ line endings.\n                ;\n                parameters = events.slice(lineIndex, index);\n                parameters.unshift(event);\n                (0, $2Qp1S.splice)(events, lineIndex, index - lineIndex + 1, parameters);\n            }\n        }\n    }\n    return !more;\n}\n/**\n * Tokenize embedded tokens.\n *\n * @param {Event[]} events\n * @param {number} eventIndex\n * @returns {Record<string, number>}\n */ function $e2bf5e361d23365c$var$subcontent(events, eventIndex) {\n    const token = events[eventIndex][1];\n    const context = events[eventIndex][2];\n    let startPosition = eventIndex - 1;\n    /** @type {number[]} */ const startPositions = [];\n    const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);\n    const childEvents = tokenizer.events;\n    /** @type {[number, number][]} */ const jumps = [];\n    /** @type {Record<string, number>} */ const gaps = {};\n    /** @type {Chunk[]} */ let stream;\n    /** @type {Token|undefined} */ let previous;\n    let index = -1;\n    /** @type {Token|undefined} */ let current = token;\n    let adjust = 0;\n    let start = 0;\n    const breaks = [\n        start\n    ] // Loop forward through the linked tokens to pass them in order to the\n    ;\n    // subtokenizer.\n    while(current){\n        // Find the position of the event for this token.\n        while(events[++startPosition][1] !== current);\n        startPositions.push(startPosition);\n        if (!current._tokenizer) {\n            stream = context.sliceStream(current);\n            if (!current.next) stream.push(null);\n            if (previous) tokenizer.defineSkip(current.start);\n            if (current._isInFirstContentOfListItem) tokenizer._gfmTasklistFirstContentOfListItem = true;\n            tokenizer.write(stream);\n            if (current._isInFirstContentOfListItem) tokenizer._gfmTasklistFirstContentOfListItem = undefined;\n        } // Unravel the next token.\n        previous = current;\n        current = current.next;\n    } // Now, loop back through all events (and linked tokens), to figure out which\n    // parts belong where.\n    current = token;\n    while(++index < childEvents.length)if (// Find a void token that includes a break.\n    childEvents[index][0] === \"exit\" && childEvents[index - 1][0] === \"enter\" && childEvents[index][1].type === childEvents[index - 1][1].type && childEvents[index][1].start.line !== childEvents[index][1].end.line) {\n        start = index + 1;\n        breaks.push(start) // Help GC.\n        ;\n        current._tokenizer = undefined;\n        current.previous = undefined;\n        current = current.next;\n    }\n     // Help GC.\n    tokenizer.events = [] // If theres one more token (which is the cases for lines that end in an\n    ;\n    // EOF), thats perfect: the last point we found starts it.\n    // If there isnt then make sure any remaining content is added to it.\n    if (current) {\n        // Help GC.\n        current._tokenizer = undefined;\n        current.previous = undefined;\n    } else breaks.pop();\n     // Now splice the events from the subtokenizer into the current events,\n    // moving back to front so that splice indices arent affected.\n    index = breaks.length;\n    while(index--){\n        const slice = childEvents.slice(breaks[index], breaks[index + 1]);\n        const start = startPositions.pop();\n        jumps.unshift([\n            start,\n            start + slice.length - 1\n        ]);\n        (0, $2Qp1S.splice)(events, start, 2, slice);\n    }\n    index = -1;\n    while(++index < jumps.length){\n        gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];\n        adjust += jumps[index][1] - jumps[index][0] - 1;\n    }\n    return gaps;\n}\n\n});\n\n\n\nparcelRequire.register(\"l2tD0\", function(module, exports) {\n\n$parcel$export(module.exports, \"resolver\", () => $f510c46d167f2895$export$50397835cbfdbc24);\n$parcel$export(module.exports, \"string\", () => $f510c46d167f2895$export$22b082955e083ec3);\n$parcel$export(module.exports, \"text\", () => $f510c46d167f2895$export$6f093cfa640b7166);\n/**\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */ const $f510c46d167f2895$export$50397835cbfdbc24 = {\n    resolveAll: $f510c46d167f2895$var$createResolver()\n};\nconst $f510c46d167f2895$export$22b082955e083ec3 = $f510c46d167f2895$var$initializeFactory(\"string\");\nconst $f510c46d167f2895$export$6f093cfa640b7166 = $f510c46d167f2895$var$initializeFactory(\"text\");\n/**\n * @param {'string'|'text'} field\n * @returns {InitialConstruct}\n */ function $f510c46d167f2895$var$initializeFactory(field) {\n    return {\n        tokenize: initializeText,\n        resolveAll: $f510c46d167f2895$var$createResolver(field === \"text\" ? $f510c46d167f2895$var$resolveAllLineSuffixes : undefined)\n    };\n    /** @type {Initializer} */ function initializeText(effects) {\n        const self = this;\n        const constructs = this.parser.constructs[field];\n        const text = effects.attempt(constructs, start, notText);\n        return start;\n        /** @type {State} */ function start(code) {\n            return atBreak(code) ? text(code) : notText(code);\n        }\n        /** @type {State} */ function notText(code) {\n            if (code === null) {\n                effects.consume(code);\n                return;\n            }\n            effects.enter(\"data\");\n            effects.consume(code);\n            return data;\n        }\n        /** @type {State} */ function data(code) {\n            if (atBreak(code)) {\n                effects.exit(\"data\");\n                return text(code);\n            } // Data.\n            effects.consume(code);\n            return data;\n        }\n        /**\n     * @param {Code} code\n     * @returns {boolean}\n     */ function atBreak(code) {\n            if (code === null) return true;\n            const list = constructs[code];\n            let index = -1;\n            if (list) while(++index < list.length){\n                const item = list[index];\n                if (!item.previous || item.previous.call(self, self.previous)) return true;\n            }\n            return false;\n        }\n    }\n}\n/**\n * @param {Resolver} [extraResolver]\n * @returns {Resolver}\n */ function $f510c46d167f2895$var$createResolver(extraResolver) {\n    return resolveAllText;\n    /** @type {Resolver} */ function resolveAllText(events, context) {\n        let index = -1;\n        /** @type {number|undefined} */ let enter // A rather boring computation (to merge adjacent `data` events) which\n        ;\n        // improves mm performance by 29%.\n        while(++index <= events.length){\n            if (enter === undefined) {\n                if (events[index] && events[index][1].type === \"data\") {\n                    enter = index;\n                    index++;\n                }\n            } else if (!events[index] || events[index][1].type !== \"data\") {\n                // Dont do anything if there is one data token.\n                if (index !== enter + 2) {\n                    events[enter][1].end = events[index - 1][1].end;\n                    events.splice(enter + 2, index - enter - 2);\n                    index = enter + 2;\n                }\n                enter = undefined;\n            }\n        }\n        return extraResolver ? extraResolver(events, context) : events;\n    }\n}\n/**\n * A rather ugly set of instructions which again looks at chunks in the input\n * stream.\n * The reason to do this here is that it is *much* faster to parse in reverse.\n * And that we cant hook into `null` to split the line suffix before an EOF.\n * To do: figure out if we can make this into a clean utility, or even in core.\n * As it will be useful for GFMs literal autolink extension (and maybe even\n * tables?)\n *\n * @type {Resolver}\n */ function $f510c46d167f2895$var$resolveAllLineSuffixes(events, context) {\n    let eventIndex = 0 // Skip first.\n    ;\n    while(++eventIndex <= events.length)if ((eventIndex === events.length || events[eventIndex][1].type === \"lineEnding\") && events[eventIndex - 1][1].type === \"data\") {\n        const data = events[eventIndex - 1][1];\n        const chunks = context.sliceStream(data);\n        let index = chunks.length;\n        let bufferIndex = -1;\n        let size = 0;\n        /** @type {boolean|undefined} */ let tabs;\n        while(index--){\n            const chunk = chunks[index];\n            if (typeof chunk === \"string\") {\n                bufferIndex = chunk.length;\n                while(chunk.charCodeAt(bufferIndex - 1) === 32){\n                    size++;\n                    bufferIndex--;\n                }\n                if (bufferIndex) break;\n                bufferIndex = -1;\n            } else if (chunk === -2) {\n                tabs = true;\n                size++;\n            } else if (chunk === -1) ;\n            else {\n                // Replacement character, exit.\n                index++;\n                break;\n            }\n        }\n        if (size) {\n            const token = {\n                type: eventIndex === events.length || tabs || size < 2 ? \"lineSuffix\" : \"hardBreakTrailing\",\n                start: {\n                    line: data.end.line,\n                    column: data.end.column - size,\n                    offset: data.end.offset - size,\n                    _index: data.start._index + index,\n                    _bufferIndex: index ? bufferIndex : data.start._bufferIndex + bufferIndex\n                },\n                end: Object.assign({}, data.end)\n            };\n            data.end = Object.assign({}, token.start);\n            if (data.start.offset === data.end.offset) Object.assign(data, token);\n            else {\n                events.splice(eventIndex, 0, [\n                    \"enter\",\n                    token,\n                    context\n                ], [\n                    \"exit\",\n                    token,\n                    context\n                ]);\n                eventIndex += 2;\n            }\n        }\n        eventIndex++;\n    }\n    return events;\n}\n\n});\n\nparcelRequire.register(\"8MiTe\", function(module, exports) {\n\n$parcel$export(module.exports, \"createTokenizer\", () => $664175902a9bcd27$export$ae34f10ee4b29837);\n/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').ParseContext} ParseContext\n */ /**\n * @typedef Info\n * @property {() => void} restore\n * @property {number} from\n *\n * @callback ReturnHandle\n *   Handle a successful run.\n * @param {Construct} construct\n * @param {Info} info\n * @returns {void}\n */ \nvar $iUvtM = parcelRequire(\"iUvtM\");\n\nvar $2Qp1S = parcelRequire(\"2Qp1S\");\n\nvar $km4eF = parcelRequire(\"km4eF\");\nfunction $664175902a9bcd27$export$ae34f10ee4b29837(parser, initialize, from) {\n    /** @type {Point} */ let point = Object.assign(from ? Object.assign({}, from) : {\n        line: 1,\n        column: 1,\n        offset: 0\n    }, {\n        _index: 0,\n        _bufferIndex: -1\n    });\n    /** @type {Record<string, number>} */ const columnStart = {};\n    /** @type {Array<Construct>} */ const resolveAllConstructs = [];\n    /** @type {Array<Chunk>} */ let chunks = [];\n    /** @type {Array<Token>} */ let stack = [];\n    /** @type {boolean|undefined} */ let consumed = true;\n    /**\n   * Tools used for tokenizing.\n   *\n   * @type {Effects}\n   */ const effects = {\n        consume: consume,\n        enter: enter,\n        exit: exit,\n        attempt: constructFactory(onsuccessfulconstruct),\n        check: constructFactory(onsuccessfulcheck),\n        interrupt: constructFactory(onsuccessfulcheck, {\n            interrupt: true\n        })\n    };\n    /**\n   * State and tools for resolving and serializing.\n   *\n   * @type {TokenizeContext}\n   */ const context = {\n        previous: null,\n        code: null,\n        containerState: {},\n        events: [],\n        parser: parser,\n        sliceStream: sliceStream,\n        sliceSerialize: sliceSerialize,\n        now: now,\n        defineSkip: defineSkip,\n        write: write\n    };\n    /**\n   * The state function.\n   *\n   * @type {State|void}\n   */ let state = initialize.tokenize.call(context, effects);\n    /**\n   * Track which character we expect to be consumed, to catch bugs.\n   *\n   * @type {Code}\n   */ let expectedCode;\n    if (initialize.resolveAll) resolveAllConstructs.push(initialize);\n    return context;\n    /** @type {TokenizeContext['write']} */ function write(slice) {\n        chunks = (0, $2Qp1S.push)(chunks, slice);\n        main() // Exit if were not done, resolve might change stuff.\n        ;\n        if (chunks[chunks.length - 1] !== null) return [];\n        addResult(initialize, 0) // Otherwise, resolve, and exit.\n        ;\n        context.events = (0, $km4eF.resolveAll)(resolveAllConstructs, context.events, context);\n        return context.events;\n    } //\n    // Tools.\n    //\n    /** @type {TokenizeContext['sliceSerialize']} */ function sliceSerialize(token, expandTabs) {\n        return $664175902a9bcd27$var$serializeChunks(sliceStream(token), expandTabs);\n    }\n    /** @type {TokenizeContext['sliceStream']} */ function sliceStream(token) {\n        return $664175902a9bcd27$var$sliceChunks(chunks, token);\n    }\n    /** @type {TokenizeContext['now']} */ function now() {\n        return Object.assign({}, point);\n    }\n    /** @type {TokenizeContext['defineSkip']} */ function defineSkip(value) {\n        columnStart[value.line] = value.column;\n        accountForPotentialSkip();\n    } //\n    // State management.\n    //\n    /**\n   * Main loop (note that `_index` and `_bufferIndex` in `point` are modified by\n   * `consume`).\n   * Here is where we walk through the chunks, which either include strings of\n   * several characters, or numerical character codes.\n   * The reason to do this in a loop instead of a call is so the stack can\n   * drain.\n   *\n   * @returns {void}\n   */ function main() {\n        /** @type {number} */ let chunkIndex;\n        while(point._index < chunks.length){\n            const chunk = chunks[point._index] // If were in a buffer chunk, loop through it.\n            ;\n            if (typeof chunk === \"string\") {\n                chunkIndex = point._index;\n                if (point._bufferIndex < 0) point._bufferIndex = 0;\n                while(point._index === chunkIndex && point._bufferIndex < chunk.length)go(chunk.charCodeAt(point._bufferIndex));\n            } else go(chunk);\n        }\n    }\n    /**\n   * Deal with one code.\n   *\n   * @param {Code} code\n   * @returns {void}\n   */ function go(code) {\n        consumed = undefined;\n        expectedCode = code;\n        state = state(code);\n    }\n    /** @type {Effects['consume']} */ function consume(code) {\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            point.line++;\n            point.column = 1;\n            point.offset += code === -3 ? 2 : 1;\n            accountForPotentialSkip();\n        } else if (code !== -1) {\n            point.column++;\n            point.offset++;\n        } // Not in a string chunk.\n        if (point._bufferIndex < 0) point._index++;\n        else {\n            point._bufferIndex++ // At end of string chunk.\n            ;\n            // @ts-expect-error Points w/ non-negative `_bufferIndex` reference\n            // strings.\n            if (point._bufferIndex === chunks[point._index].length) {\n                point._bufferIndex = -1;\n                point._index++;\n            }\n        } // Expose the previous character.\n        context.previous = code // Mark as consumed.\n        ;\n        consumed = true;\n    }\n    /** @type {Effects['enter']} */ function enter(type, fields) {\n        /** @type {Token} */ // @ts-expect-error Patch instead of assign required fields to help GC.\n        const token = fields || {};\n        token.type = type;\n        token.start = now();\n        context.events.push([\n            \"enter\",\n            token,\n            context\n        ]);\n        stack.push(token);\n        return token;\n    }\n    /** @type {Effects['exit']} */ function exit(type) {\n        const token = stack.pop();\n        token.end = now();\n        context.events.push([\n            \"exit\",\n            token,\n            context\n        ]);\n        return token;\n    }\n    /**\n   * Use results.\n   *\n   * @type {ReturnHandle}\n   */ function onsuccessfulconstruct(construct, info) {\n        addResult(construct, info.from);\n    }\n    /**\n   * Discard results.\n   *\n   * @type {ReturnHandle}\n   */ function onsuccessfulcheck(_, info) {\n        info.restore();\n    }\n    /**\n   * Factory to attempt/check/interrupt.\n   *\n   * @param {ReturnHandle} onreturn\n   * @param {Record<string, unknown>} [fields]\n   */ function constructFactory(onreturn, fields) {\n        return hook;\n        /**\n     * Handle either an object mapping codes to constructs, a list of\n     * constructs, or a single construct.\n     *\n     * @param {Construct|Array<Construct>|ConstructRecord} constructs\n     * @param {State} returnState\n     * @param {State} [bogusState]\n     * @returns {State}\n     */ function hook(constructs, returnState, bogusState) {\n            /** @type {Array<Construct>} */ let listOfConstructs;\n            /** @type {number} */ let constructIndex;\n            /** @type {Construct} */ let currentConstruct;\n            /** @type {Info} */ let info;\n            return Array.isArray(constructs) ? /* c8 ignore next 1 */ handleListOfConstructs(constructs) : \"tokenize\" in constructs // @ts-expect-error Looks like a construct.\n             ? handleListOfConstructs([\n                constructs\n            ]) : handleMapOfConstructs(constructs);\n            /**\n       * Handle a list of construct.\n       *\n       * @param {ConstructRecord} map\n       * @returns {State}\n       */ function handleMapOfConstructs(map) {\n                return start;\n                /** @type {State} */ function start(code) {\n                    const def = code !== null && map[code];\n                    const all = code !== null && map.null;\n                    const list = [\n                        // To do: add more extension tests.\n                        /* c8 ignore next 2 */ ...Array.isArray(def) ? def : def ? [\n                            def\n                        ] : [],\n                        ...Array.isArray(all) ? all : all ? [\n                            all\n                        ] : []\n                    ];\n                    return handleListOfConstructs(list)(code);\n                }\n            }\n            /**\n       * Handle a list of construct.\n       *\n       * @param {Array<Construct>} list\n       * @returns {State}\n       */ function handleListOfConstructs(list) {\n                listOfConstructs = list;\n                constructIndex = 0;\n                if (list.length === 0) return bogusState;\n                return handleConstruct(list[constructIndex]);\n            }\n            /**\n       * Handle a single construct.\n       *\n       * @param {Construct} construct\n       * @returns {State}\n       */ function handleConstruct(construct) {\n                return start;\n                /** @type {State} */ function start(code) {\n                    // To do: not needed to store if there is no bogus state, probably?\n                    // Currently doesnt work because `inspect` in document does a check\n                    // w/o a bogus, which doesnt make sense. But it does seem to help perf\n                    // by not storing.\n                    info = store();\n                    currentConstruct = construct;\n                    if (!construct.partial) context.currentConstruct = construct;\n                    if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) return nok(code);\n                    return construct.tokenize.call(// If we do have fields, create an object w/ `context` as its\n                    // prototype.\n                    // This allows a live binding, which is needed for `interrupt`.\n                    fields ? Object.assign(Object.create(context), fields) : context, effects, ok, nok)(code);\n                }\n            }\n            /** @type {State} */ function ok(code) {\n                consumed = true;\n                onreturn(currentConstruct, info);\n                return returnState;\n            }\n            /** @type {State} */ function nok(code) {\n                consumed = true;\n                info.restore();\n                if (++constructIndex < listOfConstructs.length) return handleConstruct(listOfConstructs[constructIndex]);\n                return bogusState;\n            }\n        }\n    }\n    /**\n   * @param {Construct} construct\n   * @param {number} from\n   * @returns {void}\n   */ function addResult(construct, from) {\n        if (construct.resolveAll && !resolveAllConstructs.includes(construct)) resolveAllConstructs.push(construct);\n        if (construct.resolve) (0, $2Qp1S.splice)(context.events, from, context.events.length - from, construct.resolve(context.events.slice(from), context));\n        if (construct.resolveTo) context.events = construct.resolveTo(context.events, context);\n    }\n    /**\n   * Store state.\n   *\n   * @returns {Info}\n   */ function store() {\n        const startPoint = now();\n        const startPrevious = context.previous;\n        const startCurrentConstruct = context.currentConstruct;\n        const startEventsIndex = context.events.length;\n        const startStack = Array.from(stack);\n        return {\n            restore: restore,\n            from: startEventsIndex\n        };\n        /**\n     * Restore state.\n     *\n     * @returns {void}\n     */ function restore() {\n            point = startPoint;\n            context.previous = startPrevious;\n            context.currentConstruct = startCurrentConstruct;\n            context.events.length = startEventsIndex;\n            stack = startStack;\n            accountForPotentialSkip();\n        }\n    }\n    /**\n   * Move the current point a bit forward in the line when its on a column\n   * skip.\n   *\n   * @returns {void}\n   */ function accountForPotentialSkip() {\n        if (point.line in columnStart && point.column < 2) {\n            point.column = columnStart[point.line];\n            point.offset += columnStart[point.line] - 1;\n        }\n    }\n}\n/**\n * Get the chunks from a slice of chunks in the range of a token.\n *\n * @param {Array<Chunk>} chunks\n * @param {Pick<Token, 'start'|'end'>} token\n * @returns {Array<Chunk>}\n */ function $664175902a9bcd27$var$sliceChunks(chunks, token) {\n    const startIndex = token.start._index;\n    const startBufferIndex = token.start._bufferIndex;\n    const endIndex = token.end._index;\n    const endBufferIndex = token.end._bufferIndex;\n    /** @type {Array<Chunk>} */ let view;\n    if (startIndex === endIndex) // @ts-expect-error `_bufferIndex` is used on string chunks.\n    view = [\n        chunks[startIndex].slice(startBufferIndex, endBufferIndex)\n    ];\n    else {\n        view = chunks.slice(startIndex, endIndex);\n        if (startBufferIndex > -1) // @ts-expect-error `_bufferIndex` is used on string chunks.\n        view[0] = view[0].slice(startBufferIndex);\n        if (endBufferIndex > 0) // @ts-expect-error `_bufferIndex` is used on string chunks.\n        view.push(chunks[endIndex].slice(0, endBufferIndex));\n    }\n    return view;\n}\n/**\n * Get the string value of a slice of chunks.\n *\n * @param {Array<Chunk>} chunks\n * @param {boolean} [expandTabs=false]\n * @returns {string}\n */ function $664175902a9bcd27$var$serializeChunks(chunks, expandTabs) {\n    let index = -1;\n    /** @type {Array<string>} */ const result = [];\n    /** @type {boolean|undefined} */ let atTab;\n    while(++index < chunks.length){\n        const chunk = chunks[index];\n        /** @type {string} */ let value;\n        if (typeof chunk === \"string\") value = chunk;\n        else switch(chunk){\n            case -5:\n                value = \"\\r\";\n                break;\n            case -4:\n                value = \"\\n\";\n                break;\n            case -3:\n                value = \"\\r\\n\";\n                break;\n            case -2:\n                value = expandTabs ? \" \" : \"\t\";\n                break;\n            case -1:\n                if (!expandTabs && atTab) continue;\n                value = \" \";\n                break;\n            default:\n                // Currently only replacement character.\n                value = String.fromCharCode(chunk);\n        }\n        atTab = chunk === -2;\n        result.push(value);\n    }\n    return result.join(\"\");\n}\n\n});\nparcelRequire.register(\"km4eF\", function(module, exports) {\n\n$parcel$export(module.exports, \"resolveAll\", () => $ed1925d082960da2$export$3ff61ec196ff408b);\n/**\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n */ /**\n * Call all `resolveAll`s.\n *\n * @param {{resolveAll?: Resolver}[]} constructs\n * @param {Event[]} events\n * @param {TokenizeContext} context\n * @returns {Event[]}\n */ function $ed1925d082960da2$export$3ff61ec196ff408b(constructs, events, context) {\n    /** @type {Resolver[]} */ const called = [];\n    let index = -1;\n    while(++index < constructs.length){\n        const resolve = constructs[index].resolveAll;\n        if (resolve && !called.includes(resolve)) {\n            events = resolve(events, context);\n            called.push(resolve);\n        }\n    }\n    return events;\n}\n\n});\n\n\nparcelRequire.register(\"6HWiY\", function(module, exports) {\n\n$parcel$export(module.exports, \"document\", () => $4e23fc6993cb2e1b$export$5a7bfc01df82fcd1);\n$parcel$export(module.exports, \"contentInitial\", () => $4e23fc6993cb2e1b$export$5a2181fb44b58173);\n$parcel$export(module.exports, \"flowInitial\", () => $4e23fc6993cb2e1b$export$cf8bead395eff824);\n$parcel$export(module.exports, \"flow\", () => $4e23fc6993cb2e1b$export$ccc7b0636abaffc3);\n$parcel$export(module.exports, \"string\", () => $4e23fc6993cb2e1b$export$22b082955e083ec3);\n$parcel$export(module.exports, \"text\", () => $4e23fc6993cb2e1b$export$6f093cfa640b7166);\n$parcel$export(module.exports, \"insideSpan\", () => $4e23fc6993cb2e1b$export$d44f260a3f9b69f5);\n$parcel$export(module.exports, \"attentionMarkers\", () => $4e23fc6993cb2e1b$export$b9c0b60d74426aea);\n$parcel$export(module.exports, \"disable\", () => $4e23fc6993cb2e1b$export$e20fbacbb41798b);\n/**\n * @typedef {import('micromark-util-types').Extension} Extension\n */ \nvar $6nTV3 = parcelRequire(\"6nTV3\");\nvar $OcEpt = parcelRequire(\"OcEpt\");\nvar $gNBbl = parcelRequire(\"gNBbl\");\nvar $gEHeN = parcelRequire(\"gEHeN\");\nvar $2Qs41 = parcelRequire(\"2Qs41\");\nvar $gs3o4 = parcelRequire(\"gs3o4\");\nvar $aqw4N = parcelRequire(\"aqw4N\");\nvar $8zB3f = parcelRequire(\"8zB3f\");\nvar $bvMUE = parcelRequire(\"bvMUE\");\nvar $h2kyO = parcelRequire(\"h2kyO\");\nvar $kSTx0 = parcelRequire(\"kSTx0\");\nvar $4vLKK = parcelRequire(\"4vLKK\");\nvar $bgjqA = parcelRequire(\"bgjqA\");\nvar $dz9VB = parcelRequire(\"dz9VB\");\nvar $8be8Q = parcelRequire(\"8be8Q\");\nvar $a9cNg = parcelRequire(\"a9cNg\");\nvar $hmr3Q = parcelRequire(\"hmr3Q\");\nvar $1PP7G = parcelRequire(\"1PP7G\");\nvar $jEoWp = parcelRequire(\"jEoWp\");\nvar $5jHEg = parcelRequire(\"5jHEg\");\n\nvar $l2tD0 = parcelRequire(\"l2tD0\");\nconst $4e23fc6993cb2e1b$export$5a7bfc01df82fcd1 = {\n    [42]: (0, $1PP7G.list),\n    [43]: (0, $1PP7G.list),\n    [45]: (0, $1PP7G.list),\n    [48]: (0, $1PP7G.list),\n    [49]: (0, $1PP7G.list),\n    [50]: (0, $1PP7G.list),\n    [51]: (0, $1PP7G.list),\n    [52]: (0, $1PP7G.list),\n    [53]: (0, $1PP7G.list),\n    [54]: (0, $1PP7G.list),\n    [55]: (0, $1PP7G.list),\n    [56]: (0, $1PP7G.list),\n    [57]: (0, $1PP7G.list),\n    [62]: (0, $gNBbl.blockQuote)\n};\nconst $4e23fc6993cb2e1b$export$5a2181fb44b58173 = {\n    [91]: (0, $bvMUE.definition)\n};\nconst $4e23fc6993cb2e1b$export$cf8bead395eff824 = {\n    [-2]: (0, $aqw4N.codeIndented),\n    [-1]: (0, $aqw4N.codeIndented),\n    [32]: (0, $aqw4N.codeIndented)\n};\nconst $4e23fc6993cb2e1b$export$ccc7b0636abaffc3 = {\n    [35]: (0, $kSTx0.headingAtx),\n    [42]: (0, $5jHEg.thematicBreak),\n    [45]: [\n        (0, $jEoWp.setextUnderline),\n        (0, $5jHEg.thematicBreak)\n    ],\n    [60]: (0, $4vLKK.htmlFlow),\n    [61]: (0, $jEoWp.setextUnderline),\n    [95]: (0, $5jHEg.thematicBreak),\n    [96]: (0, $gs3o4.codeFenced),\n    [126]: (0, $gs3o4.codeFenced)\n};\nconst $4e23fc6993cb2e1b$export$22b082955e083ec3 = {\n    [38]: (0, $2Qs41.characterReference),\n    [92]: (0, $gEHeN.characterEscape)\n};\nconst $4e23fc6993cb2e1b$export$6f093cfa640b7166 = {\n    [-5]: (0, $hmr3Q.lineEnding),\n    [-4]: (0, $hmr3Q.lineEnding),\n    [-3]: (0, $hmr3Q.lineEnding),\n    [33]: (0, $8be8Q.labelStartImage),\n    [38]: (0, $2Qs41.characterReference),\n    [42]: (0, $6nTV3.attention),\n    [60]: [\n        (0, $OcEpt.autolink),\n        (0, $bgjqA.htmlText)\n    ],\n    [91]: (0, $a9cNg.labelStartLink),\n    [92]: [\n        (0, $h2kyO.hardBreakEscape),\n        (0, $gEHeN.characterEscape)\n    ],\n    [93]: (0, $dz9VB.labelEnd),\n    [95]: (0, $6nTV3.attention),\n    [96]: (0, $8zB3f.codeText)\n};\nconst $4e23fc6993cb2e1b$export$d44f260a3f9b69f5 = {\n    null: [\n        (0, $6nTV3.attention),\n        (0, $l2tD0.resolver)\n    ]\n};\nconst $4e23fc6993cb2e1b$export$b9c0b60d74426aea = {\n    null: [\n        42,\n        95\n    ]\n};\nconst $4e23fc6993cb2e1b$export$e20fbacbb41798b = {\n    null: []\n};\n\n});\nparcelRequire.register(\"6nTV3\", function(module, exports) {\n\n$parcel$export(module.exports, \"attention\", () => $4a604472ee2b5b37$export$45b92471da762af7);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Point} Point\n */ \nvar $2Qp1S = parcelRequire(\"2Qp1S\");\n\nvar $9oBa2 = parcelRequire(\"9oBa2\");\n\nvar $km4eF = parcelRequire(\"km4eF\");\nconst $4a604472ee2b5b37$export$45b92471da762af7 = {\n    name: \"attention\",\n    tokenize: $4a604472ee2b5b37$var$tokenizeAttention,\n    resolveAll: $4a604472ee2b5b37$var$resolveAllAttention\n};\n/**\n * Take all events and resolve attention to emphasis or strong.\n *\n * @type {Resolver}\n */ function $4a604472ee2b5b37$var$resolveAllAttention(events, context) {\n    let index = -1;\n    /** @type {number} */ let open;\n    /** @type {Token} */ let group;\n    /** @type {Token} */ let text;\n    /** @type {Token} */ let openingSequence;\n    /** @type {Token} */ let closingSequence;\n    /** @type {number} */ let use;\n    /** @type {Event[]} */ let nextEvents;\n    /** @type {number} */ let offset // Walk through all events.\n    ;\n    //\n    // Note: performance of this is fine on an mb of normal markdown, but its\n    // a bottleneck for malicious stuff.\n    while(++index < events.length)// Find a token that can close.\n    if (events[index][0] === \"enter\" && events[index][1].type === \"attentionSequence\" && events[index][1]._close) {\n        open = index // Now walk back to find an opener.\n        ;\n        while(open--)// Find a token that can open the closer.\n        if (events[open][0] === \"exit\" && events[open][1].type === \"attentionSequence\" && events[open][1]._open && // If the markers are the same:\n        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index][1]).charCodeAt(0)) {\n            // If the opening can close or the closing can open,\n            // and the close size *is not* a multiple of three,\n            // but the sum of the opening and closing size *is* multiple of three,\n            // then dont match.\n            if ((events[open][1]._close || events[index][1]._open) && (events[index][1].end.offset - events[index][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index][1].end.offset - events[index][1].start.offset) % 3)) continue;\n             // Number of markers to use from the sequence.\n            use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index][1].end.offset - events[index][1].start.offset > 1 ? 2 : 1;\n            const start = Object.assign({}, events[open][1].end);\n            const end = Object.assign({}, events[index][1].start);\n            $4a604472ee2b5b37$var$movePoint(start, -use);\n            $4a604472ee2b5b37$var$movePoint(end, use);\n            openingSequence = {\n                type: use > 1 ? \"strongSequence\" : \"emphasisSequence\",\n                start: start,\n                end: Object.assign({}, events[open][1].end)\n            };\n            closingSequence = {\n                type: use > 1 ? \"strongSequence\" : \"emphasisSequence\",\n                start: Object.assign({}, events[index][1].start),\n                end: end\n            };\n            text = {\n                type: use > 1 ? \"strongText\" : \"emphasisText\",\n                start: Object.assign({}, events[open][1].end),\n                end: Object.assign({}, events[index][1].start)\n            };\n            group = {\n                type: use > 1 ? \"strong\" : \"emphasis\",\n                start: Object.assign({}, openingSequence.start),\n                end: Object.assign({}, closingSequence.end)\n            };\n            events[open][1].end = Object.assign({}, openingSequence.start);\n            events[index][1].start = Object.assign({}, closingSequence.end);\n            nextEvents = [] // If there are more markers in the opening, add them before.\n            ;\n            if (events[open][1].end.offset - events[open][1].start.offset) nextEvents = (0, $2Qp1S.push)(nextEvents, [\n                [\n                    \"enter\",\n                    events[open][1],\n                    context\n                ],\n                [\n                    \"exit\",\n                    events[open][1],\n                    context\n                ]\n            ]);\n             // Opening.\n            nextEvents = (0, $2Qp1S.push)(nextEvents, [\n                [\n                    \"enter\",\n                    group,\n                    context\n                ],\n                [\n                    \"enter\",\n                    openingSequence,\n                    context\n                ],\n                [\n                    \"exit\",\n                    openingSequence,\n                    context\n                ],\n                [\n                    \"enter\",\n                    text,\n                    context\n                ]\n            ]) // Between.\n            ;\n            nextEvents = (0, $2Qp1S.push)(nextEvents, (0, $km4eF.resolveAll)(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context)) // Closing.\n            ;\n            nextEvents = (0, $2Qp1S.push)(nextEvents, [\n                [\n                    \"exit\",\n                    text,\n                    context\n                ],\n                [\n                    \"enter\",\n                    closingSequence,\n                    context\n                ],\n                [\n                    \"exit\",\n                    closingSequence,\n                    context\n                ],\n                [\n                    \"exit\",\n                    group,\n                    context\n                ]\n            ]) // If there are more markers in the closing, add them after.\n            ;\n            if (events[index][1].end.offset - events[index][1].start.offset) {\n                offset = 2;\n                nextEvents = (0, $2Qp1S.push)(nextEvents, [\n                    [\n                        \"enter\",\n                        events[index][1],\n                        context\n                    ],\n                    [\n                        \"exit\",\n                        events[index][1],\n                        context\n                    ]\n                ]);\n            } else offset = 0;\n            (0, $2Qp1S.splice)(events, open - 1, index - open + 3, nextEvents);\n            index = open + nextEvents.length - offset - 2;\n            break;\n        }\n    }\n     // Remove remaining sequences.\n    index = -1;\n    while(++index < events.length)if (events[index][1].type === \"attentionSequence\") events[index][1].type = \"data\";\n    return events;\n}\n/** @type {Tokenizer} */ function $4a604472ee2b5b37$var$tokenizeAttention(effects, ok) {\n    const attentionMarkers = this.parser.constructs.attentionMarkers.null;\n    const previous = this.previous;\n    const before = (0, $9oBa2.classifyCharacter)(previous);\n    /** @type {NonNullable<Code>} */ let marker;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"attentionSequence\");\n        marker = code;\n        return sequence(code);\n    }\n    /** @type {State} */ function sequence(code) {\n        if (code === marker) {\n            effects.consume(code);\n            return sequence;\n        }\n        const token = effects.exit(\"attentionSequence\");\n        const after = (0, $9oBa2.classifyCharacter)(code);\n        const open = !after || after === 2 && before || attentionMarkers.includes(code);\n        const close = !before || before === 2 && after || attentionMarkers.includes(previous);\n        token._open = Boolean(marker === 42 ? open : open && (before || !close));\n        token._close = Boolean(marker === 42 ? close : close && (after || !open));\n        return ok(code);\n    }\n}\n/**\n * Move a point a bit.\n *\n * Note: `move` only works inside lines! Its not possible to move past other\n * chunks (replacement characters, tabs, or line endings).\n *\n * @param {Point} point\n * @param {number} offset\n * @returns {void}\n */ function $4a604472ee2b5b37$var$movePoint(point, offset) {\n    point.column += offset;\n    point.offset += offset;\n    point._bufferIndex += offset;\n}\n\n});\nparcelRequire.register(\"9oBa2\", function(module, exports) {\n\n$parcel$export(module.exports, \"classifyCharacter\", () => $6d732e591ba9f10c$export$e3902bc0d835cad0);\n/**\n * @typedef {import('micromark-util-types').Code} Code\n */ \nvar $iUvtM = parcelRequire(\"iUvtM\");\nfunction $6d732e591ba9f10c$export$e3902bc0d835cad0(code) {\n    if (code === null || (0, $iUvtM.markdownLineEndingOrSpace)(code) || (0, $iUvtM.unicodeWhitespace)(code)) return 1;\n    if ((0, $iUvtM.unicodePunctuation)(code)) return 2;\n}\n\n});\n\n\nparcelRequire.register(\"OcEpt\", function(module, exports) {\n\n$parcel$export(module.exports, \"autolink\", () => $096e7bce554321fc$export$17ddf85e4c916ad6);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $iUvtM = parcelRequire(\"iUvtM\");\nconst $096e7bce554321fc$export$17ddf85e4c916ad6 = {\n    name: \"autolink\",\n    tokenize: $096e7bce554321fc$var$tokenizeAutolink\n};\n/** @type {Tokenizer} */ function $096e7bce554321fc$var$tokenizeAutolink(effects, ok, nok) {\n    let size = 1;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"autolink\");\n        effects.enter(\"autolinkMarker\");\n        effects.consume(code);\n        effects.exit(\"autolinkMarker\");\n        effects.enter(\"autolinkProtocol\");\n        return open;\n    }\n    /** @type {State} */ function open(code) {\n        if ((0, $iUvtM.asciiAlpha)(code)) {\n            effects.consume(code);\n            return schemeOrEmailAtext;\n        }\n        return (0, $iUvtM.asciiAtext)(code) ? emailAtext(code) : nok(code);\n    }\n    /** @type {State} */ function schemeOrEmailAtext(code) {\n        return code === 43 || code === 45 || code === 46 || (0, $iUvtM.asciiAlphanumeric)(code) ? schemeInsideOrEmailAtext(code) : emailAtext(code);\n    }\n    /** @type {State} */ function schemeInsideOrEmailAtext(code) {\n        if (code === 58) {\n            effects.consume(code);\n            return urlInside;\n        }\n        if ((code === 43 || code === 45 || code === 46 || (0, $iUvtM.asciiAlphanumeric)(code)) && size++ < 32) {\n            effects.consume(code);\n            return schemeInsideOrEmailAtext;\n        }\n        return emailAtext(code);\n    }\n    /** @type {State} */ function urlInside(code) {\n        if (code === 62) {\n            effects.exit(\"autolinkProtocol\");\n            return end(code);\n        }\n        if (code === null || code === 32 || code === 60 || (0, $iUvtM.asciiControl)(code)) return nok(code);\n        effects.consume(code);\n        return urlInside;\n    }\n    /** @type {State} */ function emailAtext(code) {\n        if (code === 64) {\n            effects.consume(code);\n            size = 0;\n            return emailAtSignOrDot;\n        }\n        if ((0, $iUvtM.asciiAtext)(code)) {\n            effects.consume(code);\n            return emailAtext;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function emailAtSignOrDot(code) {\n        return (0, $iUvtM.asciiAlphanumeric)(code) ? emailLabel(code) : nok(code);\n    }\n    /** @type {State} */ function emailLabel(code) {\n        if (code === 46) {\n            effects.consume(code);\n            size = 0;\n            return emailAtSignOrDot;\n        }\n        if (code === 62) {\n            // Exit, then change the type.\n            effects.exit(\"autolinkProtocol\").type = \"autolinkEmail\";\n            return end(code);\n        }\n        return emailValue(code);\n    }\n    /** @type {State} */ function emailValue(code) {\n        if ((code === 45 || (0, $iUvtM.asciiAlphanumeric)(code)) && size++ < 63) {\n            effects.consume(code);\n            return code === 45 ? emailValue : emailLabel;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function end(code) {\n        effects.enter(\"autolinkMarker\");\n        effects.consume(code);\n        effects.exit(\"autolinkMarker\");\n        effects.exit(\"autolink\");\n        return ok;\n    }\n}\n\n});\n\nparcelRequire.register(\"gNBbl\", function(module, exports) {\n\n$parcel$export(module.exports, \"blockQuote\", () => $c3ae10810aeedc61$export$200dcd0a5903c968);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\nconst $c3ae10810aeedc61$export$200dcd0a5903c968 = {\n    name: \"blockQuote\",\n    tokenize: $c3ae10810aeedc61$var$tokenizeBlockQuoteStart,\n    continuation: {\n        tokenize: $c3ae10810aeedc61$var$tokenizeBlockQuoteContinuation\n    },\n    exit: $c3ae10810aeedc61$var$exit\n};\n/** @type {Tokenizer} */ function $c3ae10810aeedc61$var$tokenizeBlockQuoteStart(effects, ok, nok) {\n    const self = this;\n    return start;\n    /** @type {State} */ function start(code) {\n        if (code === 62) {\n            const state = self.containerState;\n            if (!state.open) {\n                effects.enter(\"blockQuote\", {\n                    _container: true\n                });\n                state.open = true;\n            }\n            effects.enter(\"blockQuotePrefix\");\n            effects.enter(\"blockQuoteMarker\");\n            effects.consume(code);\n            effects.exit(\"blockQuoteMarker\");\n            return after;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function after(code) {\n        if ((0, $iUvtM.markdownSpace)(code)) {\n            effects.enter(\"blockQuotePrefixWhitespace\");\n            effects.consume(code);\n            effects.exit(\"blockQuotePrefixWhitespace\");\n            effects.exit(\"blockQuotePrefix\");\n            return ok;\n        }\n        effects.exit(\"blockQuotePrefix\");\n        return ok(code);\n    }\n}\n/** @type {Tokenizer} */ function $c3ae10810aeedc61$var$tokenizeBlockQuoteContinuation(effects, ok, nok) {\n    return (0, $jH5RB.factorySpace)(effects, effects.attempt($c3ae10810aeedc61$export$200dcd0a5903c968, ok, nok), \"linePrefix\", this.parser.constructs.disable.null.includes(\"codeIndented\") ? undefined : 4);\n}\n/** @type {Exiter} */ function $c3ae10810aeedc61$var$exit(effects) {\n    effects.exit(\"blockQuote\");\n}\n\n});\n\nparcelRequire.register(\"gEHeN\", function(module, exports) {\n\n$parcel$export(module.exports, \"characterEscape\", () => $c201ebe1baa7ee0e$export$2005478564e78d96);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $iUvtM = parcelRequire(\"iUvtM\");\nconst $c201ebe1baa7ee0e$export$2005478564e78d96 = {\n    name: \"characterEscape\",\n    tokenize: $c201ebe1baa7ee0e$var$tokenizeCharacterEscape\n};\n/** @type {Tokenizer} */ function $c201ebe1baa7ee0e$var$tokenizeCharacterEscape(effects, ok, nok) {\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"characterEscape\");\n        effects.enter(\"escapeMarker\");\n        effects.consume(code);\n        effects.exit(\"escapeMarker\");\n        return open;\n    }\n    /** @type {State} */ function open(code) {\n        if ((0, $iUvtM.asciiPunctuation)(code)) {\n            effects.enter(\"characterEscapeValue\");\n            effects.consume(code);\n            effects.exit(\"characterEscapeValue\");\n            effects.exit(\"characterEscape\");\n            return ok;\n        }\n        return nok(code);\n    }\n}\n\n});\n\nparcelRequire.register(\"2Qs41\", function(module, exports) {\n\n$parcel$export(module.exports, \"characterReference\", () => $212634ff078dd1a4$export$e31905600aaf3d8e);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */ \nvar $3HEPL = parcelRequire(\"3HEPL\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\nconst $212634ff078dd1a4$export$e31905600aaf3d8e = {\n    name: \"characterReference\",\n    tokenize: $212634ff078dd1a4$var$tokenizeCharacterReference\n};\n/** @type {Tokenizer} */ function $212634ff078dd1a4$var$tokenizeCharacterReference(effects, ok, nok) {\n    const self = this;\n    let size = 0;\n    /** @type {number} */ let max;\n    /** @type {(code: Code) => code is number} */ let test;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"characterReference\");\n        effects.enter(\"characterReferenceMarker\");\n        effects.consume(code);\n        effects.exit(\"characterReferenceMarker\");\n        return open;\n    }\n    /** @type {State} */ function open(code) {\n        if (code === 35) {\n            effects.enter(\"characterReferenceMarkerNumeric\");\n            effects.consume(code);\n            effects.exit(\"characterReferenceMarkerNumeric\");\n            return numeric;\n        }\n        effects.enter(\"characterReferenceValue\");\n        max = 31;\n        test = (0, $iUvtM.asciiAlphanumeric);\n        return value(code);\n    }\n    /** @type {State} */ function numeric(code) {\n        if (code === 88 || code === 120) {\n            effects.enter(\"characterReferenceMarkerHexadecimal\");\n            effects.consume(code);\n            effects.exit(\"characterReferenceMarkerHexadecimal\");\n            effects.enter(\"characterReferenceValue\");\n            max = 6;\n            test = (0, $iUvtM.asciiHexDigit);\n            return value;\n        }\n        effects.enter(\"characterReferenceValue\");\n        max = 7;\n        test = (0, $iUvtM.asciiDigit);\n        return value(code);\n    }\n    /** @type {State} */ function value(code) {\n        /** @type {Token} */ let token;\n        if (code === 59 && size) {\n            token = effects.exit(\"characterReferenceValue\");\n            if (test === (0, $iUvtM.asciiAlphanumeric) && !(0, $3HEPL.decodeNamedCharacterReference)(self.sliceSerialize(token))) return nok(code);\n            effects.enter(\"characterReferenceMarker\");\n            effects.consume(code);\n            effects.exit(\"characterReferenceMarker\");\n            effects.exit(\"characterReference\");\n            return ok;\n        }\n        if (test(code) && size++ < max) {\n            effects.consume(code);\n            return value;\n        }\n        return nok(code);\n    }\n}\n\n});\nparcelRequire.register(\"3HEPL\", function(module, exports) {\n\n$parcel$export(module.exports, \"decodeNamedCharacterReference\", () => $2b251002bd854cfd$export$289b6a6320f709b4);\n\nvar $HyG4B = parcelRequire(\"HyG4B\");\nconst $2b251002bd854cfd$var$own = {}.hasOwnProperty;\nfunction $2b251002bd854cfd$export$289b6a6320f709b4(value) {\n    return $2b251002bd854cfd$var$own.call((0, $HyG4B.characterEntities), value) ? (0, $HyG4B.characterEntities)[value] : false;\n}\n\n});\nparcelRequire.register(\"HyG4B\", function(module, exports) {\n\n$parcel$export(module.exports, \"characterEntities\", () => $082eea842a54ecda$export$ec810d1aafce79a7);\n/**\n * Map of named character references.\n *\n * @type {Record<string, string>}\n */ const $082eea842a54ecda$export$ec810d1aafce79a7 = {\n    AElig: \"\\xc6\",\n    AMP: \"&\",\n    Aacute: \"\\xc1\",\n    Abreve: \"\",\n    Acirc: \"\\xc2\",\n    Acy: \"\",\n    Afr: \"\\uD835\\uDD04\",\n    Agrave: \"\\xc0\",\n    Alpha: \"\",\n    Amacr: \"\",\n    And: \"\",\n    Aogon: \"\",\n    Aopf: \"\\uD835\\uDD38\",\n    ApplyFunction: \"\",\n    Aring: \"\\xc5\",\n    Ascr: \"\\uD835\\uDC9C\",\n    Assign: \"\",\n    Atilde: \"\\xc3\",\n    Auml: \"\\xc4\",\n    Backslash: \"\",\n    Barv: \"\",\n    Barwed: \"\",\n    Bcy: \"\",\n    Because: \"\",\n    Bernoullis: \"\",\n    Beta: \"\",\n    Bfr: \"\\uD835\\uDD05\",\n    Bopf: \"\\uD835\\uDD39\",\n    Breve: \"\",\n    Bscr: \"\",\n    Bumpeq: \"\",\n    CHcy: \"\",\n    COPY: \"\\xa9\",\n    Cacute: \"\",\n    Cap: \"\",\n    CapitalDifferentialD: \"\",\n    Cayleys: \"\",\n    Ccaron: \"\",\n    Ccedil: \"\\xc7\",\n    Ccirc: \"\",\n    Cconint: \"\",\n    Cdot: \"\",\n    Cedilla: \"\\xb8\",\n    CenterDot: \"\\xb7\",\n    Cfr: \"\",\n    Chi: \"\",\n    CircleDot: \"\",\n    CircleMinus: \"\",\n    CirclePlus: \"\",\n    CircleTimes: \"\",\n    ClockwiseContourIntegral: \"\",\n    CloseCurlyDoubleQuote: \"\",\n    CloseCurlyQuote: \"\",\n    Colon: \"\",\n    Colone: \"\",\n    Congruent: \"\",\n    Conint: \"\",\n    ContourIntegral: \"\",\n    Copf: \"\",\n    Coproduct: \"\",\n    CounterClockwiseContourIntegral: \"\",\n    Cross: \"\",\n    Cscr: \"\\uD835\\uDC9E\",\n    Cup: \"\",\n    CupCap: \"\",\n    DD: \"\",\n    DDotrahd: \"\",\n    DJcy: \"\",\n    DScy: \"\",\n    DZcy: \"\",\n    Dagger: \"\",\n    Darr: \"\",\n    Dashv: \"\",\n    Dcaron: \"\",\n    Dcy: \"\",\n    Del: \"\",\n    Delta: \"\",\n    Dfr: \"\\uD835\\uDD07\",\n    DiacriticalAcute: \"\\xb4\",\n    DiacriticalDot: \"\",\n    DiacriticalDoubleAcute: \"\",\n    DiacriticalGrave: \"`\",\n    DiacriticalTilde: \"\",\n    Diamond: \"\",\n    DifferentialD: \"\",\n    Dopf: \"\\uD835\\uDD3B\",\n    Dot: \"\\xa8\",\n    DotDot: \"\",\n    DotEqual: \"\",\n    DoubleContourIntegral: \"\",\n    DoubleDot: \"\\xa8\",\n    DoubleDownArrow: \"\",\n    DoubleLeftArrow: \"\",\n    DoubleLeftRightArrow: \"\",\n    DoubleLeftTee: \"\",\n    DoubleLongLeftArrow: \"\",\n    DoubleLongLeftRightArrow: \"\",\n    DoubleLongRightArrow: \"\",\n    DoubleRightArrow: \"\",\n    DoubleRightTee: \"\",\n    DoubleUpArrow: \"\",\n    DoubleUpDownArrow: \"\",\n    DoubleVerticalBar: \"\",\n    DownArrow: \"\",\n    DownArrowBar: \"\",\n    DownArrowUpArrow: \"\",\n    DownBreve: \"\",\n    DownLeftRightVector: \"\",\n    DownLeftTeeVector: \"\",\n    DownLeftVector: \"\",\n    DownLeftVectorBar: \"\",\n    DownRightTeeVector: \"\",\n    DownRightVector: \"\",\n    DownRightVectorBar: \"\",\n    DownTee: \"\",\n    DownTeeArrow: \"\",\n    Downarrow: \"\",\n    Dscr: \"\\uD835\\uDC9F\",\n    Dstrok: \"\",\n    ENG: \"\",\n    ETH: \"\\xd0\",\n    Eacute: \"\\xc9\",\n    Ecaron: \"\",\n    Ecirc: \"\\xca\",\n    Ecy: \"\",\n    Edot: \"\",\n    Efr: \"\\uD835\\uDD08\",\n    Egrave: \"\\xc8\",\n    Element: \"\",\n    Emacr: \"\",\n    EmptySmallSquare: \"\",\n    EmptyVerySmallSquare: \"\",\n    Eogon: \"\",\n    Eopf: \"\\uD835\\uDD3C\",\n    Epsilon: \"\",\n    Equal: \"\",\n    EqualTilde: \"\",\n    Equilibrium: \"\",\n    Escr: \"\",\n    Esim: \"\",\n    Eta: \"\",\n    Euml: \"\\xcb\",\n    Exists: \"\",\n    ExponentialE: \"\",\n    Fcy: \"\",\n    Ffr: \"\\uD835\\uDD09\",\n    FilledSmallSquare: \"\",\n    FilledVerySmallSquare: \"\",\n    Fopf: \"\\uD835\\uDD3D\",\n    ForAll: \"\",\n    Fouriertrf: \"\",\n    Fscr: \"\",\n    GJcy: \"\",\n    GT: \">\",\n    Gamma: \"\",\n    Gammad: \"\",\n    Gbreve: \"\",\n    Gcedil: \"\",\n    Gcirc: \"\",\n    Gcy: \"\",\n    Gdot: \"\",\n    Gfr: \"\\uD835\\uDD0A\",\n    Gg: \"\",\n    Gopf: \"\\uD835\\uDD3E\",\n    GreaterEqual: \"\",\n    GreaterEqualLess: \"\",\n    GreaterFullEqual: \"\",\n    GreaterGreater: \"\",\n    GreaterLess: \"\",\n    GreaterSlantEqual: \"\",\n    GreaterTilde: \"\",\n    Gscr: \"\\uD835\\uDCA2\",\n    Gt: \"\",\n    HARDcy: \"\",\n    Hacek: \"\",\n    Hat: \"^\",\n    Hcirc: \"\",\n    Hfr: \"\",\n    HilbertSpace: \"\",\n    Hopf: \"\",\n    HorizontalLine: \"\",\n    Hscr: \"\",\n    Hstrok: \"\",\n    HumpDownHump: \"\",\n    HumpEqual: \"\",\n    IEcy: \"\",\n    IJlig: \"\",\n    IOcy: \"\",\n    Iacute: \"\\xcd\",\n    Icirc: \"\\xce\",\n    Icy: \"\",\n    Idot: \"\",\n    Ifr: \"\",\n    Igrave: \"\\xcc\",\n    Im: \"\",\n    Imacr: \"\",\n    ImaginaryI: \"\",\n    Implies: \"\",\n    Int: \"\",\n    Integral: \"\",\n    Intersection: \"\",\n    InvisibleComma: \"\",\n    InvisibleTimes: \"\",\n    Iogon: \"\",\n    Iopf: \"\\uD835\\uDD40\",\n    Iota: \"\",\n    Iscr: \"\",\n    Itilde: \"\",\n    Iukcy: \"\",\n    Iuml: \"\\xcf\",\n    Jcirc: \"\",\n    Jcy: \"\",\n    Jfr: \"\\uD835\\uDD0D\",\n    Jopf: \"\\uD835\\uDD41\",\n    Jscr: \"\\uD835\\uDCA5\",\n    Jsercy: \"\",\n    Jukcy: \"\",\n    KHcy: \"\",\n    KJcy: \"\",\n    Kappa: \"\",\n    Kcedil: \"\",\n    Kcy: \"\",\n    Kfr: \"\\uD835\\uDD0E\",\n    Kopf: \"\\uD835\\uDD42\",\n    Kscr: \"\\uD835\\uDCA6\",\n    LJcy: \"\",\n    LT: \"<\",\n    Lacute: \"\",\n    Lambda: \"\",\n    Lang: \"\",\n    Laplacetrf: \"\",\n    Larr: \"\",\n    Lcaron: \"\",\n    Lcedil: \"\",\n    Lcy: \"\",\n    LeftAngleBracket: \"\",\n    LeftArrow: \"\",\n    LeftArrowBar: \"\",\n    LeftArrowRightArrow: \"\",\n    LeftCeiling: \"\",\n    LeftDoubleBracket: \"\",\n    LeftDownTeeVector: \"\",\n    LeftDownVector: \"\",\n    LeftDownVectorBar: \"\",\n    LeftFloor: \"\",\n    LeftRightArrow: \"\",\n    LeftRightVector: \"\",\n    LeftTee: \"\",\n    LeftTeeArrow: \"\",\n    LeftTeeVector: \"\",\n    LeftTriangle: \"\",\n    LeftTriangleBar: \"\",\n    LeftTriangleEqual: \"\",\n    LeftUpDownVector: \"\",\n    LeftUpTeeVector: \"\",\n    LeftUpVector: \"\",\n    LeftUpVectorBar: \"\",\n    LeftVector: \"\",\n    LeftVectorBar: \"\",\n    Leftarrow: \"\",\n    Leftrightarrow: \"\",\n    LessEqualGreater: \"\",\n    LessFullEqual: \"\",\n    LessGreater: \"\",\n    LessLess: \"\",\n    LessSlantEqual: \"\",\n    LessTilde: \"\",\n    Lfr: \"\\uD835\\uDD0F\",\n    Ll: \"\",\n    Lleftarrow: \"\",\n    Lmidot: \"\",\n    LongLeftArrow: \"\",\n    LongLeftRightArrow: \"\",\n    LongRightArrow: \"\",\n    Longleftarrow: \"\",\n    Longleftrightarrow: \"\",\n    Longrightarrow: \"\",\n    Lopf: \"\\uD835\\uDD43\",\n    LowerLeftArrow: \"\",\n    LowerRightArrow: \"\",\n    Lscr: \"\",\n    Lsh: \"\",\n    Lstrok: \"\",\n    Lt: \"\",\n    Map: \"\",\n    Mcy: \"\",\n    MediumSpace: \"\",\n    Mellintrf: \"\",\n    Mfr: \"\\uD835\\uDD10\",\n    MinusPlus: \"\",\n    Mopf: \"\\uD835\\uDD44\",\n    Mscr: \"\",\n    Mu: \"\",\n    NJcy: \"\",\n    Nacute: \"\",\n    Ncaron: \"\",\n    Ncedil: \"\",\n    Ncy: \"\",\n    NegativeMediumSpace: \"\",\n    NegativeThickSpace: \"\",\n    NegativeThinSpace: \"\",\n    NegativeVeryThinSpace: \"\",\n    NestedGreaterGreater: \"\",\n    NestedLessLess: \"\",\n    NewLine: \"\\n\",\n    Nfr: \"\\uD835\\uDD11\",\n    NoBreak: \"\",\n    NonBreakingSpace: \"\\xa0\",\n    Nopf: \"\",\n    Not: \"\",\n    NotCongruent: \"\",\n    NotCupCap: \"\",\n    NotDoubleVerticalBar: \"\",\n    NotElement: \"\",\n    NotEqual: \"\",\n    NotEqualTilde: \"\",\n    NotExists: \"\",\n    NotGreater: \"\",\n    NotGreaterEqual: \"\",\n    NotGreaterFullEqual: \"\",\n    NotGreaterGreater: \"\",\n    NotGreaterLess: \"\",\n    NotGreaterSlantEqual: \"\",\n    NotGreaterTilde: \"\",\n    NotHumpDownHump: \"\",\n    NotHumpEqual: \"\",\n    NotLeftTriangle: \"\",\n    NotLeftTriangleBar: \"\",\n    NotLeftTriangleEqual: \"\",\n    NotLess: \"\",\n    NotLessEqual: \"\",\n    NotLessGreater: \"\",\n    NotLessLess: \"\",\n    NotLessSlantEqual: \"\",\n    NotLessTilde: \"\",\n    NotNestedGreaterGreater: \"\",\n    NotNestedLessLess: \"\",\n    NotPrecedes: \"\",\n    NotPrecedesEqual: \"\",\n    NotPrecedesSlantEqual: \"\",\n    NotReverseElement: \"\",\n    NotRightTriangle: \"\",\n    NotRightTriangleBar: \"\",\n    NotRightTriangleEqual: \"\",\n    NotSquareSubset: \"\",\n    NotSquareSubsetEqual: \"\",\n    NotSquareSuperset: \"\",\n    NotSquareSupersetEqual: \"\",\n    NotSubset: \"\",\n    NotSubsetEqual: \"\",\n    NotSucceeds: \"\",\n    NotSucceedsEqual: \"\",\n    NotSucceedsSlantEqual: \"\",\n    NotSucceedsTilde: \"\",\n    NotSuperset: \"\",\n    NotSupersetEqual: \"\",\n    NotTilde: \"\",\n    NotTildeEqual: \"\",\n    NotTildeFullEqual: \"\",\n    NotTildeTilde: \"\",\n    NotVerticalBar: \"\",\n    Nscr: \"\\uD835\\uDCA9\",\n    Ntilde: \"\\xd1\",\n    Nu: \"\",\n    OElig: \"\",\n    Oacute: \"\\xd3\",\n    Ocirc: \"\\xd4\",\n    Ocy: \"\",\n    Odblac: \"\",\n    Ofr: \"\\uD835\\uDD12\",\n    Ograve: \"\\xd2\",\n    Omacr: \"\",\n    Omega: \"\",\n    Omicron: \"\",\n    Oopf: \"\\uD835\\uDD46\",\n    OpenCurlyDoubleQuote: \"\",\n    OpenCurlyQuote: \"\",\n    Or: \"\",\n    Oscr: \"\\uD835\\uDCAA\",\n    Oslash: \"\\xd8\",\n    Otilde: \"\\xd5\",\n    Otimes: \"\",\n    Ouml: \"\\xd6\",\n    OverBar: \"\",\n    OverBrace: \"\",\n    OverBracket: \"\",\n    OverParenthesis: \"\",\n    PartialD: \"\",\n    Pcy: \"\",\n    Pfr: \"\\uD835\\uDD13\",\n    Phi: \"\",\n    Pi: \"\",\n    PlusMinus: \"\\xb1\",\n    Poincareplane: \"\",\n    Popf: \"\",\n    Pr: \"\",\n    Precedes: \"\",\n    PrecedesEqual: \"\",\n    PrecedesSlantEqual: \"\",\n    PrecedesTilde: \"\",\n    Prime: \"\",\n    Product: \"\",\n    Proportion: \"\",\n    Proportional: \"\",\n    Pscr: \"\\uD835\\uDCAB\",\n    Psi: \"\",\n    QUOT: '\"',\n    Qfr: \"\\uD835\\uDD14\",\n    Qopf: \"\",\n    Qscr: \"\\uD835\\uDCAC\",\n    RBarr: \"\",\n    REG: \"\\xae\",\n    Racute: \"\",\n    Rang: \"\",\n    Rarr: \"\",\n    Rarrtl: \"\",\n    Rcaron: \"\",\n    Rcedil: \"\",\n    Rcy: \"\",\n    Re: \"\",\n    ReverseElement: \"\",\n    ReverseEquilibrium: \"\",\n    ReverseUpEquilibrium: \"\",\n    Rfr: \"\",\n    Rho: \"\",\n    RightAngleBracket: \"\",\n    RightArrow: \"\",\n    RightArrowBar: \"\",\n    RightArrowLeftArrow: \"\",\n    RightCeiling: \"\",\n    RightDoubleBracket: \"\",\n    RightDownTeeVector: \"\",\n    RightDownVector: \"\",\n    RightDownVectorBar: \"\",\n    RightFloor: \"\",\n    RightTee: \"\",\n    RightTeeArrow: \"\",\n    RightTeeVector: \"\",\n    RightTriangle: \"\",\n    RightTriangleBar: \"\",\n    RightTriangleEqual: \"\",\n    RightUpDownVector: \"\",\n    RightUpTeeVector: \"\",\n    RightUpVector: \"\",\n    RightUpVectorBar: \"\",\n    RightVector: \"\",\n    RightVectorBar: \"\",\n    Rightarrow: \"\",\n    Ropf: \"\",\n    RoundImplies: \"\",\n    Rrightarrow: \"\",\n    Rscr: \"\",\n    Rsh: \"\",\n    RuleDelayed: \"\",\n    SHCHcy: \"\",\n    SHcy: \"\",\n    SOFTcy: \"\",\n    Sacute: \"\",\n    Sc: \"\",\n    Scaron: \"\",\n    Scedil: \"\",\n    Scirc: \"\",\n    Scy: \"\",\n    Sfr: \"\\uD835\\uDD16\",\n    ShortDownArrow: \"\",\n    ShortLeftArrow: \"\",\n    ShortRightArrow: \"\",\n    ShortUpArrow: \"\",\n    Sigma: \"\",\n    SmallCircle: \"\",\n    Sopf: \"\\uD835\\uDD4A\",\n    Sqrt: \"\",\n    Square: \"\",\n    SquareIntersection: \"\",\n    SquareSubset: \"\",\n    SquareSubsetEqual: \"\",\n    SquareSuperset: \"\",\n    SquareSupersetEqual: \"\",\n    SquareUnion: \"\",\n    Sscr: \"\\uD835\\uDCAE\",\n    Star: \"\",\n    Sub: \"\",\n    Subset: \"\",\n    SubsetEqual: \"\",\n    Succeeds: \"\",\n    SucceedsEqual: \"\",\n    SucceedsSlantEqual: \"\",\n    SucceedsTilde: \"\",\n    SuchThat: \"\",\n    Sum: \"\",\n    Sup: \"\",\n    Superset: \"\",\n    SupersetEqual: \"\",\n    Supset: \"\",\n    THORN: \"\\xde\",\n    TRADE: \"\",\n    TSHcy: \"\",\n    TScy: \"\",\n    Tab: \"\t\",\n    Tau: \"\",\n    Tcaron: \"\",\n    Tcedil: \"\",\n    Tcy: \"\",\n    Tfr: \"\\uD835\\uDD17\",\n    Therefore: \"\",\n    Theta: \"\",\n    ThickSpace: \"\",\n    ThinSpace: \"\",\n    Tilde: \"\",\n    TildeEqual: \"\",\n    TildeFullEqual: \"\",\n    TildeTilde: \"\",\n    Topf: \"\\uD835\\uDD4B\",\n    TripleDot: \"\",\n    Tscr: \"\\uD835\\uDCAF\",\n    Tstrok: \"\",\n    Uacute: \"\\xda\",\n    Uarr: \"\",\n    Uarrocir: \"\",\n    Ubrcy: \"\",\n    Ubreve: \"\",\n    Ucirc: \"\\xdb\",\n    Ucy: \"\",\n    Udblac: \"\",\n    Ufr: \"\\uD835\\uDD18\",\n    Ugrave: \"\\xd9\",\n    Umacr: \"\",\n    UnderBar: \"_\",\n    UnderBrace: \"\",\n    UnderBracket: \"\",\n    UnderParenthesis: \"\",\n    Union: \"\",\n    UnionPlus: \"\",\n    Uogon: \"\",\n    Uopf: \"\\uD835\\uDD4C\",\n    UpArrow: \"\",\n    UpArrowBar: \"\",\n    UpArrowDownArrow: \"\",\n    UpDownArrow: \"\",\n    UpEquilibrium: \"\",\n    UpTee: \"\",\n    UpTeeArrow: \"\",\n    Uparrow: \"\",\n    Updownarrow: \"\",\n    UpperLeftArrow: \"\",\n    UpperRightArrow: \"\",\n    Upsi: \"\",\n    Upsilon: \"\",\n    Uring: \"\",\n    Uscr: \"\\uD835\\uDCB0\",\n    Utilde: \"\",\n    Uuml: \"\\xdc\",\n    VDash: \"\",\n    Vbar: \"\",\n    Vcy: \"\",\n    Vdash: \"\",\n    Vdashl: \"\",\n    Vee: \"\",\n    Verbar: \"\",\n    Vert: \"\",\n    VerticalBar: \"\",\n    VerticalLine: \"|\",\n    VerticalSeparator: \"\",\n    VerticalTilde: \"\",\n    VeryThinSpace: \"\",\n    Vfr: \"\\uD835\\uDD19\",\n    Vopf: \"\\uD835\\uDD4D\",\n    Vscr: \"\\uD835\\uDCB1\",\n    Vvdash: \"\",\n    Wcirc: \"\",\n    Wedge: \"\",\n    Wfr: \"\\uD835\\uDD1A\",\n    Wopf: \"\\uD835\\uDD4E\",\n    Wscr: \"\\uD835\\uDCB2\",\n    Xfr: \"\\uD835\\uDD1B\",\n    Xi: \"\",\n    Xopf: \"\\uD835\\uDD4F\",\n    Xscr: \"\\uD835\\uDCB3\",\n    YAcy: \"\",\n    YIcy: \"\",\n    YUcy: \"\",\n    Yacute: \"\\xdd\",\n    Ycirc: \"\",\n    Ycy: \"\",\n    Yfr: \"\\uD835\\uDD1C\",\n    Yopf: \"\\uD835\\uDD50\",\n    Yscr: \"\\uD835\\uDCB4\",\n    Yuml: \"\",\n    ZHcy: \"\",\n    Zacute: \"\",\n    Zcaron: \"\",\n    Zcy: \"\",\n    Zdot: \"\",\n    ZeroWidthSpace: \"\",\n    Zeta: \"\",\n    Zfr: \"\",\n    Zopf: \"\",\n    Zscr: \"\\uD835\\uDCB5\",\n    aacute: \"\\xe1\",\n    abreve: \"\",\n    ac: \"\",\n    acE: \"\",\n    acd: \"\",\n    acirc: \"\\xe2\",\n    acute: \"\\xb4\",\n    acy: \"\",\n    aelig: \"\\xe6\",\n    af: \"\",\n    afr: \"\\uD835\\uDD1E\",\n    agrave: \"\\xe0\",\n    alefsym: \"\",\n    aleph: \"\",\n    alpha: \"\",\n    amacr: \"\",\n    amalg: \"\",\n    amp: \"&\",\n    and: \"\",\n    andand: \"\",\n    andd: \"\",\n    andslope: \"\",\n    andv: \"\",\n    ang: \"\",\n    ange: \"\",\n    angle: \"\",\n    angmsd: \"\",\n    angmsdaa: \"\",\n    angmsdab: \"\",\n    angmsdac: \"\",\n    angmsdad: \"\",\n    angmsdae: \"\",\n    angmsdaf: \"\",\n    angmsdag: \"\",\n    angmsdah: \"\",\n    angrt: \"\",\n    angrtvb: \"\",\n    angrtvbd: \"\",\n    angsph: \"\",\n    angst: \"\\xc5\",\n    angzarr: \"\",\n    aogon: \"\",\n    aopf: \"\\uD835\\uDD52\",\n    ap: \"\",\n    apE: \"\",\n    apacir: \"\",\n    ape: \"\",\n    apid: \"\",\n    apos: \"'\",\n    approx: \"\",\n    approxeq: \"\",\n    aring: \"\\xe5\",\n    ascr: \"\\uD835\\uDCB6\",\n    ast: \"*\",\n    asymp: \"\",\n    asympeq: \"\",\n    atilde: \"\\xe3\",\n    auml: \"\\xe4\",\n    awconint: \"\",\n    awint: \"\",\n    bNot: \"\",\n    backcong: \"\",\n    backepsilon: \"\",\n    backprime: \"\",\n    backsim: \"\",\n    backsimeq: \"\",\n    barvee: \"\",\n    barwed: \"\",\n    barwedge: \"\",\n    bbrk: \"\",\n    bbrktbrk: \"\",\n    bcong: \"\",\n    bcy: \"\",\n    bdquo: \"\",\n    becaus: \"\",\n    because: \"\",\n    bemptyv: \"\",\n    bepsi: \"\",\n    bernou: \"\",\n    beta: \"\",\n    beth: \"\",\n    between: \"\",\n    bfr: \"\\uD835\\uDD1F\",\n    bigcap: \"\",\n    bigcirc: \"\",\n    bigcup: \"\",\n    bigodot: \"\",\n    bigoplus: \"\",\n    bigotimes: \"\",\n    bigsqcup: \"\",\n    bigstar: \"\",\n    bigtriangledown: \"\",\n    bigtriangleup: \"\",\n    biguplus: \"\",\n    bigvee: \"\",\n    bigwedge: \"\",\n    bkarow: \"\",\n    blacklozenge: \"\",\n    blacksquare: \"\",\n    blacktriangle: \"\",\n    blacktriangledown: \"\",\n    blacktriangleleft: \"\",\n    blacktriangleright: \"\",\n    blank: \"\",\n    blk12: \"\",\n    blk14: \"\",\n    blk34: \"\",\n    block: \"\",\n    bne: \"=\",\n    bnequiv: \"\",\n    bnot: \"\",\n    bopf: \"\\uD835\\uDD53\",\n    bot: \"\",\n    bottom: \"\",\n    bowtie: \"\",\n    boxDL: \"\",\n    boxDR: \"\",\n    boxDl: \"\",\n    boxDr: \"\",\n    boxH: \"\",\n    boxHD: \"\",\n    boxHU: \"\",\n    boxHd: \"\",\n    boxHu: \"\",\n    boxUL: \"\",\n    boxUR: \"\",\n    boxUl: \"\",\n    boxUr: \"\",\n    boxV: \"\",\n    boxVH: \"\",\n    boxVL: \"\",\n    boxVR: \"\",\n    boxVh: \"\",\n    boxVl: \"\",\n    boxVr: \"\",\n    boxbox: \"\",\n    boxdL: \"\",\n    boxdR: \"\",\n    boxdl: \"\",\n    boxdr: \"\",\n    boxh: \"\",\n    boxhD: \"\",\n    boxhU: \"\",\n    boxhd: \"\",\n    boxhu: \"\",\n    boxminus: \"\",\n    boxplus: \"\",\n    boxtimes: \"\",\n    boxuL: \"\",\n    boxuR: \"\",\n    boxul: \"\",\n    boxur: \"\",\n    boxv: \"\",\n    boxvH: \"\",\n    boxvL: \"\",\n    boxvR: \"\",\n    boxvh: \"\",\n    boxvl: \"\",\n    boxvr: \"\",\n    bprime: \"\",\n    breve: \"\",\n    brvbar: \"\\xa6\",\n    bscr: \"\\uD835\\uDCB7\",\n    bsemi: \"\",\n    bsim: \"\",\n    bsime: \"\",\n    bsol: \"\\\\\",\n    bsolb: \"\",\n    bsolhsub: \"\",\n    bull: \"\",\n    bullet: \"\",\n    bump: \"\",\n    bumpE: \"\",\n    bumpe: \"\",\n    bumpeq: \"\",\n    cacute: \"\",\n    cap: \"\",\n    capand: \"\",\n    capbrcup: \"\",\n    capcap: \"\",\n    capcup: \"\",\n    capdot: \"\",\n    caps: \"\",\n    caret: \"\",\n    caron: \"\",\n    ccaps: \"\",\n    ccaron: \"\",\n    ccedil: \"\\xe7\",\n    ccirc: \"\",\n    ccups: \"\",\n    ccupssm: \"\",\n    cdot: \"\",\n    cedil: \"\\xb8\",\n    cemptyv: \"\",\n    cent: \"\\xa2\",\n    centerdot: \"\\xb7\",\n    cfr: \"\\uD835\\uDD20\",\n    chcy: \"\",\n    check: \"\",\n    checkmark: \"\",\n    chi: \"\",\n    cir: \"\",\n    cirE: \"\",\n    circ: \"\",\n    circeq: \"\",\n    circlearrowleft: \"\",\n    circlearrowright: \"\",\n    circledR: \"\\xae\",\n    circledS: \"\",\n    circledast: \"\",\n    circledcirc: \"\",\n    circleddash: \"\",\n    cire: \"\",\n    cirfnint: \"\",\n    cirmid: \"\",\n    cirscir: \"\",\n    clubs: \"\",\n    clubsuit: \"\",\n    colon: \":\",\n    colone: \"\",\n    coloneq: \"\",\n    comma: \",\",\n    commat: \"@\",\n    comp: \"\",\n    compfn: \"\",\n    complement: \"\",\n    complexes: \"\",\n    cong: \"\",\n    congdot: \"\",\n    conint: \"\",\n    copf: \"\\uD835\\uDD54\",\n    coprod: \"\",\n    copy: \"\\xa9\",\n    copysr: \"\",\n    crarr: \"\",\n    cross: \"\",\n    cscr: \"\\uD835\\uDCB8\",\n    csub: \"\",\n    csube: \"\",\n    csup: \"\",\n    csupe: \"\",\n    ctdot: \"\",\n    cudarrl: \"\",\n    cudarrr: \"\",\n    cuepr: \"\",\n    cuesc: \"\",\n    cularr: \"\",\n    cularrp: \"\",\n    cup: \"\",\n    cupbrcap: \"\",\n    cupcap: \"\",\n    cupcup: \"\",\n    cupdot: \"\",\n    cupor: \"\",\n    cups: \"\",\n    curarr: \"\",\n    curarrm: \"\",\n    curlyeqprec: \"\",\n    curlyeqsucc: \"\",\n    curlyvee: \"\",\n    curlywedge: \"\",\n    curren: \"\\xa4\",\n    curvearrowleft: \"\",\n    curvearrowright: \"\",\n    cuvee: \"\",\n    cuwed: \"\",\n    cwconint: \"\",\n    cwint: \"\",\n    cylcty: \"\",\n    dArr: \"\",\n    dHar: \"\",\n    dagger: \"\",\n    daleth: \"\",\n    darr: \"\",\n    dash: \"\",\n    dashv: \"\",\n    dbkarow: \"\",\n    dblac: \"\",\n    dcaron: \"\",\n    dcy: \"\",\n    dd: \"\",\n    ddagger: \"\",\n    ddarr: \"\",\n    ddotseq: \"\",\n    deg: \"\\xb0\",\n    delta: \"\",\n    demptyv: \"\",\n    dfisht: \"\",\n    dfr: \"\\uD835\\uDD21\",\n    dharl: \"\",\n    dharr: \"\",\n    diam: \"\",\n    diamond: \"\",\n    diamondsuit: \"\",\n    diams: \"\",\n    die: \"\\xa8\",\n    digamma: \"\",\n    disin: \"\",\n    div: \"\\xf7\",\n    divide: \"\\xf7\",\n    divideontimes: \"\",\n    divonx: \"\",\n    djcy: \"\",\n    dlcorn: \"\",\n    dlcrop: \"\",\n    dollar: \"$\",\n    dopf: \"\\uD835\\uDD55\",\n    dot: \"\",\n    doteq: \"\",\n    doteqdot: \"\",\n    dotminus: \"\",\n    dotplus: \"\",\n    dotsquare: \"\",\n    doublebarwedge: \"\",\n    downarrow: \"\",\n    downdownarrows: \"\",\n    downharpoonleft: \"\",\n    downharpoonright: \"\",\n    drbkarow: \"\",\n    drcorn: \"\",\n    drcrop: \"\",\n    dscr: \"\\uD835\\uDCB9\",\n    dscy: \"\",\n    dsol: \"\",\n    dstrok: \"\",\n    dtdot: \"\",\n    dtri: \"\",\n    dtrif: \"\",\n    duarr: \"\",\n    duhar: \"\",\n    dwangle: \"\",\n    dzcy: \"\",\n    dzigrarr: \"\",\n    eDDot: \"\",\n    eDot: \"\",\n    eacute: \"\\xe9\",\n    easter: \"\",\n    ecaron: \"\",\n    ecir: \"\",\n    ecirc: \"\\xea\",\n    ecolon: \"\",\n    ecy: \"\",\n    edot: \"\",\n    ee: \"\",\n    efDot: \"\",\n    efr: \"\\uD835\\uDD22\",\n    eg: \"\",\n    egrave: \"\\xe8\",\n    egs: \"\",\n    egsdot: \"\",\n    el: \"\",\n    elinters: \"\",\n    ell: \"\",\n    els: \"\",\n    elsdot: \"\",\n    emacr: \"\",\n    empty: \"\",\n    emptyset: \"\",\n    emptyv: \"\",\n    emsp13: \"\",\n    emsp14: \"\",\n    emsp: \"\",\n    eng: \"\",\n    ensp: \"\",\n    eogon: \"\",\n    eopf: \"\\uD835\\uDD56\",\n    epar: \"\",\n    eparsl: \"\",\n    eplus: \"\",\n    epsi: \"\",\n    epsilon: \"\",\n    epsiv: \"\",\n    eqcirc: \"\",\n    eqcolon: \"\",\n    eqsim: \"\",\n    eqslantgtr: \"\",\n    eqslantless: \"\",\n    equals: \"=\",\n    equest: \"\",\n    equiv: \"\",\n    equivDD: \"\",\n    eqvparsl: \"\",\n    erDot: \"\",\n    erarr: \"\",\n    escr: \"\",\n    esdot: \"\",\n    esim: \"\",\n    eta: \"\",\n    eth: \"\\xf0\",\n    euml: \"\\xeb\",\n    euro: \"\",\n    excl: \"!\",\n    exist: \"\",\n    expectation: \"\",\n    exponentiale: \"\",\n    fallingdotseq: \"\",\n    fcy: \"\",\n    female: \"\",\n    ffilig: \"\",\n    fflig: \"\",\n    ffllig: \"\",\n    ffr: \"\\uD835\\uDD23\",\n    filig: \"\",\n    fjlig: \"fj\",\n    flat: \"\",\n    fllig: \"\",\n    fltns: \"\",\n    fnof: \"\",\n    fopf: \"\\uD835\\uDD57\",\n    forall: \"\",\n    fork: \"\",\n    forkv: \"\",\n    fpartint: \"\",\n    frac12: \"\\xbd\",\n    frac13: \"\",\n    frac14: \"\\xbc\",\n    frac15: \"\",\n    frac16: \"\",\n    frac18: \"\",\n    frac23: \"\",\n    frac25: \"\",\n    frac34: \"\\xbe\",\n    frac35: \"\",\n    frac38: \"\",\n    frac45: \"\",\n    frac56: \"\",\n    frac58: \"\",\n    frac78: \"\",\n    frasl: \"\",\n    frown: \"\",\n    fscr: \"\\uD835\\uDCBB\",\n    gE: \"\",\n    gEl: \"\",\n    gacute: \"\",\n    gamma: \"\",\n    gammad: \"\",\n    gap: \"\",\n    gbreve: \"\",\n    gcirc: \"\",\n    gcy: \"\",\n    gdot: \"\",\n    ge: \"\",\n    gel: \"\",\n    geq: \"\",\n    geqq: \"\",\n    geqslant: \"\",\n    ges: \"\",\n    gescc: \"\",\n    gesdot: \"\",\n    gesdoto: \"\",\n    gesdotol: \"\",\n    gesl: \"\",\n    gesles: \"\",\n    gfr: \"\\uD835\\uDD24\",\n    gg: \"\",\n    ggg: \"\",\n    gimel: \"\",\n    gjcy: \"\",\n    gl: \"\",\n    glE: \"\",\n    gla: \"\",\n    glj: \"\",\n    gnE: \"\",\n    gnap: \"\",\n    gnapprox: \"\",\n    gne: \"\",\n    gneq: \"\",\n    gneqq: \"\",\n    gnsim: \"\",\n    gopf: \"\\uD835\\uDD58\",\n    grave: \"`\",\n    gscr: \"\",\n    gsim: \"\",\n    gsime: \"\",\n    gsiml: \"\",\n    gt: \">\",\n    gtcc: \"\",\n    gtcir: \"\",\n    gtdot: \"\",\n    gtlPar: \"\",\n    gtquest: \"\",\n    gtrapprox: \"\",\n    gtrarr: \"\",\n    gtrdot: \"\",\n    gtreqless: \"\",\n    gtreqqless: \"\",\n    gtrless: \"\",\n    gtrsim: \"\",\n    gvertneqq: \"\",\n    gvnE: \"\",\n    hArr: \"\",\n    hairsp: \"\",\n    half: \"\\xbd\",\n    hamilt: \"\",\n    hardcy: \"\",\n    harr: \"\",\n    harrcir: \"\",\n    harrw: \"\",\n    hbar: \"\",\n    hcirc: \"\",\n    hearts: \"\",\n    heartsuit: \"\",\n    hellip: \"\",\n    hercon: \"\",\n    hfr: \"\\uD835\\uDD25\",\n    hksearow: \"\",\n    hkswarow: \"\",\n    hoarr: \"\",\n    homtht: \"\",\n    hookleftarrow: \"\",\n    hookrightarrow: \"\",\n    hopf: \"\\uD835\\uDD59\",\n    horbar: \"\",\n    hscr: \"\\uD835\\uDCBD\",\n    hslash: \"\",\n    hstrok: \"\",\n    hybull: \"\",\n    hyphen: \"\",\n    iacute: \"\\xed\",\n    ic: \"\",\n    icirc: \"\\xee\",\n    icy: \"\",\n    iecy: \"\",\n    iexcl: \"\\xa1\",\n    iff: \"\",\n    ifr: \"\\uD835\\uDD26\",\n    igrave: \"\\xec\",\n    ii: \"\",\n    iiiint: \"\",\n    iiint: \"\",\n    iinfin: \"\",\n    iiota: \"\",\n    ijlig: \"\",\n    imacr: \"\",\n    image: \"\",\n    imagline: \"\",\n    imagpart: \"\",\n    imath: \"\",\n    imof: \"\",\n    imped: \"\",\n    in: \"\",\n    incare: \"\",\n    infin: \"\",\n    infintie: \"\",\n    inodot: \"\",\n    int: \"\",\n    intcal: \"\",\n    integers: \"\",\n    intercal: \"\",\n    intlarhk: \"\",\n    intprod: \"\",\n    iocy: \"\",\n    iogon: \"\",\n    iopf: \"\\uD835\\uDD5A\",\n    iota: \"\",\n    iprod: \"\",\n    iquest: \"\\xbf\",\n    iscr: \"\\uD835\\uDCBE\",\n    isin: \"\",\n    isinE: \"\",\n    isindot: \"\",\n    isins: \"\",\n    isinsv: \"\",\n    isinv: \"\",\n    it: \"\",\n    itilde: \"\",\n    iukcy: \"\",\n    iuml: \"\\xef\",\n    jcirc: \"\",\n    jcy: \"\",\n    jfr: \"\\uD835\\uDD27\",\n    jmath: \"\",\n    jopf: \"\\uD835\\uDD5B\",\n    jscr: \"\\uD835\\uDCBF\",\n    jsercy: \"\",\n    jukcy: \"\",\n    kappa: \"\",\n    kappav: \"\",\n    kcedil: \"\",\n    kcy: \"\",\n    kfr: \"\\uD835\\uDD28\",\n    kgreen: \"\",\n    khcy: \"\",\n    kjcy: \"\",\n    kopf: \"\\uD835\\uDD5C\",\n    kscr: \"\\uD835\\uDCC0\",\n    lAarr: \"\",\n    lArr: \"\",\n    lAtail: \"\",\n    lBarr: \"\",\n    lE: \"\",\n    lEg: \"\",\n    lHar: \"\",\n    lacute: \"\",\n    laemptyv: \"\",\n    lagran: \"\",\n    lambda: \"\",\n    lang: \"\",\n    langd: \"\",\n    langle: \"\",\n    lap: \"\",\n    laquo: \"\\xab\",\n    larr: \"\",\n    larrb: \"\",\n    larrbfs: \"\",\n    larrfs: \"\",\n    larrhk: \"\",\n    larrlp: \"\",\n    larrpl: \"\",\n    larrsim: \"\",\n    larrtl: \"\",\n    lat: \"\",\n    latail: \"\",\n    late: \"\",\n    lates: \"\",\n    lbarr: \"\",\n    lbbrk: \"\",\n    lbrace: \"{\",\n    lbrack: \"[\",\n    lbrke: \"\",\n    lbrksld: \"\",\n    lbrkslu: \"\",\n    lcaron: \"\",\n    lcedil: \"\",\n    lceil: \"\",\n    lcub: \"{\",\n    lcy: \"\",\n    ldca: \"\",\n    ldquo: \"\",\n    ldquor: \"\",\n    ldrdhar: \"\",\n    ldrushar: \"\",\n    ldsh: \"\",\n    le: \"\",\n    leftarrow: \"\",\n    leftarrowtail: \"\",\n    leftharpoondown: \"\",\n    leftharpoonup: \"\",\n    leftleftarrows: \"\",\n    leftrightarrow: \"\",\n    leftrightarrows: \"\",\n    leftrightharpoons: \"\",\n    leftrightsquigarrow: \"\",\n    leftthreetimes: \"\",\n    leg: \"\",\n    leq: \"\",\n    leqq: \"\",\n    leqslant: \"\",\n    les: \"\",\n    lescc: \"\",\n    lesdot: \"\",\n    lesdoto: \"\",\n    lesdotor: \"\",\n    lesg: \"\",\n    lesges: \"\",\n    lessapprox: \"\",\n    lessdot: \"\",\n    lesseqgtr: \"\",\n    lesseqqgtr: \"\",\n    lessgtr: \"\",\n    lesssim: \"\",\n    lfisht: \"\",\n    lfloor: \"\",\n    lfr: \"\\uD835\\uDD29\",\n    lg: \"\",\n    lgE: \"\",\n    lhard: \"\",\n    lharu: \"\",\n    lharul: \"\",\n    lhblk: \"\",\n    ljcy: \"\",\n    ll: \"\",\n    llarr: \"\",\n    llcorner: \"\",\n    llhard: \"\",\n    lltri: \"\",\n    lmidot: \"\",\n    lmoust: \"\",\n    lmoustache: \"\",\n    lnE: \"\",\n    lnap: \"\",\n    lnapprox: \"\",\n    lne: \"\",\n    lneq: \"\",\n    lneqq: \"\",\n    lnsim: \"\",\n    loang: \"\",\n    loarr: \"\",\n    lobrk: \"\",\n    longleftarrow: \"\",\n    longleftrightarrow: \"\",\n    longmapsto: \"\",\n    longrightarrow: \"\",\n    looparrowleft: \"\",\n    looparrowright: \"\",\n    lopar: \"\",\n    lopf: \"\\uD835\\uDD5D\",\n    loplus: \"\",\n    lotimes: \"\",\n    lowast: \"\",\n    lowbar: \"_\",\n    loz: \"\",\n    lozenge: \"\",\n    lozf: \"\",\n    lpar: \"(\",\n    lparlt: \"\",\n    lrarr: \"\",\n    lrcorner: \"\",\n    lrhar: \"\",\n    lrhard: \"\",\n    lrm: \"\",\n    lrtri: \"\",\n    lsaquo: \"\",\n    lscr: \"\\uD835\\uDCC1\",\n    lsh: \"\",\n    lsim: \"\",\n    lsime: \"\",\n    lsimg: \"\",\n    lsqb: \"[\",\n    lsquo: \"\",\n    lsquor: \"\",\n    lstrok: \"\",\n    lt: \"<\",\n    ltcc: \"\",\n    ltcir: \"\",\n    ltdot: \"\",\n    lthree: \"\",\n    ltimes: \"\",\n    ltlarr: \"\",\n    ltquest: \"\",\n    ltrPar: \"\",\n    ltri: \"\",\n    ltrie: \"\",\n    ltrif: \"\",\n    lurdshar: \"\",\n    luruhar: \"\",\n    lvertneqq: \"\",\n    lvnE: \"\",\n    mDDot: \"\",\n    macr: \"\\xaf\",\n    male: \"\",\n    malt: \"\",\n    maltese: \"\",\n    map: \"\",\n    mapsto: \"\",\n    mapstodown: \"\",\n    mapstoleft: \"\",\n    mapstoup: \"\",\n    marker: \"\",\n    mcomma: \"\",\n    mcy: \"\",\n    mdash: \"\",\n    measuredangle: \"\",\n    mfr: \"\\uD835\\uDD2A\",\n    mho: \"\",\n    micro: \"\\xb5\",\n    mid: \"\",\n    midast: \"*\",\n    midcir: \"\",\n    middot: \"\\xb7\",\n    minus: \"\",\n    minusb: \"\",\n    minusd: \"\",\n    minusdu: \"\",\n    mlcp: \"\",\n    mldr: \"\",\n    mnplus: \"\",\n    models: \"\",\n    mopf: \"\\uD835\\uDD5E\",\n    mp: \"\",\n    mscr: \"\\uD835\\uDCC2\",\n    mstpos: \"\",\n    mu: \"\",\n    multimap: \"\",\n    mumap: \"\",\n    nGg: \"\",\n    nGt: \"\",\n    nGtv: \"\",\n    nLeftarrow: \"\",\n    nLeftrightarrow: \"\",\n    nLl: \"\",\n    nLt: \"\",\n    nLtv: \"\",\n    nRightarrow: \"\",\n    nVDash: \"\",\n    nVdash: \"\",\n    nabla: \"\",\n    nacute: \"\",\n    nang: \"\",\n    nap: \"\",\n    napE: \"\",\n    napid: \"\",\n    napos: \"\",\n    napprox: \"\",\n    natur: \"\",\n    natural: \"\",\n    naturals: \"\",\n    nbsp: \"\\xa0\",\n    nbump: \"\",\n    nbumpe: \"\",\n    ncap: \"\",\n    ncaron: \"\",\n    ncedil: \"\",\n    ncong: \"\",\n    ncongdot: \"\",\n    ncup: \"\",\n    ncy: \"\",\n    ndash: \"\",\n    ne: \"\",\n    neArr: \"\",\n    nearhk: \"\",\n    nearr: \"\",\n    nearrow: \"\",\n    nedot: \"\",\n    nequiv: \"\",\n    nesear: \"\",\n    nesim: \"\",\n    nexist: \"\",\n    nexists: \"\",\n    nfr: \"\\uD835\\uDD2B\",\n    ngE: \"\",\n    nge: \"\",\n    ngeq: \"\",\n    ngeqq: \"\",\n    ngeqslant: \"\",\n    nges: \"\",\n    ngsim: \"\",\n    ngt: \"\",\n    ngtr: \"\",\n    nhArr: \"\",\n    nharr: \"\",\n    nhpar: \"\",\n    ni: \"\",\n    nis: \"\",\n    nisd: \"\",\n    niv: \"\",\n    njcy: \"\",\n    nlArr: \"\",\n    nlE: \"\",\n    nlarr: \"\",\n    nldr: \"\",\n    nle: \"\",\n    nleftarrow: \"\",\n    nleftrightarrow: \"\",\n    nleq: \"\",\n    nleqq: \"\",\n    nleqslant: \"\",\n    nles: \"\",\n    nless: \"\",\n    nlsim: \"\",\n    nlt: \"\",\n    nltri: \"\",\n    nltrie: \"\",\n    nmid: \"\",\n    nopf: \"\\uD835\\uDD5F\",\n    not: \"\\xac\",\n    notin: \"\",\n    notinE: \"\",\n    notindot: \"\",\n    notinva: \"\",\n    notinvb: \"\",\n    notinvc: \"\",\n    notni: \"\",\n    notniva: \"\",\n    notnivb: \"\",\n    notnivc: \"\",\n    npar: \"\",\n    nparallel: \"\",\n    nparsl: \"\",\n    npart: \"\",\n    npolint: \"\",\n    npr: \"\",\n    nprcue: \"\",\n    npre: \"\",\n    nprec: \"\",\n    npreceq: \"\",\n    nrArr: \"\",\n    nrarr: \"\",\n    nrarrc: \"\",\n    nrarrw: \"\",\n    nrightarrow: \"\",\n    nrtri: \"\",\n    nrtrie: \"\",\n    nsc: \"\",\n    nsccue: \"\",\n    nsce: \"\",\n    nscr: \"\\uD835\\uDCC3\",\n    nshortmid: \"\",\n    nshortparallel: \"\",\n    nsim: \"\",\n    nsime: \"\",\n    nsimeq: \"\",\n    nsmid: \"\",\n    nspar: \"\",\n    nsqsube: \"\",\n    nsqsupe: \"\",\n    nsub: \"\",\n    nsubE: \"\",\n    nsube: \"\",\n    nsubset: \"\",\n    nsubseteq: \"\",\n    nsubseteqq: \"\",\n    nsucc: \"\",\n    nsucceq: \"\",\n    nsup: \"\",\n    nsupE: \"\",\n    nsupe: \"\",\n    nsupset: \"\",\n    nsupseteq: \"\",\n    nsupseteqq: \"\",\n    ntgl: \"\",\n    ntilde: \"\\xf1\",\n    ntlg: \"\",\n    ntriangleleft: \"\",\n    ntrianglelefteq: \"\",\n    ntriangleright: \"\",\n    ntrianglerighteq: \"\",\n    nu: \"\",\n    num: \"#\",\n    numero: \"\",\n    numsp: \"\",\n    nvDash: \"\",\n    nvHarr: \"\",\n    nvap: \"\",\n    nvdash: \"\",\n    nvge: \"\",\n    nvgt: \">\",\n    nvinfin: \"\",\n    nvlArr: \"\",\n    nvle: \"\",\n    nvlt: \"<\",\n    nvltrie: \"\",\n    nvrArr: \"\",\n    nvrtrie: \"\",\n    nvsim: \"\",\n    nwArr: \"\",\n    nwarhk: \"\",\n    nwarr: \"\",\n    nwarrow: \"\",\n    nwnear: \"\",\n    oS: \"\",\n    oacute: \"\\xf3\",\n    oast: \"\",\n    ocir: \"\",\n    ocirc: \"\\xf4\",\n    ocy: \"\",\n    odash: \"\",\n    odblac: \"\",\n    odiv: \"\",\n    odot: \"\",\n    odsold: \"\",\n    oelig: \"\",\n    ofcir: \"\",\n    ofr: \"\\uD835\\uDD2C\",\n    ogon: \"\",\n    ograve: \"\\xf2\",\n    ogt: \"\",\n    ohbar: \"\",\n    ohm: \"\",\n    oint: \"\",\n    olarr: \"\",\n    olcir: \"\",\n    olcross: \"\",\n    oline: \"\",\n    olt: \"\",\n    omacr: \"\",\n    omega: \"\",\n    omicron: \"\",\n    omid: \"\",\n    ominus: \"\",\n    oopf: \"\\uD835\\uDD60\",\n    opar: \"\",\n    operp: \"\",\n    oplus: \"\",\n    or: \"\",\n    orarr: \"\",\n    ord: \"\",\n    order: \"\",\n    orderof: \"\",\n    ordf: \"\\xaa\",\n    ordm: \"\\xba\",\n    origof: \"\",\n    oror: \"\",\n    orslope: \"\",\n    orv: \"\",\n    oscr: \"\",\n    oslash: \"\\xf8\",\n    osol: \"\",\n    otilde: \"\\xf5\",\n    otimes: \"\",\n    otimesas: \"\",\n    ouml: \"\\xf6\",\n    ovbar: \"\",\n    par: \"\",\n    para: \"\\xb6\",\n    parallel: \"\",\n    parsim: \"\",\n    parsl: \"\",\n    part: \"\",\n    pcy: \"\",\n    percnt: \"%\",\n    period: \".\",\n    permil: \"\",\n    perp: \"\",\n    pertenk: \"\",\n    pfr: \"\\uD835\\uDD2D\",\n    phi: \"\",\n    phiv: \"\",\n    phmmat: \"\",\n    phone: \"\",\n    pi: \"\",\n    pitchfork: \"\",\n    piv: \"\",\n    planck: \"\",\n    planckh: \"\",\n    plankv: \"\",\n    plus: \"+\",\n    plusacir: \"\",\n    plusb: \"\",\n    pluscir: \"\",\n    plusdo: \"\",\n    plusdu: \"\",\n    pluse: \"\",\n    plusmn: \"\\xb1\",\n    plussim: \"\",\n    plustwo: \"\",\n    pm: \"\\xb1\",\n    pointint: \"\",\n    popf: \"\\uD835\\uDD61\",\n    pound: \"\\xa3\",\n    pr: \"\",\n    prE: \"\",\n    prap: \"\",\n    prcue: \"\",\n    pre: \"\",\n    prec: \"\",\n    precapprox: \"\",\n    preccurlyeq: \"\",\n    preceq: \"\",\n    precnapprox: \"\",\n    precneqq: \"\",\n    precnsim: \"\",\n    precsim: \"\",\n    prime: \"\",\n    primes: \"\",\n    prnE: \"\",\n    prnap: \"\",\n    prnsim: \"\",\n    prod: \"\",\n    profalar: \"\",\n    profline: \"\",\n    profsurf: \"\",\n    prop: \"\",\n    propto: \"\",\n    prsim: \"\",\n    prurel: \"\",\n    pscr: \"\\uD835\\uDCC5\",\n    psi: \"\",\n    puncsp: \"\",\n    qfr: \"\\uD835\\uDD2E\",\n    qint: \"\",\n    qopf: \"\\uD835\\uDD62\",\n    qprime: \"\",\n    qscr: \"\\uD835\\uDCC6\",\n    quaternions: \"\",\n    quatint: \"\",\n    quest: \"?\",\n    questeq: \"\",\n    quot: '\"',\n    rAarr: \"\",\n    rArr: \"\",\n    rAtail: \"\",\n    rBarr: \"\",\n    rHar: \"\",\n    race: \"\",\n    racute: \"\",\n    radic: \"\",\n    raemptyv: \"\",\n    rang: \"\",\n    rangd: \"\",\n    range: \"\",\n    rangle: \"\",\n    raquo: \"\\xbb\",\n    rarr: \"\",\n    rarrap: \"\",\n    rarrb: \"\",\n    rarrbfs: \"\",\n    rarrc: \"\",\n    rarrfs: \"\",\n    rarrhk: \"\",\n    rarrlp: \"\",\n    rarrpl: \"\",\n    rarrsim: \"\",\n    rarrtl: \"\",\n    rarrw: \"\",\n    ratail: \"\",\n    ratio: \"\",\n    rationals: \"\",\n    rbarr: \"\",\n    rbbrk: \"\",\n    rbrace: \"}\",\n    rbrack: \"]\",\n    rbrke: \"\",\n    rbrksld: \"\",\n    rbrkslu: \"\",\n    rcaron: \"\",\n    rcedil: \"\",\n    rceil: \"\",\n    rcub: \"}\",\n    rcy: \"\",\n    rdca: \"\",\n    rdldhar: \"\",\n    rdquo: \"\",\n    rdquor: \"\",\n    rdsh: \"\",\n    real: \"\",\n    realine: \"\",\n    realpart: \"\",\n    reals: \"\",\n    rect: \"\",\n    reg: \"\\xae\",\n    rfisht: \"\",\n    rfloor: \"\",\n    rfr: \"\\uD835\\uDD2F\",\n    rhard: \"\",\n    rharu: \"\",\n    rharul: \"\",\n    rho: \"\",\n    rhov: \"\",\n    rightarrow: \"\",\n    rightarrowtail: \"\",\n    rightharpoondown: \"\",\n    rightharpoonup: \"\",\n    rightleftarrows: \"\",\n    rightleftharpoons: \"\",\n    rightrightarrows: \"\",\n    rightsquigarrow: \"\",\n    rightthreetimes: \"\",\n    ring: \"\",\n    risingdotseq: \"\",\n    rlarr: \"\",\n    rlhar: \"\",\n    rlm: \"\",\n    rmoust: \"\",\n    rmoustache: \"\",\n    rnmid: \"\",\n    roang: \"\",\n    roarr: \"\",\n    robrk: \"\",\n    ropar: \"\",\n    ropf: \"\\uD835\\uDD63\",\n    roplus: \"\",\n    rotimes: \"\",\n    rpar: \")\",\n    rpargt: \"\",\n    rppolint: \"\",\n    rrarr: \"\",\n    rsaquo: \"\",\n    rscr: \"\\uD835\\uDCC7\",\n    rsh: \"\",\n    rsqb: \"]\",\n    rsquo: \"\",\n    rsquor: \"\",\n    rthree: \"\",\n    rtimes: \"\",\n    rtri: \"\",\n    rtrie: \"\",\n    rtrif: \"\",\n    rtriltri: \"\",\n    ruluhar: \"\",\n    rx: \"\",\n    sacute: \"\",\n    sbquo: \"\",\n    sc: \"\",\n    scE: \"\",\n    scap: \"\",\n    scaron: \"\",\n    sccue: \"\",\n    sce: \"\",\n    scedil: \"\",\n    scirc: \"\",\n    scnE: \"\",\n    scnap: \"\",\n    scnsim: \"\",\n    scpolint: \"\",\n    scsim: \"\",\n    scy: \"\",\n    sdot: \"\",\n    sdotb: \"\",\n    sdote: \"\",\n    seArr: \"\",\n    searhk: \"\",\n    searr: \"\",\n    searrow: \"\",\n    sect: \"\\xa7\",\n    semi: \";\",\n    seswar: \"\",\n    setminus: \"\",\n    setmn: \"\",\n    sext: \"\",\n    sfr: \"\\uD835\\uDD30\",\n    sfrown: \"\",\n    sharp: \"\",\n    shchcy: \"\",\n    shcy: \"\",\n    shortmid: \"\",\n    shortparallel: \"\",\n    shy: \"\\xad\",\n    sigma: \"\",\n    sigmaf: \"\",\n    sigmav: \"\",\n    sim: \"\",\n    simdot: \"\",\n    sime: \"\",\n    simeq: \"\",\n    simg: \"\",\n    simgE: \"\",\n    siml: \"\",\n    simlE: \"\",\n    simne: \"\",\n    simplus: \"\",\n    simrarr: \"\",\n    slarr: \"\",\n    smallsetminus: \"\",\n    smashp: \"\",\n    smeparsl: \"\",\n    smid: \"\",\n    smile: \"\",\n    smt: \"\",\n    smte: \"\",\n    smtes: \"\",\n    softcy: \"\",\n    sol: \"/\",\n    solb: \"\",\n    solbar: \"\",\n    sopf: \"\\uD835\\uDD64\",\n    spades: \"\",\n    spadesuit: \"\",\n    spar: \"\",\n    sqcap: \"\",\n    sqcaps: \"\",\n    sqcup: \"\",\n    sqcups: \"\",\n    sqsub: \"\",\n    sqsube: \"\",\n    sqsubset: \"\",\n    sqsubseteq: \"\",\n    sqsup: \"\",\n    sqsupe: \"\",\n    sqsupset: \"\",\n    sqsupseteq: \"\",\n    squ: \"\",\n    square: \"\",\n    squarf: \"\",\n    squf: \"\",\n    srarr: \"\",\n    sscr: \"\\uD835\\uDCC8\",\n    ssetmn: \"\",\n    ssmile: \"\",\n    sstarf: \"\",\n    star: \"\",\n    starf: \"\",\n    straightepsilon: \"\",\n    straightphi: \"\",\n    strns: \"\\xaf\",\n    sub: \"\",\n    subE: \"\",\n    subdot: \"\",\n    sube: \"\",\n    subedot: \"\",\n    submult: \"\",\n    subnE: \"\",\n    subne: \"\",\n    subplus: \"\",\n    subrarr: \"\",\n    subset: \"\",\n    subseteq: \"\",\n    subseteqq: \"\",\n    subsetneq: \"\",\n    subsetneqq: \"\",\n    subsim: \"\",\n    subsub: \"\",\n    subsup: \"\",\n    succ: \"\",\n    succapprox: \"\",\n    succcurlyeq: \"\",\n    succeq: \"\",\n    succnapprox: \"\",\n    succneqq: \"\",\n    succnsim: \"\",\n    succsim: \"\",\n    sum: \"\",\n    sung: \"\",\n    sup1: \"\\xb9\",\n    sup2: \"\\xb2\",\n    sup3: \"\\xb3\",\n    sup: \"\",\n    supE: \"\",\n    supdot: \"\",\n    supdsub: \"\",\n    supe: \"\",\n    supedot: \"\",\n    suphsol: \"\",\n    suphsub: \"\",\n    suplarr: \"\",\n    supmult: \"\",\n    supnE: \"\",\n    supne: \"\",\n    supplus: \"\",\n    supset: \"\",\n    supseteq: \"\",\n    supseteqq: \"\",\n    supsetneq: \"\",\n    supsetneqq: \"\",\n    supsim: \"\",\n    supsub: \"\",\n    supsup: \"\",\n    swArr: \"\",\n    swarhk: \"\",\n    swarr: \"\",\n    swarrow: \"\",\n    swnwar: \"\",\n    szlig: \"\\xdf\",\n    target: \"\",\n    tau: \"\",\n    tbrk: \"\",\n    tcaron: \"\",\n    tcedil: \"\",\n    tcy: \"\",\n    tdot: \"\",\n    telrec: \"\",\n    tfr: \"\\uD835\\uDD31\",\n    there4: \"\",\n    therefore: \"\",\n    theta: \"\",\n    thetasym: \"\",\n    thetav: \"\",\n    thickapprox: \"\",\n    thicksim: \"\",\n    thinsp: \"\",\n    thkap: \"\",\n    thksim: \"\",\n    thorn: \"\\xfe\",\n    tilde: \"\",\n    times: \"\\xd7\",\n    timesb: \"\",\n    timesbar: \"\",\n    timesd: \"\",\n    tint: \"\",\n    toea: \"\",\n    top: \"\",\n    topbot: \"\",\n    topcir: \"\",\n    topf: \"\\uD835\\uDD65\",\n    topfork: \"\",\n    tosa: \"\",\n    tprime: \"\",\n    trade: \"\",\n    triangle: \"\",\n    triangledown: \"\",\n    triangleleft: \"\",\n    trianglelefteq: \"\",\n    triangleq: \"\",\n    triangleright: \"\",\n    trianglerighteq: \"\",\n    tridot: \"\",\n    trie: \"\",\n    triminus: \"\",\n    triplus: \"\",\n    trisb: \"\",\n    tritime: \"\",\n    trpezium: \"\",\n    tscr: \"\\uD835\\uDCC9\",\n    tscy: \"\",\n    tshcy: \"\",\n    tstrok: \"\",\n    twixt: \"\",\n    twoheadleftarrow: \"\",\n    twoheadrightarrow: \"\",\n    uArr: \"\",\n    uHar: \"\",\n    uacute: \"\\xfa\",\n    uarr: \"\",\n    ubrcy: \"\",\n    ubreve: \"\",\n    ucirc: \"\\xfb\",\n    ucy: \"\",\n    udarr: \"\",\n    udblac: \"\",\n    udhar: \"\",\n    ufisht: \"\",\n    ufr: \"\\uD835\\uDD32\",\n    ugrave: \"\\xf9\",\n    uharl: \"\",\n    uharr: \"\",\n    uhblk: \"\",\n    ulcorn: \"\",\n    ulcorner: \"\",\n    ulcrop: \"\",\n    ultri: \"\",\n    umacr: \"\",\n    uml: \"\\xa8\",\n    uogon: \"\",\n    uopf: \"\\uD835\\uDD66\",\n    uparrow: \"\",\n    updownarrow: \"\",\n    upharpoonleft: \"\",\n    upharpoonright: \"\",\n    uplus: \"\",\n    upsi: \"\",\n    upsih: \"\",\n    upsilon: \"\",\n    upuparrows: \"\",\n    urcorn: \"\",\n    urcorner: \"\",\n    urcrop: \"\",\n    uring: \"\",\n    urtri: \"\",\n    uscr: \"\\uD835\\uDCCA\",\n    utdot: \"\",\n    utilde: \"\",\n    utri: \"\",\n    utrif: \"\",\n    uuarr: \"\",\n    uuml: \"\\xfc\",\n    uwangle: \"\",\n    vArr: \"\",\n    vBar: \"\",\n    vBarv: \"\",\n    vDash: \"\",\n    vangrt: \"\",\n    varepsilon: \"\",\n    varkappa: \"\",\n    varnothing: \"\",\n    varphi: \"\",\n    varpi: \"\",\n    varpropto: \"\",\n    varr: \"\",\n    varrho: \"\",\n    varsigma: \"\",\n    varsubsetneq: \"\",\n    varsubsetneqq: \"\",\n    varsupsetneq: \"\",\n    varsupsetneqq: \"\",\n    vartheta: \"\",\n    vartriangleleft: \"\",\n    vartriangleright: \"\",\n    vcy: \"\",\n    vdash: \"\",\n    vee: \"\",\n    veebar: \"\",\n    veeeq: \"\",\n    vellip: \"\",\n    verbar: \"|\",\n    vert: \"|\",\n    vfr: \"\\uD835\\uDD33\",\n    vltri: \"\",\n    vnsub: \"\",\n    vnsup: \"\",\n    vopf: \"\\uD835\\uDD67\",\n    vprop: \"\",\n    vrtri: \"\",\n    vscr: \"\\uD835\\uDCCB\",\n    vsubnE: \"\",\n    vsubne: \"\",\n    vsupnE: \"\",\n    vsupne: \"\",\n    vzigzag: \"\",\n    wcirc: \"\",\n    wedbar: \"\",\n    wedge: \"\",\n    wedgeq: \"\",\n    weierp: \"\",\n    wfr: \"\\uD835\\uDD34\",\n    wopf: \"\\uD835\\uDD68\",\n    wp: \"\",\n    wr: \"\",\n    wreath: \"\",\n    wscr: \"\\uD835\\uDCCC\",\n    xcap: \"\",\n    xcirc: \"\",\n    xcup: \"\",\n    xdtri: \"\",\n    xfr: \"\\uD835\\uDD35\",\n    xhArr: \"\",\n    xharr: \"\",\n    xi: \"\",\n    xlArr: \"\",\n    xlarr: \"\",\n    xmap: \"\",\n    xnis: \"\",\n    xodot: \"\",\n    xopf: \"\\uD835\\uDD69\",\n    xoplus: \"\",\n    xotime: \"\",\n    xrArr: \"\",\n    xrarr: \"\",\n    xscr: \"\\uD835\\uDCCD\",\n    xsqcup: \"\",\n    xuplus: \"\",\n    xutri: \"\",\n    xvee: \"\",\n    xwedge: \"\",\n    yacute: \"\\xfd\",\n    yacy: \"\",\n    ycirc: \"\",\n    ycy: \"\",\n    yen: \"\\xa5\",\n    yfr: \"\\uD835\\uDD36\",\n    yicy: \"\",\n    yopf: \"\\uD835\\uDD6A\",\n    yscr: \"\\uD835\\uDCCE\",\n    yucy: \"\",\n    yuml: \"\\xff\",\n    zacute: \"\",\n    zcaron: \"\",\n    zcy: \"\",\n    zdot: \"\",\n    zeetrf: \"\",\n    zeta: \"\",\n    zfr: \"\\uD835\\uDD37\",\n    zhcy: \"\",\n    zigrarr: \"\",\n    zopf: \"\\uD835\\uDD6B\",\n    zscr: \"\\uD835\\uDCCF\",\n    zwj: \"\",\n    zwnj: \"\"\n};\n\n});\n\n\n\nparcelRequire.register(\"gs3o4\", function(module, exports) {\n\n$parcel$export(module.exports, \"codeFenced\", () => $bfa1e3841184db91$export$c23e4921f8d87e7c);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */ \nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\nconst $bfa1e3841184db91$export$c23e4921f8d87e7c = {\n    name: \"codeFenced\",\n    tokenize: $bfa1e3841184db91$var$tokenizeCodeFenced,\n    concrete: true\n};\n/** @type {Tokenizer} */ function $bfa1e3841184db91$var$tokenizeCodeFenced(effects, ok, nok) {\n    const self = this;\n    /** @type {Construct} */ const closingFenceConstruct = {\n        tokenize: tokenizeClosingFence,\n        partial: true\n    };\n    /** @type {Construct} */ const nonLazyLine = {\n        tokenize: tokenizeNonLazyLine,\n        partial: true\n    };\n    const tail = this.events[this.events.length - 1];\n    const initialPrefix = tail && tail[1].type === \"linePrefix\" ? tail[2].sliceSerialize(tail[1], true).length : 0;\n    let sizeOpen = 0;\n    /** @type {NonNullable<Code>} */ let marker;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"codeFenced\");\n        effects.enter(\"codeFencedFence\");\n        effects.enter(\"codeFencedFenceSequence\");\n        marker = code;\n        return sequenceOpen(code);\n    }\n    /** @type {State} */ function sequenceOpen(code) {\n        if (code === marker) {\n            effects.consume(code);\n            sizeOpen++;\n            return sequenceOpen;\n        }\n        effects.exit(\"codeFencedFenceSequence\");\n        return sizeOpen < 3 ? nok(code) : (0, $jH5RB.factorySpace)(effects, infoOpen, \"whitespace\")(code);\n    }\n    /** @type {State} */ function infoOpen(code) {\n        if (code === null || (0, $iUvtM.markdownLineEnding)(code)) return openAfter(code);\n        effects.enter(\"codeFencedFenceInfo\");\n        effects.enter(\"chunkString\", {\n            contentType: \"string\"\n        });\n        return info(code);\n    }\n    /** @type {State} */ function info(code) {\n        if (code === null || (0, $iUvtM.markdownLineEndingOrSpace)(code)) {\n            effects.exit(\"chunkString\");\n            effects.exit(\"codeFencedFenceInfo\");\n            return (0, $jH5RB.factorySpace)(effects, infoAfter, \"whitespace\")(code);\n        }\n        if (code === 96 && code === marker) return nok(code);\n        effects.consume(code);\n        return info;\n    }\n    /** @type {State} */ function infoAfter(code) {\n        if (code === null || (0, $iUvtM.markdownLineEnding)(code)) return openAfter(code);\n        effects.enter(\"codeFencedFenceMeta\");\n        effects.enter(\"chunkString\", {\n            contentType: \"string\"\n        });\n        return meta(code);\n    }\n    /** @type {State} */ function meta(code) {\n        if (code === null || (0, $iUvtM.markdownLineEnding)(code)) {\n            effects.exit(\"chunkString\");\n            effects.exit(\"codeFencedFenceMeta\");\n            return openAfter(code);\n        }\n        if (code === 96 && code === marker) return nok(code);\n        effects.consume(code);\n        return meta;\n    }\n    /** @type {State} */ function openAfter(code) {\n        effects.exit(\"codeFencedFence\");\n        return self.interrupt ? ok(code) : contentStart(code);\n    }\n    /** @type {State} */ function contentStart(code) {\n        if (code === null) return after(code);\n        if ((0, $iUvtM.markdownLineEnding)(code)) return effects.attempt(nonLazyLine, effects.attempt(closingFenceConstruct, after, initialPrefix ? (0, $jH5RB.factorySpace)(effects, contentStart, \"linePrefix\", initialPrefix + 1) : contentStart), after)(code);\n        effects.enter(\"codeFlowValue\");\n        return contentContinue(code);\n    }\n    /** @type {State} */ function contentContinue(code) {\n        if (code === null || (0, $iUvtM.markdownLineEnding)(code)) {\n            effects.exit(\"codeFlowValue\");\n            return contentStart(code);\n        }\n        effects.consume(code);\n        return contentContinue;\n    }\n    /** @type {State} */ function after(code) {\n        effects.exit(\"codeFenced\");\n        return ok(code);\n    }\n    /** @type {Tokenizer} */ function tokenizeNonLazyLine(effects, ok, nok) {\n        const self = this;\n        return start;\n        /** @type {State} */ function start(code) {\n            effects.enter(\"lineEnding\");\n            effects.consume(code);\n            effects.exit(\"lineEnding\");\n            return lineStart;\n        }\n        /** @type {State} */ function lineStart(code) {\n            return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n        }\n    }\n    /** @type {Tokenizer} */ function tokenizeClosingFence(effects, ok, nok) {\n        let size = 0;\n        return (0, $jH5RB.factorySpace)(effects, closingSequenceStart, \"linePrefix\", this.parser.constructs.disable.null.includes(\"codeIndented\") ? undefined : 4);\n        /** @type {State} */ function closingSequenceStart(code) {\n            effects.enter(\"codeFencedFence\");\n            effects.enter(\"codeFencedFenceSequence\");\n            return closingSequence(code);\n        }\n        /** @type {State} */ function closingSequence(code) {\n            if (code === marker) {\n                effects.consume(code);\n                size++;\n                return closingSequence;\n            }\n            if (size < sizeOpen) return nok(code);\n            effects.exit(\"codeFencedFenceSequence\");\n            return (0, $jH5RB.factorySpace)(effects, closingSequenceEnd, \"whitespace\")(code);\n        }\n        /** @type {State} */ function closingSequenceEnd(code) {\n            if (code === null || (0, $iUvtM.markdownLineEnding)(code)) {\n                effects.exit(\"codeFencedFence\");\n                return ok(code);\n            }\n            return nok(code);\n        }\n    }\n}\n\n});\n\nparcelRequire.register(\"aqw4N\", function(module, exports) {\n\n$parcel$export(module.exports, \"codeIndented\", () => $797536ce4d4ef541$export$47910b7ab28d1853);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\nconst $797536ce4d4ef541$export$47910b7ab28d1853 = {\n    name: \"codeIndented\",\n    tokenize: $797536ce4d4ef541$var$tokenizeCodeIndented\n};\n/** @type {Construct} */ const $797536ce4d4ef541$var$indentedContent = {\n    tokenize: $797536ce4d4ef541$var$tokenizeIndentedContent,\n    partial: true\n};\n/** @type {Tokenizer} */ function $797536ce4d4ef541$var$tokenizeCodeIndented(effects, ok, nok) {\n    const self = this;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"codeIndented\");\n        return (0, $jH5RB.factorySpace)(effects, afterStartPrefix, \"linePrefix\", 5)(code);\n    }\n    /** @type {State} */ function afterStartPrefix(code) {\n        const tail = self.events[self.events.length - 1];\n        return tail && tail[1].type === \"linePrefix\" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? afterPrefix(code) : nok(code);\n    }\n    /** @type {State} */ function afterPrefix(code) {\n        if (code === null) return after(code);\n        if ((0, $iUvtM.markdownLineEnding)(code)) return effects.attempt($797536ce4d4ef541$var$indentedContent, afterPrefix, after)(code);\n        effects.enter(\"codeFlowValue\");\n        return content(code);\n    }\n    /** @type {State} */ function content(code) {\n        if (code === null || (0, $iUvtM.markdownLineEnding)(code)) {\n            effects.exit(\"codeFlowValue\");\n            return afterPrefix(code);\n        }\n        effects.consume(code);\n        return content;\n    }\n    /** @type {State} */ function after(code) {\n        effects.exit(\"codeIndented\");\n        return ok(code);\n    }\n}\n/** @type {Tokenizer} */ function $797536ce4d4ef541$var$tokenizeIndentedContent(effects, ok, nok) {\n    const self = this;\n    return start;\n    /** @type {State} */ function start(code) {\n        // If this is a lazy line, it cant be code.\n        if (self.parser.lazy[self.now().line]) return nok(code);\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            effects.enter(\"lineEnding\");\n            effects.consume(code);\n            effects.exit(\"lineEnding\");\n            return start;\n        }\n        return (0, $jH5RB.factorySpace)(effects, afterPrefix, \"linePrefix\", 5)(code);\n    }\n    /** @type {State} */ function afterPrefix(code) {\n        const tail = self.events[self.events.length - 1];\n        return tail && tail[1].type === \"linePrefix\" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok(code) : (0, $iUvtM.markdownLineEnding)(code) ? start(code) : nok(code);\n    }\n}\n\n});\n\nparcelRequire.register(\"8zB3f\", function(module, exports) {\n\n$parcel$export(module.exports, \"codeText\", () => $63de5539f73334db$export$d24f93e715f9df88);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $iUvtM = parcelRequire(\"iUvtM\");\nconst $63de5539f73334db$export$d24f93e715f9df88 = {\n    name: \"codeText\",\n    tokenize: $63de5539f73334db$var$tokenizeCodeText,\n    resolve: $63de5539f73334db$var$resolveCodeText,\n    previous: $63de5539f73334db$var$previous\n};\n/** @type {Resolver} */ function $63de5539f73334db$var$resolveCodeText(events) {\n    let tailExitIndex = events.length - 4;\n    let headEnterIndex = 3;\n    /** @type {number} */ let index;\n    /** @type {number|undefined} */ let enter // If we start and end with an EOL or a space.\n    ;\n    if ((events[headEnterIndex][1].type === \"lineEnding\" || events[headEnterIndex][1].type === \"space\") && (events[tailExitIndex][1].type === \"lineEnding\" || events[tailExitIndex][1].type === \"space\")) {\n        index = headEnterIndex // And we have data.\n        ;\n        while(++index < tailExitIndex)if (events[index][1].type === \"codeTextData\") {\n            // Then we have padding.\n            events[headEnterIndex][1].type = \"codeTextPadding\";\n            events[tailExitIndex][1].type = \"codeTextPadding\";\n            headEnterIndex += 2;\n            tailExitIndex -= 2;\n            break;\n        }\n    } // Merge adjacent spaces and data.\n    index = headEnterIndex - 1;\n    tailExitIndex++;\n    while(++index <= tailExitIndex){\n        if (enter === undefined) {\n            if (index !== tailExitIndex && events[index][1].type !== \"lineEnding\") enter = index;\n        } else if (index === tailExitIndex || events[index][1].type === \"lineEnding\") {\n            events[enter][1].type = \"codeTextData\";\n            if (index !== enter + 2) {\n                events[enter][1].end = events[index - 1][1].end;\n                events.splice(enter + 2, index - enter - 2);\n                tailExitIndex -= index - enter - 2;\n                index = enter + 2;\n            }\n            enter = undefined;\n        }\n    }\n    return events;\n}\n/** @type {Previous} */ function $63de5539f73334db$var$previous(code) {\n    // If there is a previous code, there will always be a tail.\n    return code !== 96 || this.events[this.events.length - 1][1].type === \"characterEscape\";\n}\n/** @type {Tokenizer} */ function $63de5539f73334db$var$tokenizeCodeText(effects, ok, nok) {\n    const self = this;\n    let sizeOpen = 0;\n    /** @type {number} */ let size;\n    /** @type {Token} */ let token;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"codeText\");\n        effects.enter(\"codeTextSequence\");\n        return openingSequence(code);\n    }\n    /** @type {State} */ function openingSequence(code) {\n        if (code === 96) {\n            effects.consume(code);\n            sizeOpen++;\n            return openingSequence;\n        }\n        effects.exit(\"codeTextSequence\");\n        return gap(code);\n    }\n    /** @type {State} */ function gap(code) {\n        // EOF.\n        if (code === null) return nok(code);\n         // Closing fence?\n        // Could also be data.\n        if (code === 96) {\n            token = effects.enter(\"codeTextSequence\");\n            size = 0;\n            return closingSequence(code);\n        } // Tabs dont work, and virtual spaces dont make sense.\n        if (code === 32) {\n            effects.enter(\"space\");\n            effects.consume(code);\n            effects.exit(\"space\");\n            return gap;\n        }\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            effects.enter(\"lineEnding\");\n            effects.consume(code);\n            effects.exit(\"lineEnding\");\n            return gap;\n        } // Data.\n        effects.enter(\"codeTextData\");\n        return data(code);\n    } // In code.\n    /** @type {State} */ function data(code) {\n        if (code === null || code === 32 || code === 96 || (0, $iUvtM.markdownLineEnding)(code)) {\n            effects.exit(\"codeTextData\");\n            return gap(code);\n        }\n        effects.consume(code);\n        return data;\n    } // Closing fence.\n    /** @type {State} */ function closingSequence(code) {\n        // More.\n        if (code === 96) {\n            effects.consume(code);\n            size++;\n            return closingSequence;\n        } // Done!\n        if (size === sizeOpen) {\n            effects.exit(\"codeTextSequence\");\n            effects.exit(\"codeText\");\n            return ok(code);\n        } // More or less accents: mark as data.\n        token.type = \"codeTextData\";\n        return data(code);\n    }\n}\n\n});\n\nparcelRequire.register(\"bvMUE\", function(module, exports) {\n\n$parcel$export(module.exports, \"definition\", () => $861888066e94d267$export$69f215ed977cdb73);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $DVYDN = parcelRequire(\"DVYDN\");\n\nvar $fDPPf = parcelRequire(\"fDPPf\");\n\nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nvar $hFl17 = parcelRequire(\"hFl17\");\n\nvar $e4FUu = parcelRequire(\"e4FUu\");\n\nvar $3ac70 = parcelRequire(\"3ac70\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\nconst $861888066e94d267$export$69f215ed977cdb73 = {\n    name: \"definition\",\n    tokenize: $861888066e94d267$var$tokenizeDefinition\n};\n/** @type {Construct} */ const $861888066e94d267$var$titleConstruct = {\n    tokenize: $861888066e94d267$var$tokenizeTitle,\n    partial: true\n};\n/** @type {Tokenizer} */ function $861888066e94d267$var$tokenizeDefinition(effects, ok, nok) {\n    const self = this;\n    /** @type {string} */ let identifier;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"definition\");\n        return (0, $fDPPf.factoryLabel).call(self, effects, labelAfter, nok, \"definitionLabel\", \"definitionLabelMarker\", \"definitionLabelString\")(code);\n    }\n    /** @type {State} */ function labelAfter(code) {\n        identifier = (0, $3ac70.normalizeIdentifier)(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1));\n        if (code === 58) {\n            effects.enter(\"definitionMarker\");\n            effects.consume(code);\n            effects.exit(\"definitionMarker\") // Note: blank lines cant exist in content.\n            ;\n            return (0, $e4FUu.factoryWhitespace)(effects, (0, $DVYDN.factoryDestination)(effects, effects.attempt($861888066e94d267$var$titleConstruct, (0, $jH5RB.factorySpace)(effects, after, \"whitespace\"), (0, $jH5RB.factorySpace)(effects, after, \"whitespace\")), nok, \"definitionDestination\", \"definitionDestinationLiteral\", \"definitionDestinationLiteralMarker\", \"definitionDestinationRaw\", \"definitionDestinationString\"));\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function after(code) {\n        if (code === null || (0, $iUvtM.markdownLineEnding)(code)) {\n            effects.exit(\"definition\");\n            if (!self.parser.defined.includes(identifier)) self.parser.defined.push(identifier);\n            return ok(code);\n        }\n        return nok(code);\n    }\n}\n/** @type {Tokenizer} */ function $861888066e94d267$var$tokenizeTitle(effects, ok, nok) {\n    return start;\n    /** @type {State} */ function start(code) {\n        return (0, $iUvtM.markdownLineEndingOrSpace)(code) ? (0, $e4FUu.factoryWhitespace)(effects, before)(code) : nok(code);\n    }\n    /** @type {State} */ function before(code) {\n        if (code === 34 || code === 39 || code === 40) return (0, $hFl17.factoryTitle)(effects, (0, $jH5RB.factorySpace)(effects, after, \"whitespace\"), nok, \"definitionTitle\", \"definitionTitleMarker\", \"definitionTitleString\")(code);\n        return nok(code);\n    }\n    /** @type {State} */ function after(code) {\n        return code === null || (0, $iUvtM.markdownLineEnding)(code) ? ok(code) : nok(code);\n    }\n}\n\n});\nparcelRequire.register(\"DVYDN\", function(module, exports) {\n\n$parcel$export(module.exports, \"factoryDestination\", () => $07809dac6ed252d2$export$2e6c8deaa96af245);\n/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $iUvtM = parcelRequire(\"iUvtM\");\nfunction $07809dac6ed252d2$export$2e6c8deaa96af245(effects, ok, nok, type, literalType, literalMarkerType, rawType, stringType, max) {\n    const limit = max || Number.POSITIVE_INFINITY;\n    let balance = 0;\n    return start;\n    /** @type {State} */ function start(code) {\n        if (code === 60) {\n            effects.enter(type);\n            effects.enter(literalType);\n            effects.enter(literalMarkerType);\n            effects.consume(code);\n            effects.exit(literalMarkerType);\n            return destinationEnclosedBefore;\n        }\n        if (code === null || code === 41 || (0, $iUvtM.asciiControl)(code)) return nok(code);\n        effects.enter(type);\n        effects.enter(rawType);\n        effects.enter(stringType);\n        effects.enter(\"chunkString\", {\n            contentType: \"string\"\n        });\n        return destinationRaw(code);\n    }\n    /** @type {State} */ function destinationEnclosedBefore(code) {\n        if (code === 62) {\n            effects.enter(literalMarkerType);\n            effects.consume(code);\n            effects.exit(literalMarkerType);\n            effects.exit(literalType);\n            effects.exit(type);\n            return ok;\n        }\n        effects.enter(stringType);\n        effects.enter(\"chunkString\", {\n            contentType: \"string\"\n        });\n        return destinationEnclosed(code);\n    }\n    /** @type {State} */ function destinationEnclosed(code) {\n        if (code === 62) {\n            effects.exit(\"chunkString\");\n            effects.exit(stringType);\n            return destinationEnclosedBefore(code);\n        }\n        if (code === null || code === 60 || (0, $iUvtM.markdownLineEnding)(code)) return nok(code);\n        effects.consume(code);\n        return code === 92 ? destinationEnclosedEscape : destinationEnclosed;\n    }\n    /** @type {State} */ function destinationEnclosedEscape(code) {\n        if (code === 60 || code === 62 || code === 92) {\n            effects.consume(code);\n            return destinationEnclosed;\n        }\n        return destinationEnclosed(code);\n    }\n    /** @type {State} */ function destinationRaw(code) {\n        if (code === 40) {\n            if (++balance > limit) return nok(code);\n            effects.consume(code);\n            return destinationRaw;\n        }\n        if (code === 41) {\n            if (!balance--) {\n                effects.exit(\"chunkString\");\n                effects.exit(stringType);\n                effects.exit(rawType);\n                effects.exit(type);\n                return ok(code);\n            }\n            effects.consume(code);\n            return destinationRaw;\n        }\n        if (code === null || (0, $iUvtM.markdownLineEndingOrSpace)(code)) {\n            if (balance) return nok(code);\n            effects.exit(\"chunkString\");\n            effects.exit(stringType);\n            effects.exit(rawType);\n            effects.exit(type);\n            return ok(code);\n        }\n        if ((0, $iUvtM.asciiControl)(code)) return nok(code);\n        effects.consume(code);\n        return code === 92 ? destinationRawEscape : destinationRaw;\n    }\n    /** @type {State} */ function destinationRawEscape(code) {\n        if (code === 40 || code === 41 || code === 92) {\n            effects.consume(code);\n            return destinationRaw;\n        }\n        return destinationRaw(code);\n    }\n}\n\n});\n\nparcelRequire.register(\"fDPPf\", function(module, exports) {\n\n$parcel$export(module.exports, \"factoryLabel\", () => $b632b306b4fd5043$export$7b768614d8ba97a7);\n/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $iUvtM = parcelRequire(\"iUvtM\");\nfunction $b632b306b4fd5043$export$7b768614d8ba97a7(effects, ok, nok, type, markerType, stringType) {\n    const self = this;\n    let size = 0;\n    /** @type {boolean} */ let data;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(type);\n        effects.enter(markerType);\n        effects.consume(code);\n        effects.exit(markerType);\n        effects.enter(stringType);\n        return atBreak;\n    }\n    /** @type {State} */ function atBreak(code) {\n        if (code === null || code === 91 || code === 93 && !data || /* To do: remove in the future once weve switched from\n       * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n       * which doesnt need this */ /* Hidden footnotes hook */ /* c8 ignore next 3 */ code === 94 && !size && \"_hiddenFootnoteSupport\" in self.parser.constructs || size > 999) return nok(code);\n        if (code === 93) {\n            effects.exit(stringType);\n            effects.enter(markerType);\n            effects.consume(code);\n            effects.exit(markerType);\n            effects.exit(type);\n            return ok;\n        }\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            effects.enter(\"lineEnding\");\n            effects.consume(code);\n            effects.exit(\"lineEnding\");\n            return atBreak;\n        }\n        effects.enter(\"chunkString\", {\n            contentType: \"string\"\n        });\n        return label(code);\n    }\n    /** @type {State} */ function label(code) {\n        if (code === null || code === 91 || code === 93 || (0, $iUvtM.markdownLineEnding)(code) || size++ > 999) {\n            effects.exit(\"chunkString\");\n            return atBreak(code);\n        }\n        effects.consume(code);\n        data = data || !(0, $iUvtM.markdownSpace)(code);\n        return code === 92 ? labelEscape : label;\n    }\n    /** @type {State} */ function labelEscape(code) {\n        if (code === 91 || code === 92 || code === 93) {\n            effects.consume(code);\n            size++;\n            return label;\n        }\n        return label(code);\n    }\n}\n\n});\n\nparcelRequire.register(\"hFl17\", function(module, exports) {\n\n$parcel$export(module.exports, \"factoryTitle\", () => $cdc6918eb8aa8f3b$export$f970569cc855e483);\n/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */ \nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\nfunction $cdc6918eb8aa8f3b$export$f970569cc855e483(effects, ok, nok, type, markerType, stringType) {\n    /** @type {NonNullable<Code>} */ let marker;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(type);\n        effects.enter(markerType);\n        effects.consume(code);\n        effects.exit(markerType);\n        marker = code === 40 ? 41 : code;\n        return atFirstTitleBreak;\n    }\n    /** @type {State} */ function atFirstTitleBreak(code) {\n        if (code === marker) {\n            effects.enter(markerType);\n            effects.consume(code);\n            effects.exit(markerType);\n            effects.exit(type);\n            return ok;\n        }\n        effects.enter(stringType);\n        return atTitleBreak(code);\n    }\n    /** @type {State} */ function atTitleBreak(code) {\n        if (code === marker) {\n            effects.exit(stringType);\n            return atFirstTitleBreak(marker);\n        }\n        if (code === null) return nok(code);\n         // Note: blank lines cant exist in content.\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            effects.enter(\"lineEnding\");\n            effects.consume(code);\n            effects.exit(\"lineEnding\");\n            return (0, $jH5RB.factorySpace)(effects, atTitleBreak, \"linePrefix\");\n        }\n        effects.enter(\"chunkString\", {\n            contentType: \"string\"\n        });\n        return title(code);\n    }\n    /** @type {State} */ function title(code) {\n        if (code === marker || code === null || (0, $iUvtM.markdownLineEnding)(code)) {\n            effects.exit(\"chunkString\");\n            return atTitleBreak(code);\n        }\n        effects.consume(code);\n        return code === 92 ? titleEscape : title;\n    }\n    /** @type {State} */ function titleEscape(code) {\n        if (code === marker || code === 92) {\n            effects.consume(code);\n            return title;\n        }\n        return title(code);\n    }\n}\n\n});\n\nparcelRequire.register(\"e4FUu\", function(module, exports) {\n\n$parcel$export(module.exports, \"factoryWhitespace\", () => $a3f1f2e26d47e9ab$export$1f27bd1aa33ce173);\n/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\nfunction $a3f1f2e26d47e9ab$export$1f27bd1aa33ce173(effects, ok) {\n    /** @type {boolean} */ let seen;\n    return start;\n    /** @type {State} */ function start(code) {\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            effects.enter(\"lineEnding\");\n            effects.consume(code);\n            effects.exit(\"lineEnding\");\n            seen = true;\n            return start;\n        }\n        if ((0, $iUvtM.markdownSpace)(code)) return (0, $jH5RB.factorySpace)(effects, start, seen ? \"linePrefix\" : \"lineSuffix\")(code);\n        return ok(code);\n    }\n}\n\n});\n\nparcelRequire.register(\"3ac70\", function(module, exports) {\n\n$parcel$export(module.exports, \"normalizeIdentifier\", () => $24dbb37024226bd1$export$806d55e226cfcd08);\n/**\n * Normalize an identifier (such as used in definitions).\n *\n * @param {string} value\n * @returns {string}\n */ function $24dbb37024226bd1$export$806d55e226cfcd08(value) {\n    return value // Collapse Markdown whitespace.\n    .replace(/[\\t\\n\\r ]+/g, \" \") // Trim.\n    .replace(/^ | $/g, \"\") // Some characters are considered uppercase, but if their lowercase\n    // counterpart is uppercased will result in a different uppercase\n    // character.\n    // Hence, to get that form, we perform both lower- and uppercase.\n    // Upper case makes sure keys will not interact with default prototypal\n    // methods: no method is uppercase.\n    .toLowerCase().toUpperCase();\n}\n\n});\n\n\nparcelRequire.register(\"h2kyO\", function(module, exports) {\n\n$parcel$export(module.exports, \"hardBreakEscape\", () => $c67292758c3a9417$export$86c573ab9e06f418);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $iUvtM = parcelRequire(\"iUvtM\");\nconst $c67292758c3a9417$export$86c573ab9e06f418 = {\n    name: \"hardBreakEscape\",\n    tokenize: $c67292758c3a9417$var$tokenizeHardBreakEscape\n};\n/** @type {Tokenizer} */ function $c67292758c3a9417$var$tokenizeHardBreakEscape(effects, ok, nok) {\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"hardBreakEscape\");\n        effects.enter(\"escapeMarker\");\n        effects.consume(code);\n        return open;\n    }\n    /** @type {State} */ function open(code) {\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            effects.exit(\"escapeMarker\");\n            effects.exit(\"hardBreakEscape\");\n            return ok(code);\n        }\n        return nok(code);\n    }\n}\n\n});\n\nparcelRequire.register(\"kSTx0\", function(module, exports) {\n\n$parcel$export(module.exports, \"headingAtx\", () => $f343ed25fab8a66c$export$3871e9deb360695c);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\n\nvar $2Qp1S = parcelRequire(\"2Qp1S\");\nconst $f343ed25fab8a66c$export$3871e9deb360695c = {\n    name: \"headingAtx\",\n    tokenize: $f343ed25fab8a66c$var$tokenizeHeadingAtx,\n    resolve: $f343ed25fab8a66c$var$resolveHeadingAtx\n};\n/** @type {Resolver} */ function $f343ed25fab8a66c$var$resolveHeadingAtx(events, context) {\n    let contentEnd = events.length - 2;\n    let contentStart = 3;\n    /** @type {Token} */ let content;\n    /** @type {Token} */ let text // Prefix whitespace, part of the opening.\n    ;\n    if (events[contentStart][1].type === \"whitespace\") contentStart += 2;\n     // Suffix whitespace, part of the closing.\n    if (contentEnd - 2 > contentStart && events[contentEnd][1].type === \"whitespace\") contentEnd -= 2;\n    if (events[contentEnd][1].type === \"atxHeadingSequence\" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === \"whitespace\")) contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;\n    if (contentEnd > contentStart) {\n        content = {\n            type: \"atxHeadingText\",\n            start: events[contentStart][1].start,\n            end: events[contentEnd][1].end\n        };\n        text = {\n            type: \"chunkText\",\n            start: events[contentStart][1].start,\n            end: events[contentEnd][1].end,\n            // @ts-expect-error Constants are fine to assign.\n            contentType: \"text\"\n        };\n        (0, $2Qp1S.splice)(events, contentStart, contentEnd - contentStart + 1, [\n            [\n                \"enter\",\n                content,\n                context\n            ],\n            [\n                \"enter\",\n                text,\n                context\n            ],\n            [\n                \"exit\",\n                text,\n                context\n            ],\n            [\n                \"exit\",\n                content,\n                context\n            ]\n        ]);\n    }\n    return events;\n}\n/** @type {Tokenizer} */ function $f343ed25fab8a66c$var$tokenizeHeadingAtx(effects, ok, nok) {\n    const self = this;\n    let size = 0;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"atxHeading\");\n        effects.enter(\"atxHeadingSequence\");\n        return fenceOpenInside(code);\n    }\n    /** @type {State} */ function fenceOpenInside(code) {\n        if (code === 35 && size++ < 6) {\n            effects.consume(code);\n            return fenceOpenInside;\n        }\n        if (code === null || (0, $iUvtM.markdownLineEndingOrSpace)(code)) {\n            effects.exit(\"atxHeadingSequence\");\n            return self.interrupt ? ok(code) : headingBreak(code);\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function headingBreak(code) {\n        if (code === 35) {\n            effects.enter(\"atxHeadingSequence\");\n            return sequence(code);\n        }\n        if (code === null || (0, $iUvtM.markdownLineEnding)(code)) {\n            effects.exit(\"atxHeading\");\n            return ok(code);\n        }\n        if ((0, $iUvtM.markdownSpace)(code)) return (0, $jH5RB.factorySpace)(effects, headingBreak, \"whitespace\")(code);\n        effects.enter(\"atxHeadingText\");\n        return data(code);\n    }\n    /** @type {State} */ function sequence(code) {\n        if (code === 35) {\n            effects.consume(code);\n            return sequence;\n        }\n        effects.exit(\"atxHeadingSequence\");\n        return headingBreak(code);\n    }\n    /** @type {State} */ function data(code) {\n        if (code === null || code === 35 || (0, $iUvtM.markdownLineEndingOrSpace)(code)) {\n            effects.exit(\"atxHeadingText\");\n            return headingBreak(code);\n        }\n        effects.consume(code);\n        return data;\n    }\n}\n\n});\n\nparcelRequire.register(\"4vLKK\", function(module, exports) {\n\n$parcel$export(module.exports, \"htmlFlow\", () => $348f19684487bb7f$export$476ac411cb7d0d8f);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */ \nvar $iUvtM = parcelRequire(\"iUvtM\");\n\nvar $gZx53 = parcelRequire(\"gZx53\");\n\nvar $7jf0e = parcelRequire(\"7jf0e\");\nconst $348f19684487bb7f$export$476ac411cb7d0d8f = {\n    name: \"htmlFlow\",\n    tokenize: $348f19684487bb7f$var$tokenizeHtmlFlow,\n    resolveTo: $348f19684487bb7f$var$resolveToHtmlFlow,\n    concrete: true\n};\n/** @type {Construct} */ const $348f19684487bb7f$var$nextBlankConstruct = {\n    tokenize: $348f19684487bb7f$var$tokenizeNextBlank,\n    partial: true\n};\n/** @type {Resolver} */ function $348f19684487bb7f$var$resolveToHtmlFlow(events) {\n    let index = events.length;\n    while(index--){\n        if (events[index][0] === \"enter\" && events[index][1].type === \"htmlFlow\") break;\n    }\n    if (index > 1 && events[index - 2][1].type === \"linePrefix\") {\n        // Add the prefix start to the HTML token.\n        events[index][1].start = events[index - 2][1].start // Add the prefix start to the HTML line token.\n        ;\n        events[index + 1][1].start = events[index - 2][1].start // Remove the line prefix.\n        ;\n        events.splice(index - 2, 2);\n    }\n    return events;\n}\n/** @type {Tokenizer} */ function $348f19684487bb7f$var$tokenizeHtmlFlow(effects, ok, nok) {\n    const self = this;\n    /** @type {number} */ let kind;\n    /** @type {boolean} */ let startTag;\n    /** @type {string} */ let buffer;\n    /** @type {number} */ let index;\n    /** @type {Code} */ let marker;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"htmlFlow\");\n        effects.enter(\"htmlFlowData\");\n        effects.consume(code);\n        return open;\n    }\n    /** @type {State} */ function open(code) {\n        if (code === 33) {\n            effects.consume(code);\n            return declarationStart;\n        }\n        if (code === 47) {\n            effects.consume(code);\n            return tagCloseStart;\n        }\n        if (code === 63) {\n            effects.consume(code);\n            kind = 3 // While were in an instruction instead of a declaration, were on a `?`\n            ;\n            // right now, so we do need to search for `>`, similar to declarations.\n            return self.interrupt ? ok : continuationDeclarationInside;\n        }\n        if ((0, $iUvtM.asciiAlpha)(code)) {\n            effects.consume(code);\n            buffer = String.fromCharCode(code);\n            startTag = true;\n            return tagName;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function declarationStart(code) {\n        if (code === 45) {\n            effects.consume(code);\n            kind = 2;\n            return commentOpenInside;\n        }\n        if (code === 91) {\n            effects.consume(code);\n            kind = 5;\n            buffer = \"CDATA[\";\n            index = 0;\n            return cdataOpenInside;\n        }\n        if ((0, $iUvtM.asciiAlpha)(code)) {\n            effects.consume(code);\n            kind = 4;\n            return self.interrupt ? ok : continuationDeclarationInside;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function commentOpenInside(code) {\n        if (code === 45) {\n            effects.consume(code);\n            return self.interrupt ? ok : continuationDeclarationInside;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function cdataOpenInside(code) {\n        if (code === buffer.charCodeAt(index++)) {\n            effects.consume(code);\n            return index === buffer.length ? self.interrupt ? ok : continuation : cdataOpenInside;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function tagCloseStart(code) {\n        if ((0, $iUvtM.asciiAlpha)(code)) {\n            effects.consume(code);\n            buffer = String.fromCharCode(code);\n            return tagName;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function tagName(code) {\n        if (code === null || code === 47 || code === 62 || (0, $iUvtM.markdownLineEndingOrSpace)(code)) {\n            if (code !== 47 && startTag && (0, $gZx53.htmlRawNames).includes(buffer.toLowerCase())) {\n                kind = 1;\n                return self.interrupt ? ok(code) : continuation(code);\n            }\n            if ((0, $gZx53.htmlBlockNames).includes(buffer.toLowerCase())) {\n                kind = 6;\n                if (code === 47) {\n                    effects.consume(code);\n                    return basicSelfClosing;\n                }\n                return self.interrupt ? ok(code) : continuation(code);\n            }\n            kind = 7 // Do not support complete HTML when interrupting\n            ;\n            return self.interrupt && !self.parser.lazy[self.now().line] ? nok(code) : startTag ? completeAttributeNameBefore(code) : completeClosingTagAfter(code);\n        }\n        if (code === 45 || (0, $iUvtM.asciiAlphanumeric)(code)) {\n            effects.consume(code);\n            buffer += String.fromCharCode(code);\n            return tagName;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function basicSelfClosing(code) {\n        if (code === 62) {\n            effects.consume(code);\n            return self.interrupt ? ok : continuation;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function completeClosingTagAfter(code) {\n        if ((0, $iUvtM.markdownSpace)(code)) {\n            effects.consume(code);\n            return completeClosingTagAfter;\n        }\n        return completeEnd(code);\n    }\n    /** @type {State} */ function completeAttributeNameBefore(code) {\n        if (code === 47) {\n            effects.consume(code);\n            return completeEnd;\n        }\n        if (code === 58 || code === 95 || (0, $iUvtM.asciiAlpha)(code)) {\n            effects.consume(code);\n            return completeAttributeName;\n        }\n        if ((0, $iUvtM.markdownSpace)(code)) {\n            effects.consume(code);\n            return completeAttributeNameBefore;\n        }\n        return completeEnd(code);\n    }\n    /** @type {State} */ function completeAttributeName(code) {\n        if (code === 45 || code === 46 || code === 58 || code === 95 || (0, $iUvtM.asciiAlphanumeric)(code)) {\n            effects.consume(code);\n            return completeAttributeName;\n        }\n        return completeAttributeNameAfter(code);\n    }\n    /** @type {State} */ function completeAttributeNameAfter(code) {\n        if (code === 61) {\n            effects.consume(code);\n            return completeAttributeValueBefore;\n        }\n        if ((0, $iUvtM.markdownSpace)(code)) {\n            effects.consume(code);\n            return completeAttributeNameAfter;\n        }\n        return completeAttributeNameBefore(code);\n    }\n    /** @type {State} */ function completeAttributeValueBefore(code) {\n        if (code === null || code === 60 || code === 61 || code === 62 || code === 96) return nok(code);\n        if (code === 34 || code === 39) {\n            effects.consume(code);\n            marker = code;\n            return completeAttributeValueQuoted;\n        }\n        if ((0, $iUvtM.markdownSpace)(code)) {\n            effects.consume(code);\n            return completeAttributeValueBefore;\n        }\n        marker = null;\n        return completeAttributeValueUnquoted(code);\n    }\n    /** @type {State} */ function completeAttributeValueQuoted(code) {\n        if (code === null || (0, $iUvtM.markdownLineEnding)(code)) return nok(code);\n        if (code === marker) {\n            effects.consume(code);\n            return completeAttributeValueQuotedAfter;\n        }\n        effects.consume(code);\n        return completeAttributeValueQuoted;\n    }\n    /** @type {State} */ function completeAttributeValueUnquoted(code) {\n        if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 62 || code === 96 || (0, $iUvtM.markdownLineEndingOrSpace)(code)) return completeAttributeNameAfter(code);\n        effects.consume(code);\n        return completeAttributeValueUnquoted;\n    }\n    /** @type {State} */ function completeAttributeValueQuotedAfter(code) {\n        if (code === 47 || code === 62 || (0, $iUvtM.markdownSpace)(code)) return completeAttributeNameBefore(code);\n        return nok(code);\n    }\n    /** @type {State} */ function completeEnd(code) {\n        if (code === 62) {\n            effects.consume(code);\n            return completeAfter;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function completeAfter(code) {\n        if ((0, $iUvtM.markdownSpace)(code)) {\n            effects.consume(code);\n            return completeAfter;\n        }\n        return code === null || (0, $iUvtM.markdownLineEnding)(code) ? continuation(code) : nok(code);\n    }\n    /** @type {State} */ function continuation(code) {\n        if (code === 45 && kind === 2) {\n            effects.consume(code);\n            return continuationCommentInside;\n        }\n        if (code === 60 && kind === 1) {\n            effects.consume(code);\n            return continuationRawTagOpen;\n        }\n        if (code === 62 && kind === 4) {\n            effects.consume(code);\n            return continuationClose;\n        }\n        if (code === 63 && kind === 3) {\n            effects.consume(code);\n            return continuationDeclarationInside;\n        }\n        if (code === 93 && kind === 5) {\n            effects.consume(code);\n            return continuationCharacterDataInside;\n        }\n        if ((0, $iUvtM.markdownLineEnding)(code) && (kind === 6 || kind === 7)) return effects.check($348f19684487bb7f$var$nextBlankConstruct, continuationClose, continuationAtLineEnding)(code);\n        if (code === null || (0, $iUvtM.markdownLineEnding)(code)) return continuationAtLineEnding(code);\n        effects.consume(code);\n        return continuation;\n    }\n    /** @type {State} */ function continuationAtLineEnding(code) {\n        effects.exit(\"htmlFlowData\");\n        return htmlContinueStart(code);\n    }\n    /** @type {State} */ function htmlContinueStart(code) {\n        if (code === null) return done(code);\n        if ((0, $iUvtM.markdownLineEnding)(code)) return effects.attempt({\n            tokenize: htmlLineEnd,\n            partial: true\n        }, htmlContinueStart, done)(code);\n        effects.enter(\"htmlFlowData\");\n        return continuation(code);\n    }\n    /** @type {Tokenizer} */ function htmlLineEnd(effects, ok, nok) {\n        return start;\n        /** @type {State} */ function start(code) {\n            effects.enter(\"lineEnding\");\n            effects.consume(code);\n            effects.exit(\"lineEnding\");\n            return lineStart;\n        }\n        /** @type {State} */ function lineStart(code) {\n            return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n        }\n    }\n    /** @type {State} */ function continuationCommentInside(code) {\n        if (code === 45) {\n            effects.consume(code);\n            return continuationDeclarationInside;\n        }\n        return continuation(code);\n    }\n    /** @type {State} */ function continuationRawTagOpen(code) {\n        if (code === 47) {\n            effects.consume(code);\n            buffer = \"\";\n            return continuationRawEndTag;\n        }\n        return continuation(code);\n    }\n    /** @type {State} */ function continuationRawEndTag(code) {\n        if (code === 62 && (0, $gZx53.htmlRawNames).includes(buffer.toLowerCase())) {\n            effects.consume(code);\n            return continuationClose;\n        }\n        if ((0, $iUvtM.asciiAlpha)(code) && buffer.length < 8) {\n            effects.consume(code);\n            buffer += String.fromCharCode(code);\n            return continuationRawEndTag;\n        }\n        return continuation(code);\n    }\n    /** @type {State} */ function continuationCharacterDataInside(code) {\n        if (code === 93) {\n            effects.consume(code);\n            return continuationDeclarationInside;\n        }\n        return continuation(code);\n    }\n    /** @type {State} */ function continuationDeclarationInside(code) {\n        if (code === 62) {\n            effects.consume(code);\n            return continuationClose;\n        } // More dashes.\n        if (code === 45 && kind === 2) {\n            effects.consume(code);\n            return continuationDeclarationInside;\n        }\n        return continuation(code);\n    }\n    /** @type {State} */ function continuationClose(code) {\n        if (code === null || (0, $iUvtM.markdownLineEnding)(code)) {\n            effects.exit(\"htmlFlowData\");\n            return done(code);\n        }\n        effects.consume(code);\n        return continuationClose;\n    }\n    /** @type {State} */ function done(code) {\n        effects.exit(\"htmlFlow\");\n        return ok(code);\n    }\n}\n/** @type {Tokenizer} */ function $348f19684487bb7f$var$tokenizeNextBlank(effects, ok, nok) {\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.exit(\"htmlFlowData\");\n        effects.enter(\"lineEndingBlank\");\n        effects.consume(code);\n        effects.exit(\"lineEndingBlank\");\n        return effects.attempt((0, $7jf0e.blankLine), ok, nok);\n    }\n}\n\n});\nparcelRequire.register(\"gZx53\", function(module, exports) {\n\n$parcel$export(module.exports, \"htmlBlockNames\", () => $c5ec00f1b3028007$export$7364aee1c59d1879);\n$parcel$export(module.exports, \"htmlRawNames\", () => $c5ec00f1b3028007$export$948e66da505d080);\n/**\n * List of lowercase HTML tag names which when parsing HTML (flow), result\n * in more relaxed rules (condition 6): because they are known blocks, the\n * HTML-like syntax doesnt have to be strictly parsed.\n * For tag names not in this list, a more strict algorithm (condition 7) is used\n * to detect whether the HTML-like syntax is seen as HTML (flow) or not.\n *\n * This is copied from:\n * <https://spec.commonmark.org/0.30/#html-blocks>.\n */ const $c5ec00f1b3028007$export$7364aee1c59d1879 = [\n    \"address\",\n    \"article\",\n    \"aside\",\n    \"base\",\n    \"basefont\",\n    \"blockquote\",\n    \"body\",\n    \"caption\",\n    \"center\",\n    \"col\",\n    \"colgroup\",\n    \"dd\",\n    \"details\",\n    \"dialog\",\n    \"dir\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"frame\",\n    \"frameset\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"head\",\n    \"header\",\n    \"hr\",\n    \"html\",\n    \"iframe\",\n    \"legend\",\n    \"li\",\n    \"link\",\n    \"main\",\n    \"menu\",\n    \"menuitem\",\n    \"nav\",\n    \"noframes\",\n    \"ol\",\n    \"optgroup\",\n    \"option\",\n    \"p\",\n    \"param\",\n    \"section\",\n    \"summary\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"title\",\n    \"tr\",\n    \"track\",\n    \"ul\"\n];\nconst $c5ec00f1b3028007$export$948e66da505d080 = [\n    \"pre\",\n    \"script\",\n    \"style\",\n    \"textarea\"\n];\n\n});\n\n\nparcelRequire.register(\"bgjqA\", function(module, exports) {\n\n$parcel$export(module.exports, \"htmlText\", () => $8330424d747ed971$export$398af27f284914fe);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */ \nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\nconst $8330424d747ed971$export$398af27f284914fe = {\n    name: \"htmlText\",\n    tokenize: $8330424d747ed971$var$tokenizeHtmlText\n};\n/** @type {Tokenizer} */ function $8330424d747ed971$var$tokenizeHtmlText(effects, ok, nok) {\n    const self = this;\n    /** @type {NonNullable<Code>|undefined} */ let marker;\n    /** @type {string} */ let buffer;\n    /** @type {number} */ let index;\n    /** @type {State} */ let returnState;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"htmlText\");\n        effects.enter(\"htmlTextData\");\n        effects.consume(code);\n        return open;\n    }\n    /** @type {State} */ function open(code) {\n        if (code === 33) {\n            effects.consume(code);\n            return declarationOpen;\n        }\n        if (code === 47) {\n            effects.consume(code);\n            return tagCloseStart;\n        }\n        if (code === 63) {\n            effects.consume(code);\n            return instruction;\n        }\n        if ((0, $iUvtM.asciiAlpha)(code)) {\n            effects.consume(code);\n            return tagOpen;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function declarationOpen(code) {\n        if (code === 45) {\n            effects.consume(code);\n            return commentOpen;\n        }\n        if (code === 91) {\n            effects.consume(code);\n            buffer = \"CDATA[\";\n            index = 0;\n            return cdataOpen;\n        }\n        if ((0, $iUvtM.asciiAlpha)(code)) {\n            effects.consume(code);\n            return declaration;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function commentOpen(code) {\n        if (code === 45) {\n            effects.consume(code);\n            return commentStart;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function commentStart(code) {\n        if (code === null || code === 62) return nok(code);\n        if (code === 45) {\n            effects.consume(code);\n            return commentStartDash;\n        }\n        return comment(code);\n    }\n    /** @type {State} */ function commentStartDash(code) {\n        if (code === null || code === 62) return nok(code);\n        return comment(code);\n    }\n    /** @type {State} */ function comment(code) {\n        if (code === null) return nok(code);\n        if (code === 45) {\n            effects.consume(code);\n            return commentClose;\n        }\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            returnState = comment;\n            return atLineEnding(code);\n        }\n        effects.consume(code);\n        return comment;\n    }\n    /** @type {State} */ function commentClose(code) {\n        if (code === 45) {\n            effects.consume(code);\n            return end;\n        }\n        return comment(code);\n    }\n    /** @type {State} */ function cdataOpen(code) {\n        if (code === buffer.charCodeAt(index++)) {\n            effects.consume(code);\n            return index === buffer.length ? cdata : cdataOpen;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function cdata(code) {\n        if (code === null) return nok(code);\n        if (code === 93) {\n            effects.consume(code);\n            return cdataClose;\n        }\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            returnState = cdata;\n            return atLineEnding(code);\n        }\n        effects.consume(code);\n        return cdata;\n    }\n    /** @type {State} */ function cdataClose(code) {\n        if (code === 93) {\n            effects.consume(code);\n            return cdataEnd;\n        }\n        return cdata(code);\n    }\n    /** @type {State} */ function cdataEnd(code) {\n        if (code === 62) return end(code);\n        if (code === 93) {\n            effects.consume(code);\n            return cdataEnd;\n        }\n        return cdata(code);\n    }\n    /** @type {State} */ function declaration(code) {\n        if (code === null || code === 62) return end(code);\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            returnState = declaration;\n            return atLineEnding(code);\n        }\n        effects.consume(code);\n        return declaration;\n    }\n    /** @type {State} */ function instruction(code) {\n        if (code === null) return nok(code);\n        if (code === 63) {\n            effects.consume(code);\n            return instructionClose;\n        }\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            returnState = instruction;\n            return atLineEnding(code);\n        }\n        effects.consume(code);\n        return instruction;\n    }\n    /** @type {State} */ function instructionClose(code) {\n        return code === 62 ? end(code) : instruction(code);\n    }\n    /** @type {State} */ function tagCloseStart(code) {\n        if ((0, $iUvtM.asciiAlpha)(code)) {\n            effects.consume(code);\n            return tagClose;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function tagClose(code) {\n        if (code === 45 || (0, $iUvtM.asciiAlphanumeric)(code)) {\n            effects.consume(code);\n            return tagClose;\n        }\n        return tagCloseBetween(code);\n    }\n    /** @type {State} */ function tagCloseBetween(code) {\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            returnState = tagCloseBetween;\n            return atLineEnding(code);\n        }\n        if ((0, $iUvtM.markdownSpace)(code)) {\n            effects.consume(code);\n            return tagCloseBetween;\n        }\n        return end(code);\n    }\n    /** @type {State} */ function tagOpen(code) {\n        if (code === 45 || (0, $iUvtM.asciiAlphanumeric)(code)) {\n            effects.consume(code);\n            return tagOpen;\n        }\n        if (code === 47 || code === 62 || (0, $iUvtM.markdownLineEndingOrSpace)(code)) return tagOpenBetween(code);\n        return nok(code);\n    }\n    /** @type {State} */ function tagOpenBetween(code) {\n        if (code === 47) {\n            effects.consume(code);\n            return end;\n        }\n        if (code === 58 || code === 95 || (0, $iUvtM.asciiAlpha)(code)) {\n            effects.consume(code);\n            return tagOpenAttributeName;\n        }\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            returnState = tagOpenBetween;\n            return atLineEnding(code);\n        }\n        if ((0, $iUvtM.markdownSpace)(code)) {\n            effects.consume(code);\n            return tagOpenBetween;\n        }\n        return end(code);\n    }\n    /** @type {State} */ function tagOpenAttributeName(code) {\n        if (code === 45 || code === 46 || code === 58 || code === 95 || (0, $iUvtM.asciiAlphanumeric)(code)) {\n            effects.consume(code);\n            return tagOpenAttributeName;\n        }\n        return tagOpenAttributeNameAfter(code);\n    }\n    /** @type {State} */ function tagOpenAttributeNameAfter(code) {\n        if (code === 61) {\n            effects.consume(code);\n            return tagOpenAttributeValueBefore;\n        }\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            returnState = tagOpenAttributeNameAfter;\n            return atLineEnding(code);\n        }\n        if ((0, $iUvtM.markdownSpace)(code)) {\n            effects.consume(code);\n            return tagOpenAttributeNameAfter;\n        }\n        return tagOpenBetween(code);\n    }\n    /** @type {State} */ function tagOpenAttributeValueBefore(code) {\n        if (code === null || code === 60 || code === 61 || code === 62 || code === 96) return nok(code);\n        if (code === 34 || code === 39) {\n            effects.consume(code);\n            marker = code;\n            return tagOpenAttributeValueQuoted;\n        }\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            returnState = tagOpenAttributeValueBefore;\n            return atLineEnding(code);\n        }\n        if ((0, $iUvtM.markdownSpace)(code)) {\n            effects.consume(code);\n            return tagOpenAttributeValueBefore;\n        }\n        effects.consume(code);\n        marker = undefined;\n        return tagOpenAttributeValueUnquoted;\n    }\n    /** @type {State} */ function tagOpenAttributeValueQuoted(code) {\n        if (code === marker) {\n            effects.consume(code);\n            return tagOpenAttributeValueQuotedAfter;\n        }\n        if (code === null) return nok(code);\n        if ((0, $iUvtM.markdownLineEnding)(code)) {\n            returnState = tagOpenAttributeValueQuoted;\n            return atLineEnding(code);\n        }\n        effects.consume(code);\n        return tagOpenAttributeValueQuoted;\n    }\n    /** @type {State} */ function tagOpenAttributeValueQuotedAfter(code) {\n        if (code === 62 || code === 47 || (0, $iUvtM.markdownLineEndingOrSpace)(code)) return tagOpenBetween(code);\n        return nok(code);\n    }\n    /** @type {State} */ function tagOpenAttributeValueUnquoted(code) {\n        if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 96) return nok(code);\n        if (code === 62 || (0, $iUvtM.markdownLineEndingOrSpace)(code)) return tagOpenBetween(code);\n        effects.consume(code);\n        return tagOpenAttributeValueUnquoted;\n    } // We cant have blank lines in content, so no need to worry about empty\n    // tokens.\n    /** @type {State} */ function atLineEnding(code) {\n        effects.exit(\"htmlTextData\");\n        effects.enter(\"lineEnding\");\n        effects.consume(code);\n        effects.exit(\"lineEnding\");\n        return (0, $jH5RB.factorySpace)(effects, afterPrefix, \"linePrefix\", self.parser.constructs.disable.null.includes(\"codeIndented\") ? undefined : 4);\n    }\n    /** @type {State} */ function afterPrefix(code) {\n        effects.enter(\"htmlTextData\");\n        return returnState(code);\n    }\n    /** @type {State} */ function end(code) {\n        if (code === 62) {\n            effects.consume(code);\n            effects.exit(\"htmlTextData\");\n            effects.exit(\"htmlText\");\n            return ok;\n        }\n        return nok(code);\n    }\n}\n\n});\n\nparcelRequire.register(\"dz9VB\", function(module, exports) {\n\n$parcel$export(module.exports, \"labelEnd\", () => $9e063ebe1e586afe$export$470a5dafbbf62654);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */ \nvar $DVYDN = parcelRequire(\"DVYDN\");\n\nvar $fDPPf = parcelRequire(\"fDPPf\");\n\nvar $hFl17 = parcelRequire(\"hFl17\");\n\nvar $e4FUu = parcelRequire(\"e4FUu\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\n\nvar $2Qp1S = parcelRequire(\"2Qp1S\");\n\nvar $3ac70 = parcelRequire(\"3ac70\");\n\nvar $km4eF = parcelRequire(\"km4eF\");\nconst $9e063ebe1e586afe$export$470a5dafbbf62654 = {\n    name: \"labelEnd\",\n    tokenize: $9e063ebe1e586afe$var$tokenizeLabelEnd,\n    resolveTo: $9e063ebe1e586afe$var$resolveToLabelEnd,\n    resolveAll: $9e063ebe1e586afe$var$resolveAllLabelEnd\n};\n/** @type {Construct} */ const $9e063ebe1e586afe$var$resourceConstruct = {\n    tokenize: $9e063ebe1e586afe$var$tokenizeResource\n};\n/** @type {Construct} */ const $9e063ebe1e586afe$var$fullReferenceConstruct = {\n    tokenize: $9e063ebe1e586afe$var$tokenizeFullReference\n};\n/** @type {Construct} */ const $9e063ebe1e586afe$var$collapsedReferenceConstruct = {\n    tokenize: $9e063ebe1e586afe$var$tokenizeCollapsedReference\n};\n/** @type {Resolver} */ function $9e063ebe1e586afe$var$resolveAllLabelEnd(events) {\n    let index = -1;\n    /** @type {Token} */ let token;\n    while(++index < events.length){\n        token = events[index][1];\n        if (token.type === \"labelImage\" || token.type === \"labelLink\" || token.type === \"labelEnd\") {\n            // Remove the marker.\n            events.splice(index + 1, token.type === \"labelImage\" ? 4 : 2);\n            token.type = \"data\";\n            index++;\n        }\n    }\n    return events;\n}\n/** @type {Resolver} */ function $9e063ebe1e586afe$var$resolveToLabelEnd(events, context) {\n    let index = events.length;\n    let offset = 0;\n    /** @type {Token} */ let token;\n    /** @type {number|undefined} */ let open;\n    /** @type {number|undefined} */ let close;\n    /** @type {Event[]} */ let media // Find an opening.\n    ;\n    while(index--){\n        token = events[index][1];\n        if (open) {\n            // If we see another link, or inactive link label, weve been here before.\n            if (token.type === \"link\" || token.type === \"labelLink\" && token._inactive) break;\n             // Mark other link openings as inactive, as we cant have links in\n            // links.\n            if (events[index][0] === \"enter\" && token.type === \"labelLink\") token._inactive = true;\n        } else if (close) {\n            if (events[index][0] === \"enter\" && (token.type === \"labelImage\" || token.type === \"labelLink\") && !token._balanced) {\n                open = index;\n                if (token.type !== \"labelLink\") {\n                    offset = 2;\n                    break;\n                }\n            }\n        } else if (token.type === \"labelEnd\") close = index;\n    }\n    const group = {\n        type: events[open][1].type === \"labelLink\" ? \"link\" : \"image\",\n        start: Object.assign({}, events[open][1].start),\n        end: Object.assign({}, events[events.length - 1][1].end)\n    };\n    const label = {\n        type: \"label\",\n        start: Object.assign({}, events[open][1].start),\n        end: Object.assign({}, events[close][1].end)\n    };\n    const text = {\n        type: \"labelText\",\n        start: Object.assign({}, events[open + offset + 2][1].end),\n        end: Object.assign({}, events[close - 2][1].start)\n    };\n    media = [\n        [\n            \"enter\",\n            group,\n            context\n        ],\n        [\n            \"enter\",\n            label,\n            context\n        ]\n    ] // Opening marker.\n    ;\n    media = (0, $2Qp1S.push)(media, events.slice(open + 1, open + offset + 3)) // Text open.\n    ;\n    media = (0, $2Qp1S.push)(media, [\n        [\n            \"enter\",\n            text,\n            context\n        ]\n    ]) // Between.\n    ;\n    media = (0, $2Qp1S.push)(media, (0, $km4eF.resolveAll)(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context)) // Text close, marker close, label close.\n    ;\n    media = (0, $2Qp1S.push)(media, [\n        [\n            \"exit\",\n            text,\n            context\n        ],\n        events[close - 2],\n        events[close - 1],\n        [\n            \"exit\",\n            label,\n            context\n        ]\n    ]) // Reference, resource, or so.\n    ;\n    media = (0, $2Qp1S.push)(media, events.slice(close + 1)) // Media close.\n    ;\n    media = (0, $2Qp1S.push)(media, [\n        [\n            \"exit\",\n            group,\n            context\n        ]\n    ]);\n    (0, $2Qp1S.splice)(events, open, events.length, media);\n    return events;\n}\n/** @type {Tokenizer} */ function $9e063ebe1e586afe$var$tokenizeLabelEnd(effects, ok, nok) {\n    const self = this;\n    let index = self.events.length;\n    /** @type {Token} */ let labelStart;\n    /** @type {boolean} */ let defined // Find an opening.\n    ;\n    while(index--)if ((self.events[index][1].type === \"labelImage\" || self.events[index][1].type === \"labelLink\") && !self.events[index][1]._balanced) {\n        labelStart = self.events[index][1];\n        break;\n    }\n    return start;\n    /** @type {State} */ function start(code) {\n        if (!labelStart) return nok(code);\n         // Its a balanced bracket, but contains a link.\n        if (labelStart._inactive) return balanced(code);\n        defined = self.parser.defined.includes((0, $3ac70.normalizeIdentifier)(self.sliceSerialize({\n            start: labelStart.end,\n            end: self.now()\n        })));\n        effects.enter(\"labelEnd\");\n        effects.enter(\"labelMarker\");\n        effects.consume(code);\n        effects.exit(\"labelMarker\");\n        effects.exit(\"labelEnd\");\n        return afterLabelEnd;\n    }\n    /** @type {State} */ function afterLabelEnd(code) {\n        // Resource: `[asd](fgh)`.\n        if (code === 40) return effects.attempt($9e063ebe1e586afe$var$resourceConstruct, ok, defined ? ok : balanced)(code);\n         // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n        if (code === 91) return effects.attempt($9e063ebe1e586afe$var$fullReferenceConstruct, ok, defined ? effects.attempt($9e063ebe1e586afe$var$collapsedReferenceConstruct, ok, balanced) : balanced)(code);\n         // Shortcut reference: `[asd]`?\n        return defined ? ok(code) : balanced(code);\n    }\n    /** @type {State} */ function balanced(code) {\n        labelStart._balanced = true;\n        return nok(code);\n    }\n}\n/** @type {Tokenizer} */ function $9e063ebe1e586afe$var$tokenizeResource(effects, ok, nok) {\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"resource\");\n        effects.enter(\"resourceMarker\");\n        effects.consume(code);\n        effects.exit(\"resourceMarker\");\n        return (0, $e4FUu.factoryWhitespace)(effects, open);\n    }\n    /** @type {State} */ function open(code) {\n        if (code === 41) return end(code);\n        return (0, $DVYDN.factoryDestination)(effects, destinationAfter, nok, \"resourceDestination\", \"resourceDestinationLiteral\", \"resourceDestinationLiteralMarker\", \"resourceDestinationRaw\", \"resourceDestinationString\", 32)(code);\n    }\n    /** @type {State} */ function destinationAfter(code) {\n        return (0, $iUvtM.markdownLineEndingOrSpace)(code) ? (0, $e4FUu.factoryWhitespace)(effects, between)(code) : end(code);\n    }\n    /** @type {State} */ function between(code) {\n        if (code === 34 || code === 39 || code === 40) return (0, $hFl17.factoryTitle)(effects, (0, $e4FUu.factoryWhitespace)(effects, end), nok, \"resourceTitle\", \"resourceTitleMarker\", \"resourceTitleString\")(code);\n        return end(code);\n    }\n    /** @type {State} */ function end(code) {\n        if (code === 41) {\n            effects.enter(\"resourceMarker\");\n            effects.consume(code);\n            effects.exit(\"resourceMarker\");\n            effects.exit(\"resource\");\n            return ok;\n        }\n        return nok(code);\n    }\n}\n/** @type {Tokenizer} */ function $9e063ebe1e586afe$var$tokenizeFullReference(effects, ok, nok) {\n    const self = this;\n    return start;\n    /** @type {State} */ function start(code) {\n        return (0, $fDPPf.factoryLabel).call(self, effects, afterLabel, nok, \"reference\", \"referenceMarker\", \"referenceString\")(code);\n    }\n    /** @type {State} */ function afterLabel(code) {\n        return self.parser.defined.includes((0, $3ac70.normalizeIdentifier)(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\n    }\n}\n/** @type {Tokenizer} */ function $9e063ebe1e586afe$var$tokenizeCollapsedReference(effects, ok, nok) {\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"reference\");\n        effects.enter(\"referenceMarker\");\n        effects.consume(code);\n        effects.exit(\"referenceMarker\");\n        return open;\n    }\n    /** @type {State} */ function open(code) {\n        if (code === 93) {\n            effects.enter(\"referenceMarker\");\n            effects.consume(code);\n            effects.exit(\"referenceMarker\");\n            effects.exit(\"reference\");\n            return ok;\n        }\n        return nok(code);\n    }\n}\n\n});\n\nparcelRequire.register(\"8be8Q\", function(module, exports) {\n\n$parcel$export(module.exports, \"labelStartImage\", () => $5f4a520d3aad06eb$export$3d754936e25aa5f5);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $dz9VB = parcelRequire(\"dz9VB\");\nconst $5f4a520d3aad06eb$export$3d754936e25aa5f5 = {\n    name: \"labelStartImage\",\n    tokenize: $5f4a520d3aad06eb$var$tokenizeLabelStartImage,\n    resolveAll: (0, $dz9VB.labelEnd).resolveAll\n};\n/** @type {Tokenizer} */ function $5f4a520d3aad06eb$var$tokenizeLabelStartImage(effects, ok, nok) {\n    const self = this;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"labelImage\");\n        effects.enter(\"labelImageMarker\");\n        effects.consume(code);\n        effects.exit(\"labelImageMarker\");\n        return open;\n    }\n    /** @type {State} */ function open(code) {\n        if (code === 91) {\n            effects.enter(\"labelMarker\");\n            effects.consume(code);\n            effects.exit(\"labelMarker\");\n            effects.exit(\"labelImage\");\n            return after;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function after(code) {\n        /* To do: remove in the future once weve switched from\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n     * which doesnt need this */ /* Hidden footnotes hook */ /* c8 ignore next 3 */ return code === 94 && \"_hiddenFootnoteSupport\" in self.parser.constructs ? nok(code) : ok(code);\n    }\n}\n\n});\n\nparcelRequire.register(\"a9cNg\", function(module, exports) {\n\n$parcel$export(module.exports, \"labelStartLink\", () => $01e81346ffe0e376$export$5c0cee0701a3b584);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $dz9VB = parcelRequire(\"dz9VB\");\nconst $01e81346ffe0e376$export$5c0cee0701a3b584 = {\n    name: \"labelStartLink\",\n    tokenize: $01e81346ffe0e376$var$tokenizeLabelStartLink,\n    resolveAll: (0, $dz9VB.labelEnd).resolveAll\n};\n/** @type {Tokenizer} */ function $01e81346ffe0e376$var$tokenizeLabelStartLink(effects, ok, nok) {\n    const self = this;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"labelLink\");\n        effects.enter(\"labelMarker\");\n        effects.consume(code);\n        effects.exit(\"labelMarker\");\n        effects.exit(\"labelLink\");\n        return after;\n    }\n    /** @type {State} */ function after(code) {\n        /* To do: remove in the future once weve switched from\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n     * which doesnt need this */ /* Hidden footnotes hook. */ /* c8 ignore next 3 */ return code === 94 && \"_hiddenFootnoteSupport\" in self.parser.constructs ? nok(code) : ok(code);\n    }\n}\n\n});\n\nparcelRequire.register(\"hmr3Q\", function(module, exports) {\n\n$parcel$export(module.exports, \"lineEnding\", () => $ca397b7ad9fc1681$export$8e62e0ad51c97b2);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */ \nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nconst $ca397b7ad9fc1681$export$8e62e0ad51c97b2 = {\n    name: \"lineEnding\",\n    tokenize: $ca397b7ad9fc1681$var$tokenizeLineEnding\n};\n/** @type {Tokenizer} */ function $ca397b7ad9fc1681$var$tokenizeLineEnding(effects, ok) {\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"lineEnding\");\n        effects.consume(code);\n        effects.exit(\"lineEnding\");\n        return (0, $jH5RB.factorySpace)(effects, ok, \"linePrefix\");\n    }\n}\n\n});\n\nparcelRequire.register(\"1PP7G\", function(module, exports) {\n\n$parcel$export(module.exports, \"list\", () => $156235cc4d370751$export$8837f4fc672e936d);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */ /**\n * @typedef {Record<string, unknown> & {marker: Code, type: string, size: number}} ListContainerState\n * @typedef {TokenizeContext & {containerState: ListContainerState}} TokenizeContextWithState\n */ \nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\n\nvar $7jf0e = parcelRequire(\"7jf0e\");\n\nvar $5jHEg = parcelRequire(\"5jHEg\");\nconst $156235cc4d370751$export$8837f4fc672e936d = {\n    name: \"list\",\n    tokenize: $156235cc4d370751$var$tokenizeListStart,\n    continuation: {\n        tokenize: $156235cc4d370751$var$tokenizeListContinuation\n    },\n    exit: $156235cc4d370751$var$tokenizeListEnd\n};\n/** @type {Construct} */ const $156235cc4d370751$var$listItemPrefixWhitespaceConstruct = {\n    tokenize: $156235cc4d370751$var$tokenizeListItemPrefixWhitespace,\n    partial: true\n};\n/** @type {Construct} */ const $156235cc4d370751$var$indentConstruct = {\n    tokenize: $156235cc4d370751$var$tokenizeIndent,\n    partial: true\n};\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */ function $156235cc4d370751$var$tokenizeListStart(effects, ok, nok) {\n    const self = this;\n    const tail = self.events[self.events.length - 1];\n    let initialSize = tail && tail[1].type === \"linePrefix\" ? tail[2].sliceSerialize(tail[1], true).length : 0;\n    let size = 0;\n    return start;\n    /** @type {State} */ function start(code) {\n        const kind = self.containerState.type || (code === 42 || code === 43 || code === 45 ? \"listUnordered\" : \"listOrdered\");\n        if (kind === \"listUnordered\" ? !self.containerState.marker || code === self.containerState.marker : (0, $iUvtM.asciiDigit)(code)) {\n            if (!self.containerState.type) {\n                self.containerState.type = kind;\n                effects.enter(kind, {\n                    _container: true\n                });\n            }\n            if (kind === \"listUnordered\") {\n                effects.enter(\"listItemPrefix\");\n                return code === 42 || code === 45 ? effects.check((0, $5jHEg.thematicBreak), nok, atMarker)(code) : atMarker(code);\n            }\n            if (!self.interrupt || code === 49) {\n                effects.enter(\"listItemPrefix\");\n                effects.enter(\"listItemValue\");\n                return inside(code);\n            }\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function inside(code) {\n        if ((0, $iUvtM.asciiDigit)(code) && ++size < 10) {\n            effects.consume(code);\n            return inside;\n        }\n        if ((!self.interrupt || size < 2) && (self.containerState.marker ? code === self.containerState.marker : code === 41 || code === 46)) {\n            effects.exit(\"listItemValue\");\n            return atMarker(code);\n        }\n        return nok(code);\n    }\n    /**\n   * @type {State}\n   **/ function atMarker(code) {\n        effects.enter(\"listItemMarker\");\n        effects.consume(code);\n        effects.exit(\"listItemMarker\");\n        self.containerState.marker = self.containerState.marker || code;\n        return effects.check((0, $7jf0e.blankLine), self.interrupt ? nok : onBlank, effects.attempt($156235cc4d370751$var$listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));\n    }\n    /** @type {State} */ function onBlank(code) {\n        self.containerState.initialBlankLine = true;\n        initialSize++;\n        return endOfPrefix(code);\n    }\n    /** @type {State} */ function otherPrefix(code) {\n        if ((0, $iUvtM.markdownSpace)(code)) {\n            effects.enter(\"listItemPrefixWhitespace\");\n            effects.consume(code);\n            effects.exit(\"listItemPrefixWhitespace\");\n            return endOfPrefix;\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function endOfPrefix(code) {\n        self.containerState.size = initialSize + self.sliceSerialize(effects.exit(\"listItemPrefix\"), true).length;\n        return ok(code);\n    }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */ function $156235cc4d370751$var$tokenizeListContinuation(effects, ok, nok) {\n    const self = this;\n    self.containerState._closeFlow = undefined;\n    return effects.check((0, $7jf0e.blankLine), onBlank, notBlank);\n    /** @type {State} */ function onBlank(code) {\n        self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine // We have a blank line.\n        ;\n        // Still, try to consume at most the items size.\n        return (0, $jH5RB.factorySpace)(effects, ok, \"listItemIndent\", self.containerState.size + 1)(code);\n    }\n    /** @type {State} */ function notBlank(code) {\n        if (self.containerState.furtherBlankLines || !(0, $iUvtM.markdownSpace)(code)) {\n            self.containerState.furtherBlankLines = undefined;\n            self.containerState.initialBlankLine = undefined;\n            return notInCurrentItem(code);\n        }\n        self.containerState.furtherBlankLines = undefined;\n        self.containerState.initialBlankLine = undefined;\n        return effects.attempt($156235cc4d370751$var$indentConstruct, ok, notInCurrentItem)(code);\n    }\n    /** @type {State} */ function notInCurrentItem(code) {\n        // While we do continue, we signal that the flow should be closed.\n        self.containerState._closeFlow = true // As were closing flow, were no longer interrupting.\n        ;\n        self.interrupt = undefined;\n        return (0, $jH5RB.factorySpace)(effects, effects.attempt($156235cc4d370751$export$8837f4fc672e936d, ok, nok), \"linePrefix\", self.parser.constructs.disable.null.includes(\"codeIndented\") ? undefined : 4)(code);\n    }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */ function $156235cc4d370751$var$tokenizeIndent(effects, ok, nok) {\n    const self = this;\n    return (0, $jH5RB.factorySpace)(effects, afterPrefix, \"listItemIndent\", self.containerState.size + 1);\n    /** @type {State} */ function afterPrefix(code) {\n        const tail = self.events[self.events.length - 1];\n        return tail && tail[1].type === \"listItemIndent\" && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok(code) : nok(code);\n    }\n}\n/**\n * @type {Exiter}\n * @this {TokenizeContextWithState}\n */ function $156235cc4d370751$var$tokenizeListEnd(effects) {\n    effects.exit(this.containerState.type);\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */ function $156235cc4d370751$var$tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n    const self = this;\n    return (0, $jH5RB.factorySpace)(effects, afterPrefix, \"listItemPrefixWhitespace\", self.parser.constructs.disable.null.includes(\"codeIndented\") ? undefined : 5);\n    /** @type {State} */ function afterPrefix(code) {\n        const tail = self.events[self.events.length - 1];\n        return !(0, $iUvtM.markdownSpace)(code) && tail && tail[1].type === \"listItemPrefixWhitespace\" ? ok(code) : nok(code);\n    }\n}\n\n});\nparcelRequire.register(\"5jHEg\", function(module, exports) {\n\n$parcel$export(module.exports, \"thematicBreak\", () => $3df095c4dce56453$export$ba7b13e047416c03);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */ \nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\nconst $3df095c4dce56453$export$ba7b13e047416c03 = {\n    name: \"thematicBreak\",\n    tokenize: $3df095c4dce56453$var$tokenizeThematicBreak\n};\n/** @type {Tokenizer} */ function $3df095c4dce56453$var$tokenizeThematicBreak(effects, ok, nok) {\n    let size = 0;\n    /** @type {NonNullable<Code>} */ let marker;\n    return start;\n    /** @type {State} */ function start(code) {\n        effects.enter(\"thematicBreak\");\n        marker = code;\n        return atBreak(code);\n    }\n    /** @type {State} */ function atBreak(code) {\n        if (code === marker) {\n            effects.enter(\"thematicBreakSequence\");\n            return sequence(code);\n        }\n        if ((0, $iUvtM.markdownSpace)(code)) return (0, $jH5RB.factorySpace)(effects, atBreak, \"whitespace\")(code);\n        if (size < 3 || code !== null && !(0, $iUvtM.markdownLineEnding)(code)) return nok(code);\n        effects.exit(\"thematicBreak\");\n        return ok(code);\n    }\n    /** @type {State} */ function sequence(code) {\n        if (code === marker) {\n            effects.consume(code);\n            size++;\n            return sequence;\n        }\n        effects.exit(\"thematicBreakSequence\");\n        return atBreak(code);\n    }\n}\n\n});\n\n\nparcelRequire.register(\"jEoWp\", function(module, exports) {\n\n$parcel$export(module.exports, \"setextUnderline\", () => $e4e5198b081c05d3$export$e104e2de391dfde9);\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */ \nvar $jH5RB = parcelRequire(\"jH5RB\");\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\nconst $e4e5198b081c05d3$export$e104e2de391dfde9 = {\n    name: \"setextUnderline\",\n    tokenize: $e4e5198b081c05d3$var$tokenizeSetextUnderline,\n    resolveTo: $e4e5198b081c05d3$var$resolveToSetextUnderline\n};\n/** @type {Resolver} */ function $e4e5198b081c05d3$var$resolveToSetextUnderline(events, context) {\n    let index = events.length;\n    /** @type {number|undefined} */ let content;\n    /** @type {number|undefined} */ let text;\n    /** @type {number|undefined} */ let definition // Find the opening of the content.\n    ;\n    // Itll always exist: we dont tokenize if it isnt there.\n    while(index--)if (events[index][0] === \"enter\") {\n        if (events[index][1].type === \"content\") {\n            content = index;\n            break;\n        }\n        if (events[index][1].type === \"paragraph\") text = index;\n    } else {\n        if (events[index][1].type === \"content\") // Remove the content end (if needed well add it later)\n        events.splice(index, 1);\n        if (!definition && events[index][1].type === \"definition\") definition = index;\n    }\n    const heading = {\n        type: \"setextHeading\",\n        start: Object.assign({}, events[text][1].start),\n        end: Object.assign({}, events[events.length - 1][1].end)\n    } // Change the paragraph to setext heading text.\n    ;\n    events[text][1].type = \"setextHeadingText\" // If we have definitions in the content, well keep on having content,\n    ;\n    // but we need move it.\n    if (definition) {\n        events.splice(text, 0, [\n            \"enter\",\n            heading,\n            context\n        ]);\n        events.splice(definition + 1, 0, [\n            \"exit\",\n            events[content][1],\n            context\n        ]);\n        events[content][1].end = Object.assign({}, events[definition][1].end);\n    } else events[content][1] = heading;\n     // Add the heading exit at the end.\n    events.push([\n        \"exit\",\n        heading,\n        context\n    ]);\n    return events;\n}\n/** @type {Tokenizer} */ function $e4e5198b081c05d3$var$tokenizeSetextUnderline(effects, ok, nok) {\n    const self = this;\n    let index = self.events.length;\n    /** @type {NonNullable<Code>} */ let marker;\n    /** @type {boolean} */ let paragraph // Find an opening.\n    ;\n    while(index--)// Skip enter/exit of line ending, line prefix, and content.\n    // We can now either have a definition or a paragraph.\n    if (self.events[index][1].type !== \"lineEnding\" && self.events[index][1].type !== \"linePrefix\" && self.events[index][1].type !== \"content\") {\n        paragraph = self.events[index][1].type === \"paragraph\";\n        break;\n    }\n    return start;\n    /** @type {State} */ function start(code) {\n        if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n            effects.enter(\"setextHeadingLine\");\n            effects.enter(\"setextHeadingLineSequence\");\n            marker = code;\n            return closingSequence(code);\n        }\n        return nok(code);\n    }\n    /** @type {State} */ function closingSequence(code) {\n        if (code === marker) {\n            effects.consume(code);\n            return closingSequence;\n        }\n        effects.exit(\"setextHeadingLineSequence\");\n        return (0, $jH5RB.factorySpace)(effects, closingSequenceEnd, \"lineSuffix\")(code);\n    }\n    /** @type {State} */ function closingSequenceEnd(code) {\n        if (code === null || (0, $iUvtM.markdownLineEnding)(code)) {\n            effects.exit(\"setextHeadingLine\");\n            return ok(code);\n        }\n        return nok(code);\n    }\n}\n\n});\n\n\n\nparcelRequire.register(\"lw7ce\", function(module, exports) {\n\n$parcel$export(module.exports, \"preprocess\", () => $faa22b241d1ff8fd$export$fc37fe19dfda43ee);\n/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Value} Value\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Code} Code\n */ /**\n * @callback Preprocessor\n * @param {Value} value\n * @param {Encoding} [encoding]\n * @param {boolean} [end=false]\n * @returns {Array<Chunk>}\n */ const $faa22b241d1ff8fd$var$search = /[\\0\\t\\n\\r]/g;\nfunction $faa22b241d1ff8fd$export$fc37fe19dfda43ee() {\n    let column = 1;\n    let buffer = \"\";\n    /** @type {boolean|undefined} */ let start = true;\n    /** @type {boolean|undefined} */ let atCarriageReturn;\n    return preprocessor;\n    /** @type {Preprocessor} */ function preprocessor(value, encoding, end) {\n        /** @type {Array<Chunk>} */ const chunks = [];\n        /** @type {RegExpMatchArray|null} */ let match;\n        /** @type {number} */ let next;\n        /** @type {number} */ let startPosition;\n        /** @type {number} */ let endPosition;\n        /** @type {Code} */ let code // @ts-expect-error `Buffer` does allow an encoding.\n        ;\n        value = buffer + value.toString(encoding);\n        startPosition = 0;\n        buffer = \"\";\n        if (start) {\n            if (value.charCodeAt(0) === 65279) startPosition++;\n            start = undefined;\n        }\n        while(startPosition < value.length){\n            $faa22b241d1ff8fd$var$search.lastIndex = startPosition;\n            match = $faa22b241d1ff8fd$var$search.exec(value);\n            endPosition = match && match.index !== undefined ? match.index : value.length;\n            code = value.charCodeAt(endPosition);\n            if (!match) {\n                buffer = value.slice(startPosition);\n                break;\n            }\n            if (code === 10 && startPosition === endPosition && atCarriageReturn) {\n                chunks.push(-3);\n                atCarriageReturn = undefined;\n            } else {\n                if (atCarriageReturn) {\n                    chunks.push(-5);\n                    atCarriageReturn = undefined;\n                }\n                if (startPosition < endPosition) {\n                    chunks.push(value.slice(startPosition, endPosition));\n                    column += endPosition - startPosition;\n                }\n                switch(code){\n                    case 0:\n                        chunks.push(65533);\n                        column++;\n                        break;\n                    case 9:\n                        next = Math.ceil(column / 4) * 4;\n                        chunks.push(-2);\n                        while(column++ < next)chunks.push(-1);\n                        break;\n                    case 10:\n                        chunks.push(-4);\n                        column = 1;\n                        break;\n                    default:\n                        atCarriageReturn = true;\n                        column = 1;\n                }\n            }\n            startPosition = endPosition + 1;\n        }\n        if (end) {\n            if (atCarriageReturn) chunks.push(-5);\n            if (buffer) chunks.push(buffer);\n            chunks.push(null);\n        }\n        return chunks;\n    }\n}\n\n});\n\nparcelRequire.register(\"3gGaD\", function(module, exports) {\n\n$parcel$export(module.exports, \"postprocess\", () => $261393ead1603790$export$bd0e6e1378a871d7);\n/**\n * @typedef {import('micromark-util-types').Event} Event\n */ \nvar $jsYfy = parcelRequire(\"jsYfy\");\nfunction $261393ead1603790$export$bd0e6e1378a871d7(events) {\n    while(!(0, $jsYfy.subtokenize)(events));\n    return events;\n}\n\n});\n\nparcelRequire.register(\"gZtaX\", function(module, exports) {\n\n$parcel$export(module.exports, \"decodeNumericCharacterReference\", () => $c5e8f98ad61a9793$export$15a69557afac2c20);\n/**\n * Turn the number (in string form as either hexa- or plain decimal) coming from\n * a numeric character reference into a character.\n *\n * @param {string} value\n *   Value to decode.\n * @param {number} base\n *   Numeric base.\n * @returns {string}\n */ function $c5e8f98ad61a9793$export$15a69557afac2c20(value, base) {\n    const code = Number.parseInt(value, base);\n    if (// C0 except for HT, LF, FF, CR, space\n    code < 9 || code === 11 || code > 13 && code < 32 || // Control character (DEL) of the basic block and C1 controls.\n    code > 126 && code < 160 || // Lone high surrogates and low surrogates.\n    code > 55295 && code < 57344 || // Noncharacters.\n    code > 64975 && code < 65008 || (code & 65535) === 65535 || (code & 65535) === 65534 || // Out of range\n    code > 1114111) return \"\";\n    return String.fromCharCode(code);\n}\n\n});\n\nparcelRequire.register(\"8OH7a\", function(module, exports) {\n\n$parcel$export(module.exports, \"decodeString\", () => $66b46fe490d28799$export$a0fb664af7d0cc44);\n\nvar $3HEPL = parcelRequire(\"3HEPL\");\n\nvar $gZtaX = parcelRequire(\"gZtaX\");\nconst $66b46fe490d28799$var$characterEscapeOrReference = /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi;\nfunction $66b46fe490d28799$export$a0fb664af7d0cc44(value) {\n    return value.replace($66b46fe490d28799$var$characterEscapeOrReference, $66b46fe490d28799$var$decode);\n}\n/**\n * @param {string} $0\n * @param {string} $1\n * @param {string} $2\n * @returns {string}\n */ function $66b46fe490d28799$var$decode($0, $1, $2) {\n    if ($1) // Escape.\n    return $1;\n     // Reference.\n    const head = $2.charCodeAt(0);\n    if (head === 35) {\n        const head = $2.charCodeAt(1);\n        const hex = head === 120 || head === 88;\n        return (0, $gZtaX.decodeNumericCharacterReference)($2.slice(hex ? 2 : 1), hex ? 16 : 10);\n    }\n    return (0, $3HEPL.decodeNamedCharacterReference)($2) || $0;\n}\n\n});\n\n\n\n\nparcelRequire.register(\"kJTlh\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $f192f06803e471a7$export$2e2bcd8739ae039);\n/**\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('mdast-util-to-hast').Options} Options\n * @typedef {import('unified').Processor<any, any, any, any>} Processor\n *\n * @typedef {import('mdast-util-to-hast')} DoNotTouchAsThisImportIncludesRawInTree\n */ \nvar $82jGJ = parcelRequire(\"82jGJ\");\n// Note: the `<MdastRoot, HastRoot>` overload doesnt seem to work :'(\n/**\n * Plugin that turns markdown into HTML to support rehype.\n *\n * *   If a destination processor is given, that processor runs with a new HTML\n *     (hast) tree (bridge-mode).\n *     As the given processor runs with a hast tree, and rehype plugins support\n *     hast, that means rehype plugins can be used with the given processor.\n *     The hast tree is discarded in the end.\n *     Its highly unlikely that you want to do this.\n * *   The common case is to not pass a destination processor, in which case the\n *     current processor continues running with a new HTML (hast) tree\n *     (mutate-mode).\n *     As the current processor continues with a hast tree, and rehype plugins\n *     support hast, that means rehype plugins can be used after\n *     `remark-rehype`.\n *     Its likely that this is what you want to do.\n *\n * @param destination\n *   Optional unified processor.\n * @param options\n *   Options passed to `mdast-util-to-hast`.\n */ const $f192f06803e471a7$var$remarkRehype = /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */ function(destination, options) {\n    return destination && \"run\" in destination ? $f192f06803e471a7$var$bridge(destination, options) : $f192f06803e471a7$var$mutate(destination || options);\n};\nvar $f192f06803e471a7$export$2e2bcd8739ae039 = $f192f06803e471a7$var$remarkRehype;\n/**\n * Bridge-mode.\n * Runs the destination with the new hast tree.\n *\n * @type {import('unified').Plugin<[Processor, Options?], MdastRoot>}\n */ function $f192f06803e471a7$var$bridge(destination, options) {\n    return (node, file, next)=>{\n        destination.run((0, $82jGJ.toHast)(node, options), file, (error)=>{\n            next(error);\n        });\n    };\n}\n/**\n * Mutate-mode.\n * Further plugins run on the hast tree.\n *\n * @type {import('unified').Plugin<[Options?]|void[], MdastRoot, HastRoot>}\n */ function $f192f06803e471a7$var$mutate(options) {\n    // @ts-expect-error: assume a corresponding node is returned by `toHast`.\n    return (node)=>(0, $82jGJ.toHast)(node, options);\n}\n\n});\nparcelRequire.register(\"82jGJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"toHast\", () => $5d9dc8503281e181$export$c0e4c5cf07538633);\n/**\n * @typedef {import('hast').Content} HastContent\n * @typedef {import('hast').Root} HastRoot\n *\n * @typedef {import('mdast').Content} MdastContent\n * @typedef {import('mdast').Root} MdastRoot\n *\n * @typedef {import('./state.js').Options} Options\n */ /**\n * @typedef {HastRoot | HastContent} HastNodes\n * @typedef {MdastRoot | MdastContent} MdastNodes\n */ \nvar $1j7pP = parcelRequire(\"1j7pP\");\n\nvar $56qaC = parcelRequire(\"56qaC\");\nfunction $5d9dc8503281e181$export$c0e4c5cf07538633(tree, options) {\n    const state = (0, $56qaC.createState)(tree, options);\n    const node = state.one(tree, null);\n    const foot = (0, $1j7pP.footer)(state);\n    if (foot) // @ts-expect-error If theres a footer, there were definitions, meaning block\n    // content.\n    // So assume `node` is a parent node.\n    node.children.push({\n        type: \"text\",\n        value: \"\\n\"\n    }, foot);\n    // To do: next major: always return root?\n    return Array.isArray(node) ? {\n        type: \"root\",\n        children: node\n    } : node;\n}\n\n});\nparcelRequire.register(\"1j7pP\", function(module, exports) {\n\n$parcel$export(module.exports, \"footer\", () => $0f3d515b9a22cf98$export$adb608be33961c98);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('./state.js').State} State\n */ \nvar $eznPp = parcelRequire(\"eznPp\");\nfunction $0f3d515b9a22cf98$export$adb608be33961c98(state) {\n    /** @type {Array<ElementContent>} */ const listItems = [];\n    let index = -1;\n    while(++index < state.footnoteOrder.length){\n        const def = state.footnoteById[state.footnoteOrder[index]];\n        if (!def) continue;\n        const content = state.all(def);\n        const id = String(def.identifier).toUpperCase();\n        const safeId = (0, $eznPp.normalizeUri)(id.toLowerCase());\n        let referenceIndex = 0;\n        /** @type {Array<ElementContent>} */ const backReferences = [];\n        while(++referenceIndex <= state.footnoteCounts[id]){\n            /** @type {Element} */ const backReference = {\n                type: \"element\",\n                tagName: \"a\",\n                properties: {\n                    href: \"#\" + state.clobberPrefix + \"fnref-\" + safeId + (referenceIndex > 1 ? \"-\" + referenceIndex : \"\"),\n                    dataFootnoteBackref: true,\n                    className: [\n                        \"data-footnote-backref\"\n                    ],\n                    ariaLabel: state.footnoteBackLabel\n                },\n                children: [\n                    {\n                        type: \"text\",\n                        value: \"\"\n                    }\n                ]\n            };\n            if (referenceIndex > 1) backReference.children.push({\n                type: \"element\",\n                tagName: \"sup\",\n                children: [\n                    {\n                        type: \"text\",\n                        value: String(referenceIndex)\n                    }\n                ]\n            });\n            if (backReferences.length > 0) backReferences.push({\n                type: \"text\",\n                value: \" \"\n            });\n            backReferences.push(backReference);\n        }\n        const tail = content[content.length - 1];\n        if (tail && tail.type === \"element\" && tail.tagName === \"p\") {\n            const tailTail = tail.children[tail.children.length - 1];\n            if (tailTail && tailTail.type === \"text\") tailTail.value += \" \";\n            else tail.children.push({\n                type: \"text\",\n                value: \" \"\n            });\n            tail.children.push(...backReferences);\n        } else content.push(...backReferences);\n        /** @type {Element} */ const listItem = {\n            type: \"element\",\n            tagName: \"li\",\n            properties: {\n                id: state.clobberPrefix + \"fn-\" + safeId\n            },\n            children: state.wrap(content, true)\n        };\n        state.patch(def, listItem);\n        listItems.push(listItem);\n    }\n    if (listItems.length === 0) return;\n    return {\n        type: \"element\",\n        tagName: \"section\",\n        properties: {\n            dataFootnotes: true,\n            className: [\n                \"footnotes\"\n            ]\n        },\n        children: [\n            {\n                type: \"element\",\n                tagName: state.footnoteLabelTagName,\n                properties: {\n                    // To do: use structured clone.\n                    ...JSON.parse(JSON.stringify(state.footnoteLabelProperties)),\n                    id: \"footnote-label\"\n                },\n                children: [\n                    {\n                        type: \"text\",\n                        value: state.footnoteLabel\n                    }\n                ]\n            },\n            {\n                type: \"text\",\n                value: \"\\n\"\n            },\n            {\n                type: \"element\",\n                tagName: \"ol\",\n                properties: {},\n                children: state.wrap(listItems, true)\n            },\n            {\n                type: \"text\",\n                value: \"\\n\"\n            }\n        ]\n    };\n}\n\n});\nparcelRequire.register(\"eznPp\", function(module, exports) {\n\n$parcel$export(module.exports, \"normalizeUri\", () => $a9b6d15784ed8a88$export$e42a3e39590d28b5);\n\nvar $iUvtM = parcelRequire(\"iUvtM\");\n\nvar $f9Avt = parcelRequire(\"f9Avt\");\nfunction $a9b6d15784ed8a88$export$d130a2d684099e5a(url, protocol) {\n    const value = (0, $f9Avt.encode)($a9b6d15784ed8a88$export$e42a3e39590d28b5(url || \"\"));\n    if (!protocol) return value;\n    const colon = value.indexOf(\":\");\n    const questionMark = value.indexOf(\"?\");\n    const numberSign = value.indexOf(\"#\");\n    const slash = value.indexOf(\"/\");\n    if (// If there is no protocol, its relative.\n    colon < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.\n    slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign || // It is a protocol, it should be allowed.\n    protocol.test(value.slice(0, colon))) return value;\n    return \"\";\n}\nfunction $a9b6d15784ed8a88$export$e42a3e39590d28b5(value) {\n    /** @type {Array<string>} */ const result = [];\n    let index = -1;\n    let start = 0;\n    let skip = 0;\n    while(++index < value.length){\n        const code = value.charCodeAt(index);\n        /** @type {string} */ let replace = \"\" // A correct percent encoded value.\n        ;\n        if (code === 37 && (0, $iUvtM.asciiAlphanumeric)(value.charCodeAt(index + 1)) && (0, $iUvtM.asciiAlphanumeric)(value.charCodeAt(index + 2))) skip = 2;\n        else if (code < 128) {\n            if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) replace = String.fromCharCode(code);\n        } else if (code > 55295 && code < 57344) {\n            const next = value.charCodeAt(index + 1) // A correct surrogate pair.\n            ;\n            if (code < 56320 && next > 56319 && next < 57344) {\n                replace = String.fromCharCode(code, next);\n                skip = 1;\n            } else replace = \"\";\n        } else replace = String.fromCharCode(code);\n        if (replace) {\n            result.push(value.slice(start, index), encodeURIComponent(replace));\n            start = index + skip + 1;\n            replace = \"\";\n        }\n        if (skip) {\n            index += skip;\n            skip = 0;\n        }\n    }\n    return result.join(\"\") + value.slice(start);\n}\n\n});\nparcelRequire.register(\"f9Avt\", function(module, exports) {\n\n$parcel$export(module.exports, \"encode\", () => $b08403b79a57c87d$export$c564cdbbe6da493);\nconst $b08403b79a57c87d$var$characterReferences = {\n    '\"': \"quot\",\n    \"&\": \"amp\",\n    \"<\": \"lt\",\n    \">\": \"gt\"\n};\nfunction $b08403b79a57c87d$export$c564cdbbe6da493(value) {\n    return value.replace(/[\"&<>]/g, replace);\n    /**\n   * @param {string} value\n   * @returns {string}\n   */ function replace(value) {\n        // @ts-expect-error Hush, its fine.\n        return \"&\" + $b08403b79a57c87d$var$characterReferences[value] + \";\";\n    }\n}\n\n});\n\n\n\nparcelRequire.register(\"56qaC\", function(module, exports) {\n\n$parcel$export(module.exports, \"createState\", () => $3b71d02d19a2f9fc$export$e6a0daad8304de);\n/**\n * @typedef {import('hast').Content} HastContent\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Content} MdastContent\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Parent} MdastParent\n * @typedef {import('mdast').Root} MdastRoot\n */ /**\n * @typedef {HastRoot | HastContent} HastNodes\n * @typedef {MdastRoot | MdastContent} MdastNodes\n * @typedef {Extract<MdastNodes, MdastParent>} MdastParents\n *\n * @typedef EmbeddedHastFields\n *   hast fields.\n * @property {string | null | undefined} [hName]\n *   Generate a specific element with this tag name instead.\n * @property {HastProperties | null | undefined} [hProperties]\n *   Generate an element with these properties instead.\n * @property {Array<HastElementContent> | null | undefined} [hChildren]\n *   Generate an element with this content instead.\n *\n * @typedef {Record<string, unknown> & EmbeddedHastFields} MdastData\n *   mdast data with embedded hast fields.\n *\n * @typedef {MdastNodes & {data?: MdastData | null | undefined}} MdastNodeWithData\n *   mdast node with embedded hast data.\n *\n * @typedef PointLike\n *   Point-like value.\n * @property {number | null | undefined} [line]\n *   Line.\n * @property {number | null | undefined} [column]\n *   Column.\n * @property {number | null | undefined} [offset]\n *   Offset.\n *\n * @typedef PositionLike\n *   Position-like value.\n * @property {PointLike | null | undefined} [start]\n *   Point-like value.\n * @property {PointLike | null | undefined} [end]\n *   Point-like value.\n *\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | null | undefined} parent\n *   Parent of `node`.\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n *   hast node.\n *\n * @callback HFunctionProps\n *   Signature of `state` for when props are passed.\n * @param {MdastNodes | PositionLike | null | undefined} node\n *   mdast node or unist position.\n * @param {string} tagName\n *   HTML tag name.\n * @param {HastProperties} props\n *   Properties.\n * @param {Array<HastElementContent> | null | undefined} [children]\n *   hast content.\n * @returns {HastElement}\n *   Compiled element.\n *\n * @callback HFunctionNoProps\n *   Signature of `state` for when no props are passed.\n * @param {MdastNodes | PositionLike | null | undefined} node\n *   mdast node or unist position.\n * @param {string} tagName\n *   HTML tag name.\n * @param {Array<HastElementContent> | null | undefined} [children]\n *   hast content.\n * @returns {HastElement}\n *   Compiled element.\n *\n * @typedef HFields\n *   Info on `state`.\n * @property {boolean} dangerous\n *   Whether HTML is allowed.\n * @property {string} clobberPrefix\n *   Prefix to use to prevent DOM clobbering.\n * @property {string} footnoteLabel\n *   Label to use to introduce the footnote section.\n * @property {string} footnoteLabelTagName\n *   HTML used for the footnote label.\n * @property {HastProperties} footnoteLabelProperties\n *   Properties on the HTML tag used for the footnote label.\n * @property {string} footnoteBackLabel\n *   Label to use from backreferences back to their footnote call.\n * @property {(identifier: string) => MdastDefinition | null} definition\n *   Definition cache.\n * @property {Record<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Record<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {Handler} unknownHandler\n *   Handler for any none not in `passThrough` or otherwise handled.\n * @property {(from: MdastNodes, node: HastNodes) => void} patch\n *   Copy a nodes positional info.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => Type | HastElement} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {(node: MdastNodes, parent: MdastParents | null | undefined) => HastElementContent | Array<HastElementContent> | null | undefined} one\n *   Transform an mdast node to hast.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastContent>(nodes: Array<Type>, loose?: boolean | null | undefined) => Array<Type | HastText>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n * @property {(left: MdastNodeWithData | PositionLike | null | undefined, right: HastElementContent) => HastElementContent} augment\n *   Like `state` but lower-level and usable on non-elements.\n *   Deprecated: use `patch` and `applyData`.\n * @property {Array<string>} passThrough\n *   List of node types to pass through untouched (except for their children).\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree.\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` attribute on footnotes to prevent it from\n *   *clobbering*.\n * @property {string | null | undefined} [footnoteBackLabel='Back to content']\n *   Label to use from backreferences back to their footnote call (affects\n *   screen readers).\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Label to use for the footnotes section (affects screen readers).\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (note that `id: 'footnote-label'`\n *   is always added as footnote calls use it with `aria-describedby` to\n *   provide an accessible label).\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   Tag name to use for the footnote label.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes.\n * @property {Array<string> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes.\n *\n * @typedef {Record<string, Handler>} Handlers\n *   Handle nodes.\n *\n * @typedef {HFunctionProps & HFunctionNoProps & HFields} State\n *   Info passed around.\n */ \nvar $ei8wA = parcelRequire(\"ei8wA\");\n\nvar $40w8i = parcelRequire(\"40w8i\");\n\nvar $8bjnJ = parcelRequire(\"8bjnJ\");\n\nvar $kCihy = parcelRequire(\"kCihy\");\n\nvar $1u0y6 = parcelRequire(\"1u0y6\");\nconst $3b71d02d19a2f9fc$var$own = {}.hasOwnProperty;\nfunction $3b71d02d19a2f9fc$export$e6a0daad8304de(tree, options) {\n    const settings = options || {};\n    const dangerous = settings.allowDangerousHtml || false;\n    /** @type {Record<string, MdastFootnoteDefinition>} */ const footnoteById = {};\n    // To do: next major: add `options` to state, remove:\n    // `dangerous`, `clobberPrefix`, `footnoteLabel`, `footnoteLabelTagName`,\n    // `footnoteLabelProperties`, `footnoteBackLabel`, `passThrough`,\n    // `unknownHandler`.\n    // To do: next major: move to `state.options.allowDangerousHtml`.\n    state.dangerous = dangerous;\n    // To do: next major: move to `state.options`.\n    state.clobberPrefix = settings.clobberPrefix === undefined || settings.clobberPrefix === null ? \"user-content-\" : settings.clobberPrefix;\n    // To do: next major: move to `state.options`.\n    state.footnoteLabel = settings.footnoteLabel || \"Footnotes\";\n    // To do: next major: move to `state.options`.\n    state.footnoteLabelTagName = settings.footnoteLabelTagName || \"h2\";\n    // To do: next major: move to `state.options`.\n    state.footnoteLabelProperties = settings.footnoteLabelProperties || {\n        className: [\n            \"sr-only\"\n        ]\n    };\n    // To do: next major: move to `state.options`.\n    state.footnoteBackLabel = settings.footnoteBackLabel || \"Back to content\";\n    // To do: next major: move to `state.options`.\n    state.unknownHandler = settings.unknownHandler;\n    // To do: next major: move to `state.options`.\n    state.passThrough = settings.passThrough;\n    state.handlers = {\n        ...(0, $1u0y6.handlers),\n        ...settings.handlers\n    };\n    // To do: next major: replace utility with `definitionById` object, so we\n    // only walk once (as we need footnotes too).\n    state.definition = (0, $kCihy.definitions)(tree);\n    state.footnoteById = footnoteById;\n    /** @type {Array<string>} */ state.footnoteOrder = [];\n    /** @type {Record<string, number>} */ state.footnoteCounts = {};\n    state.patch = $3b71d02d19a2f9fc$var$patch;\n    state.applyData = $3b71d02d19a2f9fc$var$applyData;\n    state.one = oneBound;\n    state.all = allBound;\n    state.wrap = $3b71d02d19a2f9fc$export$4997ffc0176396a6;\n    // To do: next major: remove `augment`.\n    state.augment = augment;\n    (0, $ei8wA.visit)(tree, \"footnoteDefinition\", (definition)=>{\n        const id = String(definition.identifier).toUpperCase();\n        // Mimick CM behavior of link definitions.\n        // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8290999/index.js#L26>.\n        if (!$3b71d02d19a2f9fc$var$own.call(footnoteById, id)) footnoteById[id] = definition;\n    });\n    // @ts-expect-error Hush, its fine!\n    return state;\n    /**\n   * Finalise the created `right`, a hast node, from `left`, an mdast node.\n   *\n   * @param {MdastNodeWithData | PositionLike | null | undefined} left\n   * @param {HastElementContent} right\n   * @returns {HastElementContent}\n   */ /* c8 ignore start */ // To do: next major: remove.\n    function augment(left, right) {\n        // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n        if (left && \"data\" in left && left.data) {\n            /** @type {MdastData} */ const data = left.data;\n            if (data.hName) {\n                if (right.type !== \"element\") right = {\n                    type: \"element\",\n                    tagName: \"\",\n                    properties: {},\n                    children: []\n                };\n                right.tagName = data.hName;\n            }\n            if (right.type === \"element\" && data.hProperties) right.properties = {\n                ...right.properties,\n                ...data.hProperties\n            };\n            if (\"children\" in right && right.children && data.hChildren) right.children = data.hChildren;\n        }\n        if (left) {\n            const ctx = \"type\" in left ? left : {\n                position: left\n            };\n            if (!(0, $8bjnJ.generated)(ctx)) // @ts-expect-error: fine.\n            right.position = {\n                start: (0, $40w8i.pointStart)(ctx),\n                end: (0, $40w8i.pointEnd)(ctx)\n            };\n        }\n        return right;\n    }\n    /* c8 ignore stop */ /**\n   * Create an element for `node`.\n   *\n   * @type {HFunctionProps}\n   */ /* c8 ignore start */ // To do: next major: remove.\n    function state(node, tagName, props, children) {\n        if (Array.isArray(props)) {\n            children = props;\n            props = {};\n        }\n        // @ts-expect-error augmenting an element yields an element.\n        return augment(node, {\n            type: \"element\",\n            tagName: tagName,\n            properties: props || {},\n            children: children || []\n        });\n    }\n    /* c8 ignore stop */ /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | null | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n   *   Resulting hast node.\n   */ function oneBound(node, parent) {\n        // @ts-expect-error: thats a state :)\n        return $3b71d02d19a2f9fc$export$80bf7733f1207381(state, node, parent);\n    }\n    /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */ function allBound(parent) {\n        // @ts-expect-error: thats a state :)\n        return $3b71d02d19a2f9fc$export$84bf76cd7afc7469(state, parent);\n    }\n}\n/**\n * Copy a nodes positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {void}\n *   Nothing.\n */ function $3b71d02d19a2f9fc$var$patch(from, to) {\n    if (from.position) to.position = (0, $40w8i.position)(from);\n}\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {Type | HastElement}\n *   Nothing.\n */ function $3b71d02d19a2f9fc$var$applyData(from, to) {\n    /** @type {Type | HastElement} */ let result = to;\n    // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n    if (from && from.data) {\n        const hName = from.data.hName;\n        const hChildren = from.data.hChildren;\n        const hProperties = from.data.hProperties;\n        if (typeof hName === \"string\") {\n            // Transforming the node resulted in an element with a different name\n            // than wanted:\n            if (result.type === \"element\") result.tagName = hName;\n            else result = {\n                type: \"element\",\n                tagName: hName,\n                properties: {},\n                children: []\n            };\n        }\n        if (result.type === \"element\" && hProperties) result.properties = {\n            ...result.properties,\n            ...hProperties\n        };\n        if (\"children\" in result && result.children && hChildren !== null && hChildren !== undefined) // @ts-expect-error: assume valid children are defined.\n        result.children = hChildren;\n    }\n    return result;\n}\nfunction $3b71d02d19a2f9fc$export$80bf7733f1207381(state, node, parent) {\n    const type = node && node.type;\n    // Fail on non-nodes.\n    if (!type) throw new Error(\"Expected node, got `\" + node + \"`\");\n    if ($3b71d02d19a2f9fc$var$own.call(state.handlers, type)) return state.handlers[type](state, node, parent);\n    if (state.passThrough && state.passThrough.includes(type)) // To do: next major: deep clone.\n    // @ts-expect-error: types of passed through nodes are expected to be added manually.\n    return \"children\" in node ? {\n        ...node,\n        children: $3b71d02d19a2f9fc$export$84bf76cd7afc7469(state, node)\n    } : node;\n    if (state.unknownHandler) return state.unknownHandler(state, node, parent);\n    return $3b71d02d19a2f9fc$var$defaultUnknownHandler(state, node);\n}\nfunction $3b71d02d19a2f9fc$export$84bf76cd7afc7469(state, parent) {\n    /** @type {Array<HastElementContent>} */ const values = [];\n    if (\"children\" in parent) {\n        const nodes = parent.children;\n        let index = -1;\n        while(++index < nodes.length){\n            const result = $3b71d02d19a2f9fc$export$80bf7733f1207381(state, nodes[index], parent);\n            // To do: see if we van clean this? Can we merge texts?\n            if (result) {\n                if (index && nodes[index - 1].type === \"break\") {\n                    if (!Array.isArray(result) && result.type === \"text\") result.value = result.value.replace(/^\\s+/, \"\");\n                    if (!Array.isArray(result) && result.type === \"element\") {\n                        const head = result.children[0];\n                        if (head && head.type === \"text\") head.value = head.value.replace(/^\\s+/, \"\");\n                    }\n                }\n                if (Array.isArray(result)) values.push(...result);\n                else values.push(result);\n            }\n        }\n    }\n    return values;\n}\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastText | HastElement}\n *   Resulting hast node.\n */ function $3b71d02d19a2f9fc$var$defaultUnknownHandler(state, node) {\n    const data = node.data || {};\n    /** @type {HastText | HastElement} */ const result = \"value\" in node && !($3b71d02d19a2f9fc$var$own.call(data, \"hProperties\") || $3b71d02d19a2f9fc$var$own.call(data, \"hChildren\")) ? {\n        type: \"text\",\n        value: node.value\n    } : {\n        type: \"element\",\n        tagName: \"div\",\n        properties: {},\n        children: $3b71d02d19a2f9fc$export$84bf76cd7afc7469(state, node)\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\nfunction $3b71d02d19a2f9fc$export$4997ffc0176396a6(nodes, loose) {\n    /** @type {Array<Type | HastText>} */ const result = [];\n    let index = -1;\n    if (loose) result.push({\n        type: \"text\",\n        value: \"\\n\"\n    });\n    while(++index < nodes.length){\n        if (index) result.push({\n            type: \"text\",\n            value: \"\\n\"\n        });\n        result.push(nodes[index]);\n    }\n    if (loose && nodes.length > 0) result.push({\n        type: \"text\",\n        value: \"\\n\"\n    });\n    return result;\n}\n\n});\nparcelRequire.register(\"ei8wA\", function(module, exports) {\n\n$parcel$export(module.exports, \"visit\", () => $a6795beeb14361e9$export$bf638b60ea8b89b7);\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */ /**\n * Check if `Child` can be a child of `Ancestor`.\n *\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\n * `never`.\n *\n * @template {Node} Ancestor\n *   Node type.\n * @template {Node} Child\n *   Node type.\n * @typedef {(\n *   Ancestor extends Parent\n *     ? Child extends Ancestor['children'][number]\n *       ? Ancestor\n *       : never\n *     : never\n * )} ParentsOf\n */ /**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends Node ? number | null : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */ /**\n * Build a typed `Visitor` function from a node and all possible parents.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Visited\n *   Node type.\n * @template {Parent} Ancestor\n *   Parent type.\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\n */ /**\n * Build a typed `Visitor` function from a list of descendants and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\n *     Extract<Descendant, Parent>\n *   >\n * )} BuildVisitorFromDescendants\n */ /**\n * Build a typed `Visitor` function from a tree and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} [Tree=Node]\n *   Node type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n */ \nvar $7xAT4 = parcelRequire(\"7xAT4\");\nconst $a6795beeb14361e9$export$bf638b60ea8b89b7 = /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */ /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */ function(tree, test, visitor, reverse) {\n    if (typeof test === \"function\" && typeof visitor !== \"function\") {\n        reverse = visitor;\n        visitor = test;\n        test = null;\n    }\n    (0, $7xAT4.visitParents)(tree, test, overload, reverse);\n    /**\n       * @param {Node} node\n       * @param {Array<Parent>} parents\n       */ function overload(node, parents) {\n        const parent = parents[parents.length - 1];\n        return visitor(node, parent ? parent.children.indexOf(node) : null, parent);\n    }\n};\n\n});\nparcelRequire.register(\"7xAT4\", function(module, exports) {\n\n$parcel$export(module.exports, \"visitParents\", () => $57d83a7e99fe1db8$export$70008a21eb6de899);\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */ /**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */ /**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */ /**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */ \nvar $cXrlj = parcelRequire(\"cXrlj\");\n\nvar $dwwhP = parcelRequire(\"dwwhP\");\nconst $57d83a7e99fe1db8$export$f4d8133c446fe484 = true;\nconst $57d83a7e99fe1db8$export$7f100f842f565dc9 = false;\nconst $57d83a7e99fe1db8$export$8773f85c2fb2c116 = \"skip\";\nconst $57d83a7e99fe1db8$export$70008a21eb6de899 = /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */ /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */ function(tree, test, visitor, reverse) {\n    if (typeof test === \"function\" && typeof visitor !== \"function\") {\n        reverse = visitor;\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test;\n        test = null;\n    }\n    const is = (0, $cXrlj.convert)(test);\n    const step = reverse ? -1 : 1;\n    factory(tree, undefined, [])();\n    /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */ function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */ // @ts-expect-error: hush\n        const value = node && typeof node === \"object\" ? node : {};\n        if (typeof value.type === \"string\") {\n            const name = // `hast`\n            typeof value.tagName === \"string\" ? value.tagName : typeof value.name === \"string\" ? value.name : undefined;\n            Object.defineProperty(visit, \"name\", {\n                value: \"node (\" + (0, $dwwhP.color)(node.type + (name ? \"<\" + name + \">\" : \"\")) + \")\"\n            });\n        }\n        return visit;\n        function visit() {\n            /** @type {ActionTuple} */ let result = [];\n            /** @type {ActionTuple} */ let subresult;\n            /** @type {number} */ let offset;\n            /** @type {Array<Parent>} */ let grandparents;\n            if (!test || is(node, index, parents[parents.length - 1] || null)) {\n                result = $57d83a7e99fe1db8$var$toResult(visitor(node, parents));\n                if (result[0] === $57d83a7e99fe1db8$export$7f100f842f565dc9) return result;\n            }\n            // @ts-expect-error looks like a parent.\n            if (node.children && result[0] !== $57d83a7e99fe1db8$export$8773f85c2fb2c116) {\n                // @ts-expect-error looks like a parent.\n                offset = (reverse ? node.children.length : -1) + step;\n                // @ts-expect-error looks like a parent.\n                grandparents = parents.concat(node);\n                // @ts-expect-error looks like a parent.\n                while(offset > -1 && offset < node.children.length){\n                    // @ts-expect-error looks like a parent.\n                    subresult = factory(node.children[offset], offset, grandparents)();\n                    if (subresult[0] === $57d83a7e99fe1db8$export$7f100f842f565dc9) return subresult;\n                    offset = typeof subresult[1] === \"number\" ? subresult[1] : offset + step;\n                }\n            }\n            return result;\n        }\n    }\n};\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */ function $57d83a7e99fe1db8$var$toResult(value) {\n    if (Array.isArray(value)) return value;\n    if (typeof value === \"number\") return [\n        $57d83a7e99fe1db8$export$f4d8133c446fe484,\n        value\n    ];\n    return [\n        value\n    ];\n}\n\n});\nparcelRequire.register(\"cXrlj\", function(module, exports) {\n\n$parcel$export(module.exports, \"convert\", () => $96f0346b9b041ae6$export$9c68d69a4c5bbcf9);\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */ /**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */ /**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */ /**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */ /**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */ /**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */ /**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The nodes position in its parent.\n * @param parent\n *   The nodes parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */ const $96f0346b9b041ae6$export$226b3eccf92c9ed9 = /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */ /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */ // eslint-disable-next-line max-params\nfunction is(node, test, index, parent, context) {\n    const check = $96f0346b9b041ae6$export$9c68d69a4c5bbcf9(test);\n    if (index !== undefined && index !== null && (typeof index !== \"number\" || index < 0 || index === Number.POSITIVE_INFINITY)) throw new Error(\"Expected positive finite index\");\n    if (parent !== undefined && parent !== null && (!is(parent) || !parent.children)) throw new Error(\"Expected parent node\");\n    if ((parent === undefined || parent === null) !== (index === undefined || index === null)) throw new Error(\"Expected both parent and index\");\n    // @ts-expect-error Looks like a node.\n    return node && node.type && typeof node.type === \"string\" ? Boolean(check.call(context, node, index, parent)) : false;\n};\nconst $96f0346b9b041ae6$export$9c68d69a4c5bbcf9 = /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */ /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */ function(test) {\n    if (test === undefined || test === null) return $96f0346b9b041ae6$var$ok;\n    if (typeof test === \"string\") return $96f0346b9b041ae6$var$typeFactory(test);\n    if (typeof test === \"object\") return Array.isArray(test) ? $96f0346b9b041ae6$var$anyFactory(test) : $96f0346b9b041ae6$var$propsFactory(test);\n    if (typeof test === \"function\") return $96f0346b9b041ae6$var$castFactory(test);\n    throw new Error(\"Expected function, string, or object as test\");\n};\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */ function $96f0346b9b041ae6$var$anyFactory(tests) {\n    /** @type {Array<AssertAnything>} */ const checks = [];\n    let index = -1;\n    while(++index < tests.length)checks[index] = $96f0346b9b041ae6$export$9c68d69a4c5bbcf9(tests[index]);\n    return $96f0346b9b041ae6$var$castFactory(any);\n    /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */ function any(...parameters) {\n        let index = -1;\n        while(++index < checks.length){\n            if (checks[index].call(this, ...parameters)) return true;\n        }\n        return false;\n    }\n}\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */ function $96f0346b9b041ae6$var$propsFactory(check) {\n    return $96f0346b9b041ae6$var$castFactory(all);\n    /**\n   * @param {Node} node\n   * @returns {boolean}\n   */ function all(node) {\n        /** @type {string} */ let key;\n        for(key in check){\n            // @ts-expect-error: hush, it sure works as an index.\n            if (node[key] !== check[key]) return false;\n        }\n        return true;\n    }\n}\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */ function $96f0346b9b041ae6$var$typeFactory(check) {\n    return $96f0346b9b041ae6$var$castFactory(type);\n    /**\n   * @param {Node} node\n   */ function type(node) {\n        return node && node.type === check;\n    }\n}\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */ function $96f0346b9b041ae6$var$castFactory(check) {\n    return assertion;\n    /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */ function assertion(node, ...parameters) {\n        return Boolean(node && typeof node === \"object\" && \"type\" in node && // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters)));\n    }\n}\nfunction $96f0346b9b041ae6$var$ok() {\n    return true;\n}\n\n});\n\nparcelRequire.register(\"dwwhP\", function(module, exports) {\n\n$parcel$export(module.exports, \"color\", () => $9d874ef8a8ef080d$export$35e9368ef982300f);\n/**\n * @param {string} d\n * @returns {string}\n */ function $9d874ef8a8ef080d$export$35e9368ef982300f(d) {\n    return d;\n}\n\n});\n\n\n\nparcelRequire.register(\"40w8i\", function(module, exports) {\n\n$parcel$export(module.exports, \"pointStart\", () => $2eb0166faf454f4f$export$771bf3e4949bfbee);\n$parcel$export(module.exports, \"pointEnd\", () => $2eb0166faf454f4f$export$da309cdce9dc2a25);\n$parcel$export(module.exports, \"position\", () => $2eb0166faf454f4f$export$5880b8b5730aff45);\n/**\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n */ /**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */ /**\n * Get the starting point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */ const $2eb0166faf454f4f$export$771bf3e4949bfbee = $2eb0166faf454f4f$var$point(\"start\");\nconst $2eb0166faf454f4f$export$da309cdce9dc2a25 = $2eb0166faf454f4f$var$point(\"end\");\nfunction $2eb0166faf454f4f$export$5880b8b5730aff45(node) {\n    return {\n        start: $2eb0166faf454f4f$export$771bf3e4949bfbee(node),\n        end: $2eb0166faf454f4f$export$da309cdce9dc2a25(node)\n    };\n}\n/**\n * Get the positional info of `node`.\n *\n * @param {'start' | 'end'} type\n *   Side.\n * @returns\n *   Getter.\n */ function $2eb0166faf454f4f$var$point(type) {\n    return point;\n    /**\n   * Get the point info of `node` at a bound side.\n   *\n   * @param {NodeLike | Node | null | undefined} [node]\n   * @returns {Point}\n   */ function point(node) {\n        const point = node && node.position && node.position[type] || {};\n        // To do: next major: dont return points when invalid.\n        return {\n            // @ts-expect-error: in practice, null is allowed.\n            line: point.line || null,\n            // @ts-expect-error: in practice, null is allowed.\n            column: point.column || null,\n            // @ts-expect-error: in practice, null is allowed.\n            offset: point.offset > -1 ? point.offset : null\n        };\n    }\n}\n\n});\n\nparcelRequire.register(\"8bjnJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"generated\", () => $5f4e629f12acb78a$export$41ad1363166ec91a);\n/**\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef NodeLike\n * @property {PositionLike | null | undefined} [position]\n */ /**\n * Check if `node` is generated.\n *\n * @param {NodeLike | null | undefined} [node]\n *   Node to check.\n * @returns {boolean}\n *   Whether `node` is generated (does not have positional info).\n */ function $5f4e629f12acb78a$export$41ad1363166ec91a(node) {\n    return !node || !node.position || !node.position.start || !node.position.start.line || !node.position.start.column || !node.position.end || !node.position.end.line || !node.position.end.column;\n}\n\n});\n\nparcelRequire.register(\"kCihy\", function(module, exports) {\n\n$parcel$export(module.exports, \"definitions\", () => $f02589b0b57bcb5b$export$d79264f26953ec1);\n/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Definition} Definition\n */ /**\n * @typedef {Root | Content} Node\n *\n * @callback GetDefinition\n *   Get a definition by identifier.\n * @param {string | null | undefined} [identifier]\n *   Identifier of definition.\n * @returns {Definition | null}\n *   Definition corresponding to `identifier` or `null`.\n */ \nvar $ei8wA = parcelRequire(\"ei8wA\");\nconst $f02589b0b57bcb5b$var$own = {}.hasOwnProperty;\nfunction $f02589b0b57bcb5b$export$d79264f26953ec1(tree) {\n    /** @type {Record<string, Definition>} */ const cache = Object.create(null);\n    if (!tree || !tree.type) throw new Error(\"mdast-util-definitions expected node\");\n    (0, $ei8wA.visit)(tree, \"definition\", (definition)=>{\n        const id = $f02589b0b57bcb5b$var$clean(definition.identifier);\n        if (id && !$f02589b0b57bcb5b$var$own.call(cache, id)) cache[id] = definition;\n    });\n    return definition;\n    /** @type {GetDefinition} */ function definition(identifier) {\n        const id = $f02589b0b57bcb5b$var$clean(identifier);\n        // To do: next major: return `undefined` when not found.\n        return id && $f02589b0b57bcb5b$var$own.call(cache, id) ? cache[id] : null;\n    }\n}\n/**\n * @param {string | null | undefined} [value]\n * @returns {string}\n */ function $f02589b0b57bcb5b$var$clean(value) {\n    return String(value || \"\").toUpperCase();\n}\n\n});\n\nparcelRequire.register(\"1u0y6\", function(module, exports) {\n\n$parcel$export(module.exports, \"handlers\", () => $114904d24886f596$export$455ce229eb3d2472);\n\nvar $bBTWt = parcelRequire(\"bBTWt\");\n\nvar $gAkBB = parcelRequire(\"gAkBB\");\n\nvar $aQ0We = parcelRequire(\"aQ0We\");\n\nvar $1eNIu = parcelRequire(\"1eNIu\");\n\nvar $6Pou9 = parcelRequire(\"6Pou9\");\n\nvar $lzRR1 = parcelRequire(\"lzRR1\");\n\nvar $4R9bv = parcelRequire(\"4R9bv\");\n\nvar $g6bry = parcelRequire(\"g6bry\");\n\nvar $2ude9 = parcelRequire(\"2ude9\");\n\nvar $luOdh = parcelRequire(\"luOdh\");\n\nvar $3ONqI = parcelRequire(\"3ONqI\");\n\nvar $ginya = parcelRequire(\"ginya\");\n\nvar $jcqku = parcelRequire(\"jcqku\");\n\nvar $lTpT2 = parcelRequire(\"lTpT2\");\n\nvar $lhaRl = parcelRequire(\"lhaRl\");\n\nvar $aA78B = parcelRequire(\"aA78B\");\n\nvar $kaiJ7 = parcelRequire(\"kaiJ7\");\n\nvar $9TBfz = parcelRequire(\"9TBfz\");\n\nvar $d1czY = parcelRequire(\"d1czY\");\n\nvar $84G49 = parcelRequire(\"84G49\");\n\nvar $auLC5 = parcelRequire(\"auLC5\");\n\nvar $bEKLo = parcelRequire(\"bEKLo\");\n\nvar $ksz7P = parcelRequire(\"ksz7P\");\n\nvar $Sxzp6 = parcelRequire(\"Sxzp6\");\nconst $114904d24886f596$export$455ce229eb3d2472 = {\n    blockquote: $bBTWt.blockquote,\n    break: (0, $gAkBB.hardBreak),\n    code: $aQ0We.code,\n    delete: (0, $1eNIu.strikethrough),\n    emphasis: $6Pou9.emphasis,\n    footnoteReference: $lzRR1.footnoteReference,\n    footnote: $4R9bv.footnote,\n    heading: $g6bry.heading,\n    html: $2ude9.html,\n    imageReference: $luOdh.imageReference,\n    image: $3ONqI.image,\n    inlineCode: $ginya.inlineCode,\n    linkReference: $jcqku.linkReference,\n    link: $lTpT2.link,\n    listItem: $lhaRl.listItem,\n    list: $aA78B.list,\n    paragraph: $kaiJ7.paragraph,\n    root: $9TBfz.root,\n    strong: $d1czY.strong,\n    table: $84G49.table,\n    tableCell: $bEKLo.tableCell,\n    tableRow: $auLC5.tableRow,\n    text: $ksz7P.text,\n    thematicBreak: $Sxzp6.thematicBreak,\n    toml: $114904d24886f596$var$ignore,\n    yaml: $114904d24886f596$var$ignore,\n    definition: $114904d24886f596$var$ignore,\n    footnoteDefinition: $114904d24886f596$var$ignore\n};\n// Return nothing for nodes that are ignored.\nfunction $114904d24886f596$var$ignore() {\n    // To do: next major: return `undefined`.\n    return null;\n}\n\n});\nparcelRequire.register(\"bBTWt\", function(module, exports) {\n\n$parcel$export(module.exports, \"blockquote\", () => $873e8b602d67e1eb$export$67dc04e652a298ca);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../state.js').State} State\n */ /**\n * Turn an mdast `blockquote` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Blockquote} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */ function $873e8b602d67e1eb$export$67dc04e652a298ca(state, node) {\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"blockquote\",\n        properties: {},\n        children: state.wrap(state.all(node), true)\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\nparcelRequire.register(\"gAkBB\", function(module, exports) {\n\n$parcel$export(module.exports, \"hardBreak\", () => $c12ffdf45974319a$export$371da9dd35aba193);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../state.js').State} State\n */ /**\n * Turn an mdast `break` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Break} node\n *   mdast node.\n * @returns {Array<Element | Text>}\n *   hast element content.\n */ function $c12ffdf45974319a$export$371da9dd35aba193(state, node) {\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"br\",\n        properties: {},\n        children: []\n    };\n    state.patch(node, result);\n    return [\n        state.applyData(node, result),\n        {\n            type: \"text\",\n            value: \"\\n\"\n        }\n    ];\n}\n\n});\n\nparcelRequire.register(\"aQ0We\", function(module, exports) {\n\n$parcel$export(module.exports, \"code\", () => $7e3f7d005d5ee31c$export$6565f9f03506010b);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../state.js').State} State\n\n */ /**\n * Turn an mdast `code` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Code} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */ function $7e3f7d005d5ee31c$export$6565f9f03506010b(state, node) {\n    const value = node.value ? node.value + \"\\n\" : \"\";\n    // To do: next major, use `node.lang` w/o regex, the splittings been going\n    // on for years in remark now.\n    const lang = node.lang ? node.lang.match(/^[^ \\t]+(?=[ \\t]|$)/) : null;\n    /** @type {Properties} */ const properties = {};\n    if (lang) properties.className = [\n        \"language-\" + lang\n    ];\n    // Create `<code>`.\n    /** @type {Element} */ let result = {\n        type: \"element\",\n        tagName: \"code\",\n        properties: properties,\n        children: [\n            {\n                type: \"text\",\n                value: value\n            }\n        ]\n    };\n    if (node.meta) result.data = {\n        meta: node.meta\n    };\n    state.patch(node, result);\n    result = state.applyData(node, result);\n    // Create `<pre>`.\n    result = {\n        type: \"element\",\n        tagName: \"pre\",\n        properties: {},\n        children: [\n            result\n        ]\n    };\n    state.patch(node, result);\n    return result;\n}\n\n});\n\nparcelRequire.register(\"1eNIu\", function(module, exports) {\n\n$parcel$export(module.exports, \"strikethrough\", () => $0e6da9eea1159b5c$export$19426ff118fe8be);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Delete} Delete\n * @typedef {import('../state.js').State} State\n\n */ /**\n * Turn an mdast `delete` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Delete} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */ function $0e6da9eea1159b5c$export$19426ff118fe8be(state, node) {\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"del\",\n        properties: {},\n        children: state.all(node)\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\nparcelRequire.register(\"6Pou9\", function(module, exports) {\n\n$parcel$export(module.exports, \"emphasis\", () => $4f8a7fc2c9259b58$export$bef81ba411953b51);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../state.js').State} State\n */ /**\n * Turn an mdast `emphasis` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Emphasis} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */ function $4f8a7fc2c9259b58$export$bef81ba411953b51(state, node) {\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"em\",\n        properties: {},\n        children: state.all(node)\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\nparcelRequire.register(\"lzRR1\", function(module, exports) {\n\n$parcel$export(module.exports, \"footnoteReference\", () => $fb56a43294cb554f$export$7f87ee744075c1ba);\n/**\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('hast').Element} Element\n * @typedef {import('../state.js').State} State\n */ \nvar $eznPp = parcelRequire(\"eznPp\");\nfunction $fb56a43294cb554f$export$7f87ee744075c1ba(state, node) {\n    const id = String(node.identifier).toUpperCase();\n    const safeId = (0, $eznPp.normalizeUri)(id.toLowerCase());\n    const index = state.footnoteOrder.indexOf(id);\n    /** @type {number} */ let counter;\n    if (index === -1) {\n        state.footnoteOrder.push(id);\n        state.footnoteCounts[id] = 1;\n        counter = state.footnoteOrder.length;\n    } else {\n        state.footnoteCounts[id]++;\n        counter = index + 1;\n    }\n    const reuseCounter = state.footnoteCounts[id];\n    /** @type {Element} */ const link = {\n        type: \"element\",\n        tagName: \"a\",\n        properties: {\n            href: \"#\" + state.clobberPrefix + \"fn-\" + safeId,\n            id: state.clobberPrefix + \"fnref-\" + safeId + (reuseCounter > 1 ? \"-\" + reuseCounter : \"\"),\n            dataFootnoteRef: true,\n            ariaDescribedBy: [\n                \"footnote-label\"\n            ]\n        },\n        children: [\n            {\n                type: \"text\",\n                value: String(counter)\n            }\n        ]\n    };\n    state.patch(node, link);\n    /** @type {Element} */ const sup = {\n        type: \"element\",\n        tagName: \"sup\",\n        properties: {},\n        children: [\n            link\n        ]\n    };\n    state.patch(node, sup);\n    return state.applyData(node, sup);\n}\n\n});\n\nparcelRequire.register(\"4R9bv\", function(module, exports) {\n\n$parcel$export(module.exports, \"footnote\", () => $38933c847d32fb3a$export$3b6a720baa2c20ec);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Footnote} Footnote\n * @typedef {import('../state.js').State} State\n */ \nvar $lzRR1 = parcelRequire(\"lzRR1\");\nfunction $38933c847d32fb3a$export$3b6a720baa2c20ec(state, node) {\n    const footnoteById = state.footnoteById;\n    let no = 1;\n    while(no in footnoteById)no++;\n    const identifier = String(no);\n    footnoteById[identifier] = {\n        type: \"footnoteDefinition\",\n        identifier: identifier,\n        children: [\n            {\n                type: \"paragraph\",\n                children: node.children\n            }\n        ],\n        position: node.position\n    };\n    return (0, $lzRR1.footnoteReference)(state, {\n        type: \"footnoteReference\",\n        identifier: identifier,\n        position: node.position\n    });\n}\n\n});\n\nparcelRequire.register(\"g6bry\", function(module, exports) {\n\n$parcel$export(module.exports, \"heading\", () => $bb86154deb79b98e$export$46e4a324ac90507f);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../state.js').State} State\n */ /**\n * Turn an mdast `heading` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Heading} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */ function $bb86154deb79b98e$export$46e4a324ac90507f(state, node) {\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"h\" + node.depth,\n        properties: {},\n        children: state.all(node)\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\nparcelRequire.register(\"2ude9\", function(module, exports) {\n\n$parcel$export(module.exports, \"html\", () => $1cf8a4c88312066a$export$c0bb0b647f701bb5);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').HTML} Html\n * @typedef {import('../state.js').State} State\n * @typedef {import('../../index.js').Raw} Raw\n */ /**\n * Turn an mdast `html` node into hast (`raw` node in dangerous mode, otherwise\n * nothing).\n *\n * @param {State} state\n *   Info passed around.\n * @param {Html} node\n *   mdast node.\n * @returns {Raw | Element | null}\n *   hast node.\n */ function $1cf8a4c88312066a$export$c0bb0b647f701bb5(state, node) {\n    if (state.dangerous) {\n        /** @type {Raw} */ const result = {\n            type: \"raw\",\n            value: node.value\n        };\n        state.patch(node, result);\n        return state.applyData(node, result);\n    }\n    // To do: next major: return `undefined`.\n    return null;\n}\n\n});\n\nparcelRequire.register(\"luOdh\", function(module, exports) {\n\n$parcel$export(module.exports, \"imageReference\", () => $fa63599826cf80b6$export$f281796f6bc3b8db);\n/**\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../state.js').State} State\n */ \nvar $eznPp = parcelRequire(\"eznPp\");\n\nvar $3Hi5O = parcelRequire(\"3Hi5O\");\nfunction $fa63599826cf80b6$export$f281796f6bc3b8db(state, node) {\n    const def = state.definition(node.identifier);\n    if (!def) return (0, $3Hi5O.revert)(state, node);\n    /** @type {Properties} */ const properties = {\n        src: (0, $eznPp.normalizeUri)(def.url || \"\"),\n        alt: node.alt\n    };\n    if (def.title !== null && def.title !== undefined) properties.title = def.title;\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"img\",\n        properties: properties,\n        children: []\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\nparcelRequire.register(\"3Hi5O\", function(module, exports) {\n\n$parcel$export(module.exports, \"revert\", () => $2b136c1710f10951$export$3fdd26f3d9e7dc78);\n/**\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Reference} Reference\n * @typedef {import('mdast').Root} Root\n *\n * @typedef {import('./state.js').State} State\n */ /**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Reference>} References\n */ // To do: next major: always return array.\n/**\n * Return the content of a reference without definition as plain text.\n *\n * @param {State} state\n *   Info passed around.\n * @param {References} node\n *   Reference node (image, link).\n * @returns {ElementContent | Array<ElementContent>}\n *   hast content.\n */ function $2b136c1710f10951$export$3fdd26f3d9e7dc78(state, node) {\n    const subtype = node.referenceType;\n    let suffix = \"]\";\n    if (subtype === \"collapsed\") suffix += \"[]\";\n    else if (subtype === \"full\") suffix += \"[\" + (node.label || node.identifier) + \"]\";\n    if (node.type === \"imageReference\") return {\n        type: \"text\",\n        value: \"![\" + node.alt + suffix\n    };\n    const contents = state.all(node);\n    const head = contents[0];\n    if (head && head.type === \"text\") head.value = \"[\" + head.value;\n    else contents.unshift({\n        type: \"text\",\n        value: \"[\"\n    });\n    const tail = contents[contents.length - 1];\n    if (tail && tail.type === \"text\") tail.value += suffix;\n    else contents.push({\n        type: \"text\",\n        value: suffix\n    });\n    return contents;\n}\n\n});\n\n\nparcelRequire.register(\"3ONqI\", function(module, exports) {\n\n$parcel$export(module.exports, \"image\", () => $2c7c625ff27de5b7$export$5c452ff88e35e47d);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../state.js').State} State\n */ \nvar $eznPp = parcelRequire(\"eznPp\");\nfunction $2c7c625ff27de5b7$export$5c452ff88e35e47d(state, node) {\n    /** @type {Properties} */ const properties = {\n        src: (0, $eznPp.normalizeUri)(node.url)\n    };\n    if (node.alt !== null && node.alt !== undefined) properties.alt = node.alt;\n    if (node.title !== null && node.title !== undefined) properties.title = node.title;\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"img\",\n        properties: properties,\n        children: []\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\nparcelRequire.register(\"ginya\", function(module, exports) {\n\n$parcel$export(module.exports, \"inlineCode\", () => $bdd09856e8ba33ae$export$91b9bee19a0d8569);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../state.js').State} State\n */ /**\n * Turn an mdast `inlineCode` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {InlineCode} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */ function $bdd09856e8ba33ae$export$91b9bee19a0d8569(state, node) {\n    /** @type {Text} */ const text = {\n        type: \"text\",\n        value: node.value.replace(/\\r?\\n|\\r/g, \" \")\n    };\n    state.patch(node, text);\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"code\",\n        properties: {},\n        children: [\n            text\n        ]\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\nparcelRequire.register(\"jcqku\", function(module, exports) {\n\n$parcel$export(module.exports, \"linkReference\", () => $dfa38fce9f7f6b8c$export$e6c469b1b7b2bc6a);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../state.js').State} State\n */ \nvar $eznPp = parcelRequire(\"eznPp\");\n\nvar $3Hi5O = parcelRequire(\"3Hi5O\");\nfunction $dfa38fce9f7f6b8c$export$e6c469b1b7b2bc6a(state, node) {\n    const def = state.definition(node.identifier);\n    if (!def) return (0, $3Hi5O.revert)(state, node);\n    /** @type {Properties} */ const properties = {\n        href: (0, $eznPp.normalizeUri)(def.url || \"\")\n    };\n    if (def.title !== null && def.title !== undefined) properties.title = def.title;\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"a\",\n        properties: properties,\n        children: state.all(node)\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\nparcelRequire.register(\"lTpT2\", function(module, exports) {\n\n$parcel$export(module.exports, \"link\", () => $ff02d09ce4744195$export$9c30223ca0a664fb);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../state.js').State} State\n */ \nvar $eznPp = parcelRequire(\"eznPp\");\nfunction $ff02d09ce4744195$export$9c30223ca0a664fb(state, node) {\n    /** @type {Properties} */ const properties = {\n        href: (0, $eznPp.normalizeUri)(node.url)\n    };\n    if (node.title !== null && node.title !== undefined) properties.title = node.title;\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"a\",\n        properties: properties,\n        children: state.all(node)\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\nparcelRequire.register(\"lhaRl\", function(module, exports) {\n\n$parcel$export(module.exports, \"listItem\", () => $f7d39bf347298f3f$export$76c7e83ecc9cdf05);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../state.js').State} State\n */ /**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */ /**\n * Turn an mdast `listItem` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ListItem} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */ function $f7d39bf347298f3f$export$76c7e83ecc9cdf05(state, node, parent) {\n    const results = state.all(node);\n    const loose = parent ? $f7d39bf347298f3f$var$listLoose(parent) : $f7d39bf347298f3f$var$listItemLoose(node);\n    /** @type {Properties} */ const properties = {};\n    /** @type {Array<ElementContent>} */ const children = [];\n    if (typeof node.checked === \"boolean\") {\n        const head = results[0];\n        /** @type {Element} */ let paragraph;\n        if (head && head.type === \"element\" && head.tagName === \"p\") paragraph = head;\n        else {\n            paragraph = {\n                type: \"element\",\n                tagName: \"p\",\n                properties: {},\n                children: []\n            };\n            results.unshift(paragraph);\n        }\n        if (paragraph.children.length > 0) paragraph.children.unshift({\n            type: \"text\",\n            value: \" \"\n        });\n        paragraph.children.unshift({\n            type: \"element\",\n            tagName: \"input\",\n            properties: {\n                type: \"checkbox\",\n                checked: node.checked,\n                disabled: true\n            },\n            children: []\n        });\n        // According to github-markdown-css, this class hides bullet.\n        // See: <https://github.com/sindresorhus/github-markdown-css>.\n        properties.className = [\n            \"task-list-item\"\n        ];\n    }\n    let index = -1;\n    while(++index < results.length){\n        const child = results[index];\n        // Add eols before nodes, except if this is a loose, first paragraph.\n        if (loose || index !== 0 || child.type !== \"element\" || child.tagName !== \"p\") children.push({\n            type: \"text\",\n            value: \"\\n\"\n        });\n        if (child.type === \"element\" && child.tagName === \"p\" && !loose) children.push(...child.children);\n        else children.push(child);\n    }\n    const tail = results[results.length - 1];\n    // Add a final eol.\n    if (tail && (loose || tail.type !== \"element\" || tail.tagName !== \"p\")) children.push({\n        type: \"text\",\n        value: \"\\n\"\n    });\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"li\",\n        properties: properties,\n        children: children\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n/**\n * @param {Parents} node\n * @return {Boolean}\n */ function $f7d39bf347298f3f$var$listLoose(node) {\n    let loose = false;\n    if (node.type === \"list\") {\n        loose = node.spread || false;\n        const children = node.children;\n        let index = -1;\n        while(!loose && ++index < children.length)loose = $f7d39bf347298f3f$var$listItemLoose(children[index]);\n    }\n    return loose;\n}\n/**\n * @param {ListItem} node\n * @return {Boolean}\n */ function $f7d39bf347298f3f$var$listItemLoose(node) {\n    const spread = node.spread;\n    return spread === undefined || spread === null ? node.children.length > 1 : spread;\n}\n\n});\n\nparcelRequire.register(\"aA78B\", function(module, exports) {\n\n$parcel$export(module.exports, \"list\", () => $7b42cd949e6c60f9$export$8837f4fc672e936d);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').List} List\n * @typedef {import('../state.js').State} State\n */ /**\n * Turn an mdast `list` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {List} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */ function $7b42cd949e6c60f9$export$8837f4fc672e936d(state, node) {\n    /** @type {Properties} */ const properties = {};\n    const results = state.all(node);\n    let index = -1;\n    if (typeof node.start === \"number\" && node.start !== 1) properties.start = node.start;\n    // Like GitHub, add a class for custom styling.\n    while(++index < results.length){\n        const child = results[index];\n        if (child.type === \"element\" && child.tagName === \"li\" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes(\"task-list-item\")) {\n            properties.className = [\n                \"contains-task-list\"\n            ];\n            break;\n        }\n    }\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: node.ordered ? \"ol\" : \"ul\",\n        properties: properties,\n        children: state.wrap(results, true)\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\nparcelRequire.register(\"kaiJ7\", function(module, exports) {\n\n$parcel$export(module.exports, \"paragraph\", () => $eae3449019415a3a$export$9c206ddddb32a9b);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../state.js').State} State\n */ /**\n * Turn an mdast `paragraph` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Paragraph} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */ function $eae3449019415a3a$export$9c206ddddb32a9b(state, node) {\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"p\",\n        properties: {},\n        children: state.all(node)\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\nparcelRequire.register(\"9TBfz\", function(module, exports) {\n\n$parcel$export(module.exports, \"root\", () => $7346253959989240$export$e8e78c978b129247);\n/**\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('../state.js').State} State\n */ /**\n * Turn an mdast `root` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastRoot} node\n *   mdast node.\n * @returns {HastRoot | HastElement}\n *   hast node.\n */ function $7346253959989240$export$e8e78c978b129247(state, node) {\n    /** @type {HastRoot} */ const result = {\n        type: \"root\",\n        children: state.wrap(state.all(node))\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\nparcelRequire.register(\"d1czY\", function(module, exports) {\n\n$parcel$export(module.exports, \"strong\", () => $97a52058d14c61a8$export$59ae2c325a998f89);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../state.js').State} State\n */ /**\n * Turn an mdast `strong` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Strong} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */ function $97a52058d14c61a8$export$59ae2c325a998f89(state, node) {\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"strong\",\n        properties: {},\n        children: state.all(node)\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\nparcelRequire.register(\"84G49\", function(module, exports) {\n\n$parcel$export(module.exports, \"table\", () => $5e0f53d9d07017d8$export$9852986a3ec5f6a0);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Table} Table\n * @typedef {import('../state.js').State} State\n */ \nvar $40w8i = parcelRequire(\"40w8i\");\nfunction $5e0f53d9d07017d8$export$9852986a3ec5f6a0(state, node) {\n    const rows = state.all(node);\n    const firstRow = rows.shift();\n    /** @type {Array<Element>} */ const tableContent = [];\n    if (firstRow) {\n        /** @type {Element} */ const head = {\n            type: \"element\",\n            tagName: \"thead\",\n            properties: {},\n            children: state.wrap([\n                firstRow\n            ], true)\n        };\n        state.patch(node.children[0], head);\n        tableContent.push(head);\n    }\n    if (rows.length > 0) {\n        /** @type {Element} */ const body = {\n            type: \"element\",\n            tagName: \"tbody\",\n            properties: {},\n            children: state.wrap(rows, true)\n        };\n        const start = (0, $40w8i.pointStart)(node.children[1]);\n        const end = (0, $40w8i.pointEnd)(node.children[node.children.length - 1]);\n        if (start.line && end.line) body.position = {\n            start: start,\n            end: end\n        };\n        tableContent.push(body);\n    }\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"table\",\n        properties: {},\n        children: state.wrap(tableContent, true)\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\nparcelRequire.register(\"auLC5\", function(module, exports) {\n\n$parcel$export(module.exports, \"tableRow\", () => $7a41a3b926310dff$export$ce666bf02318c957);\n/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('../state.js').State} State\n */ /**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */ /**\n * Turn an mdast `tableRow` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableRow} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */ function $7a41a3b926310dff$export$ce666bf02318c957(state, node, parent) {\n    const siblings = parent ? parent.children : undefined;\n    // Generate a body row when without parent.\n    const rowIndex = siblings ? siblings.indexOf(node) : 1;\n    const tagName = rowIndex === 0 ? \"th\" : \"td\";\n    const align = parent && parent.type === \"table\" ? parent.align : undefined;\n    const length = align ? align.length : node.children.length;\n    let cellIndex = -1;\n    /** @type {Array<ElementContent>} */ const cells = [];\n    while(++cellIndex < length){\n        // Note: can also be undefined.\n        const cell = node.children[cellIndex];\n        /** @type {Properties} */ const properties = {};\n        const alignValue = align ? align[cellIndex] : undefined;\n        if (alignValue) properties.align = alignValue;\n        /** @type {Element} */ let result = {\n            type: \"element\",\n            tagName: tagName,\n            properties: properties,\n            children: []\n        };\n        if (cell) {\n            result.children = state.all(cell);\n            state.patch(cell, result);\n            result = state.applyData(node, result);\n        }\n        cells.push(result);\n    }\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"tr\",\n        properties: {},\n        children: state.wrap(cells, true)\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\nparcelRequire.register(\"bEKLo\", function(module, exports) {\n\n$parcel$export(module.exports, \"tableCell\", () => $87c7b463ad5582bc$export$e1e720e5f4603e6a);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('../state.js').State} State\n */ /**\n * Turn an mdast `tableCell` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableCell} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */ function $87c7b463ad5582bc$export$e1e720e5f4603e6a(state, node) {\n    // Note: this function is normally not called: see `table-row` for how rows\n    // and their cells are compiled.\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"td\",\n        properties: {},\n        children: state.all(node)\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\nparcelRequire.register(\"ksz7P\", function(module, exports) {\n\n$parcel$export(module.exports, \"text\", () => $ee51ab4e98d30870$export$6f093cfa640b7166);\n/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Text} HastText\n * @typedef {import('mdast').Text} MdastText\n * @typedef {import('../state.js').State} State\n */ \nvar $4AQW1 = parcelRequire(\"4AQW1\");\nfunction $ee51ab4e98d30870$export$6f093cfa640b7166(state, node) {\n    /** @type {HastText} */ const result = {\n        type: \"text\",\n        value: (0, $4AQW1.trimLines)(String(node.value))\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\nparcelRequire.register(\"4AQW1\", function(module, exports) {\n\n$parcel$export(module.exports, \"trimLines\", () => $358395fcbf5a2cfd$export$a771f20bdd13def9);\nconst $358395fcbf5a2cfd$var$tab = 9 /* `\\t` */ ;\nconst $358395fcbf5a2cfd$var$space = 32 /* ` ` */ ;\nfunction $358395fcbf5a2cfd$export$a771f20bdd13def9(value) {\n    const source = String(value);\n    const search = /\\r?\\n|\\r/g;\n    let match = search.exec(source);\n    let last = 0;\n    /** @type {Array<string>} */ const lines = [];\n    while(match){\n        lines.push($358395fcbf5a2cfd$var$trimLine(source.slice(last, match.index), last > 0, true), match[0]);\n        last = match.index + match[0].length;\n        match = search.exec(source);\n    }\n    lines.push($358395fcbf5a2cfd$var$trimLine(source.slice(last), last > 0, false));\n    return lines.join(\"\");\n}\n/**\n * @param {string} value\n *   Line to trim.\n * @param {boolean} start\n *   Whether to trim the start of the line.\n * @param {boolean} end\n *   Whether to trim the end of the line.\n * @returns {string}\n *   Trimmed line.\n */ function $358395fcbf5a2cfd$var$trimLine(value, start, end) {\n    let startIndex = 0;\n    let endIndex = value.length;\n    if (start) {\n        let code = value.codePointAt(startIndex);\n        while(code === $358395fcbf5a2cfd$var$tab || code === $358395fcbf5a2cfd$var$space){\n            startIndex++;\n            code = value.codePointAt(startIndex);\n        }\n    }\n    if (end) {\n        let code = value.codePointAt(endIndex - 1);\n        while(code === $358395fcbf5a2cfd$var$tab || code === $358395fcbf5a2cfd$var$space){\n            endIndex--;\n            code = value.codePointAt(endIndex - 1);\n        }\n    }\n    return endIndex > startIndex ? value.slice(startIndex, endIndex) : \"\";\n}\n\n});\n\n\nparcelRequire.register(\"Sxzp6\", function(module, exports) {\n\n$parcel$export(module.exports, \"thematicBreak\", () => $0a3f1591cf32526f$export$ba7b13e047416c03);\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../state.js').State} State\n */ /**\n * Turn an mdast `thematicBreak` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ThematicBreak} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */ function $0a3f1591cf32526f$export$ba7b13e047416c03(state, node) {\n    /** @type {Element} */ const result = {\n        type: \"element\",\n        tagName: \"hr\",\n        properties: {},\n        children: []\n    };\n    state.patch(node, result);\n    return state.applyData(node, result);\n}\n\n});\n\n\n\n\n\nparcelRequire.register(\"4RND8\", function(module, exports) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var $38b29c2dc0019b47$var$ReactIs, $38b29c2dc0019b47$var$throwOnDirectAccess;\n\n// By explicitly using `prop-types` you are opting into new production behavior.\n// http://fb.me/prop-types-in-prod\nmodule.exports = (parcelRequire(\"dflA0\"))();\n\n});\nparcelRequire.register(\"dflA0\", function(module, exports) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \"use strict\";\n\nvar $lNqgI = parcelRequire(\"lNqgI\");\nfunction $9a4d6a57aaaab11e$var$emptyFunction() {}\nfunction $9a4d6a57aaaab11e$var$emptyFunctionWithReset() {}\n$9a4d6a57aaaab11e$var$emptyFunctionWithReset.resetWarningCache = $9a4d6a57aaaab11e$var$emptyFunction;\nmodule.exports = function() {\n    function shim(props, propName, componentName, location, propFullName, secret) {\n        if (secret === $lNqgI) // It is still safe when called from React.\n        return;\n        var err = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types\");\n        err.name = \"Invariant Violation\";\n        throw err;\n    }\n    shim.isRequired = shim;\n    function getShim() {\n        return shim;\n    }\n    // Important!\n    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n    var ReactPropTypes = {\n        array: shim,\n        bigint: shim,\n        bool: shim,\n        func: shim,\n        number: shim,\n        object: shim,\n        string: shim,\n        symbol: shim,\n        any: shim,\n        arrayOf: getShim,\n        element: shim,\n        elementType: shim,\n        instanceOf: getShim,\n        node: shim,\n        objectOf: getShim,\n        oneOf: getShim,\n        oneOfType: getShim,\n        shape: getShim,\n        exact: getShim,\n        checkPropTypes: $9a4d6a57aaaab11e$var$emptyFunctionWithReset,\n        resetWarningCache: $9a4d6a57aaaab11e$var$emptyFunction\n    };\n    ReactPropTypes.PropTypes = ReactPropTypes;\n    return ReactPropTypes;\n};\n\n});\nparcelRequire.register(\"lNqgI\", function(module, exports) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \"use strict\";\nvar $fde28cfe61c36500$var$ReactPropTypesSecret = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\nmodule.exports = $fde28cfe61c36500$var$ReactPropTypesSecret;\n\n});\n\n\n\nparcelRequire.register(\"aY292\", function(module, exports) {\n\n$parcel$export(module.exports, \"html\", () => $7fc12be348255554$export$c0bb0b647f701bb5);\n$parcel$export(module.exports, \"svg\", () => $7fc12be348255554$export$7ed1367e7fa1ad68);\n/**\n * @typedef {import('./lib/util/info.js').Info} Info\n * @typedef {import('./lib/util/schema.js').Schema} Schema\n */ \nvar $8K29K = parcelRequire(\"8K29K\");\n\nvar $cXEVp = parcelRequire(\"cXEVp\");\n\nvar $2mSAN = parcelRequire(\"2mSAN\");\n\nvar $8TXBj = parcelRequire(\"8TXBj\");\n\nvar $7ejLl = parcelRequire(\"7ejLl\");\n\nvar $cwo9C = parcelRequire(\"cwo9C\");\n\nvar $lF5RX = parcelRequire(\"lF5RX\");\n\nvar $8e8kD = parcelRequire(\"8e8kD\");\n\nvar $j3JRp = parcelRequire(\"j3JRp\");\n\nconst $7fc12be348255554$export$c0bb0b647f701bb5 = (0, $8K29K.merge)([\n    (0, $2mSAN.xml),\n    (0, $cXEVp.xlink),\n    (0, $8TXBj.xmlns),\n    (0, $7ejLl.aria),\n    (0, $cwo9C.html)\n], \"html\");\nconst $7fc12be348255554$export$7ed1367e7fa1ad68 = (0, $8K29K.merge)([\n    (0, $2mSAN.xml),\n    (0, $cXEVp.xlink),\n    (0, $8TXBj.xmlns),\n    (0, $7ejLl.aria),\n    (0, $lF5RX.svg)\n], \"svg\");\n\n});\nparcelRequire.register(\"8K29K\", function(module, exports) {\n\n$parcel$export(module.exports, \"merge\", () => $65d44acdf87d3821$export$4950aa0f605343fb);\n/**\n * @typedef {import('./schema.js').Properties} Properties\n * @typedef {import('./schema.js').Normal} Normal\n */ \nvar $2V6iF = parcelRequire(\"2V6iF\");\nfunction $65d44acdf87d3821$export$4950aa0f605343fb(definitions, space) {\n    /** @type {Properties} */ const property = {};\n    /** @type {Normal} */ const normal = {};\n    let index = -1;\n    while(++index < definitions.length){\n        Object.assign(property, definitions[index].property);\n        Object.assign(normal, definitions[index].normal);\n    }\n    return new (0, $2V6iF.Schema)(property, normal, space);\n}\n\n});\nparcelRequire.register(\"2V6iF\", function(module, exports) {\n\n$parcel$export(module.exports, \"Schema\", () => $2205caaf944f60ef$export$19342e026b58ebb7);\n/**\n * @typedef {import('./info.js').Info} Info\n * @typedef {Record<string, Info>} Properties\n * @typedef {Record<string, string>} Normal\n */ class $2205caaf944f60ef$export$19342e026b58ebb7 {\n    /**\n   * @constructor\n   * @param {Properties} property\n   * @param {Normal} normal\n   * @param {string} [space]\n   */ constructor(property, normal, space){\n        this.property = property;\n        this.normal = normal;\n        if (space) this.space = space;\n    }\n}\n/** @type {Properties} */ $2205caaf944f60ef$export$19342e026b58ebb7.prototype.property = {};\n/** @type {Normal} */ $2205caaf944f60ef$export$19342e026b58ebb7.prototype.normal = {};\n/** @type {string|null} */ $2205caaf944f60ef$export$19342e026b58ebb7.prototype.space = null;\n\n});\n\n\nparcelRequire.register(\"cXEVp\", function(module, exports) {\n\n$parcel$export(module.exports, \"xlink\", () => $96fabd8cd2ed1feb$export$2bd1230ec7600845);\n\nvar $jbPNJ = parcelRequire(\"jbPNJ\");\nconst $96fabd8cd2ed1feb$export$2bd1230ec7600845 = (0, $jbPNJ.create)({\n    space: \"xlink\",\n    transform (_, prop) {\n        return \"xlink:\" + prop.slice(5).toLowerCase();\n    },\n    properties: {\n        xLinkActuate: null,\n        xLinkArcRole: null,\n        xLinkHref: null,\n        xLinkRole: null,\n        xLinkShow: null,\n        xLinkTitle: null,\n        xLinkType: null\n    }\n});\n\n});\nparcelRequire.register(\"jbPNJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"create\", () => $df873a045ab9997d$export$185802fd694ee1f5);\n/**\n * @typedef {import('./schema.js').Properties} Properties\n * @typedef {import('./schema.js').Normal} Normal\n *\n * @typedef {Record<string, string>} Attributes\n *\n * @typedef {Object} Definition\n * @property {Record<string, number|null>} properties\n * @property {(attributes: Attributes, property: string) => string} transform\n * @property {string} [space]\n * @property {Attributes} [attributes]\n * @property {Array<string>} [mustUseProperty]\n */ \nvar $4GEAW = parcelRequire(\"4GEAW\");\n\nvar $2V6iF = parcelRequire(\"2V6iF\");\n\nvar $lqZ1V = parcelRequire(\"lqZ1V\");\nconst $df873a045ab9997d$var$own = {}.hasOwnProperty;\nfunction $df873a045ab9997d$export$185802fd694ee1f5(definition) {\n    /** @type {Properties} */ const property = {};\n    /** @type {Normal} */ const normal = {};\n    /** @type {string} */ let prop;\n    for(prop in definition.properties)if ($df873a045ab9997d$var$own.call(definition.properties, prop)) {\n        const value = definition.properties[prop];\n        const info = new (0, $lqZ1V.DefinedInfo)(prop, definition.transform(definition.attributes || {}, prop), value, definition.space);\n        if (definition.mustUseProperty && definition.mustUseProperty.includes(prop)) info.mustUseProperty = true;\n        property[prop] = info;\n        normal[(0, $4GEAW.normalize)(prop)] = prop;\n        normal[(0, $4GEAW.normalize)(info.attribute)] = prop;\n    }\n    return new (0, $2V6iF.Schema)(property, normal, definition.space);\n}\n\n});\nparcelRequire.register(\"4GEAW\", function(module, exports) {\n\n$parcel$export(module.exports, \"normalize\", () => $369a92eee5cf5c65$export$a3295358bff77e);\n/**\n * @param {string} value\n * @returns {string}\n */ function $369a92eee5cf5c65$export$a3295358bff77e(value) {\n    return value.toLowerCase();\n}\n\n});\n\nparcelRequire.register(\"lqZ1V\", function(module, exports) {\n\n$parcel$export(module.exports, \"DefinedInfo\", () => $f9ab5dffd32c2b27$export$ea6b9f0064e88c9b);\n\nvar $imkUs = parcelRequire(\"imkUs\");\n\nvar $bhH9I = parcelRequire(\"bhH9I\");\n/** @type {Array<keyof types>} */ // @ts-expect-error: hush.\nconst $f9ab5dffd32c2b27$var$checks = Object.keys($bhH9I);\nclass $f9ab5dffd32c2b27$export$ea6b9f0064e88c9b extends (0, $imkUs.Info) {\n    /**\n   * @constructor\n   * @param {string} property\n   * @param {string} attribute\n   * @param {number|null} [mask]\n   * @param {string} [space]\n   */ constructor(property, attribute, mask, space){\n        let index = -1;\n        super(property, attribute);\n        $f9ab5dffd32c2b27$var$mark(this, \"space\", space);\n        if (typeof mask === \"number\") while(++index < $f9ab5dffd32c2b27$var$checks.length){\n            const check = $f9ab5dffd32c2b27$var$checks[index];\n            $f9ab5dffd32c2b27$var$mark(this, $f9ab5dffd32c2b27$var$checks[index], (mask & $bhH9I[check]) === $bhH9I[check]);\n        }\n    }\n}\n$f9ab5dffd32c2b27$export$ea6b9f0064e88c9b.prototype.defined = true;\n/**\n * @param {DefinedInfo} values\n * @param {string} key\n * @param {unknown} value\n */ function $f9ab5dffd32c2b27$var$mark(values, key, value) {\n    if (value) // @ts-expect-error: assume `value` matches the expected value of `key`.\n    values[key] = value;\n}\n\n});\nparcelRequire.register(\"imkUs\", function(module, exports) {\n\n$parcel$export(module.exports, \"Info\", () => $d5da804e63e4f031$export$c4868e4a24d48fad);\nclass $d5da804e63e4f031$export$c4868e4a24d48fad {\n    /**\n   * @constructor\n   * @param {string} property\n   * @param {string} attribute\n   */ constructor(property, attribute){\n        /** @type {string} */ this.property = property;\n        /** @type {string} */ this.attribute = attribute;\n    }\n}\n/** @type {string|null} */ $d5da804e63e4f031$export$c4868e4a24d48fad.prototype.space = null;\n$d5da804e63e4f031$export$c4868e4a24d48fad.prototype.boolean = false;\n$d5da804e63e4f031$export$c4868e4a24d48fad.prototype.booleanish = false;\n$d5da804e63e4f031$export$c4868e4a24d48fad.prototype.overloadedBoolean = false;\n$d5da804e63e4f031$export$c4868e4a24d48fad.prototype.number = false;\n$d5da804e63e4f031$export$c4868e4a24d48fad.prototype.commaSeparated = false;\n$d5da804e63e4f031$export$c4868e4a24d48fad.prototype.spaceSeparated = false;\n$d5da804e63e4f031$export$c4868e4a24d48fad.prototype.commaOrSpaceSeparated = false;\n$d5da804e63e4f031$export$c4868e4a24d48fad.prototype.mustUseProperty = false;\n$d5da804e63e4f031$export$c4868e4a24d48fad.prototype.defined = false;\n\n});\n\nparcelRequire.register(\"bhH9I\", function(module, exports) {\n\n$parcel$export(module.exports, \"boolean\", () => $8372c20d7637626a$export$4a21f16c33752377);\n$parcel$export(module.exports, \"booleanish\", () => $8372c20d7637626a$export$55e9e1fbc638dc8f);\n$parcel$export(module.exports, \"overloadedBoolean\", () => $8372c20d7637626a$export$242ac3d3042558aa);\n$parcel$export(module.exports, \"number\", () => $8372c20d7637626a$export$98e628dec113755e);\n$parcel$export(module.exports, \"spaceSeparated\", () => $8372c20d7637626a$export$ab8645c862eb5a3e);\n$parcel$export(module.exports, \"commaSeparated\", () => $8372c20d7637626a$export$9c8d678629b3d3);\n$parcel$export(module.exports, \"commaOrSpaceSeparated\", () => $8372c20d7637626a$export$2ad25cfebf36cacd);\nlet $8372c20d7637626a$var$powers = 0;\nconst $8372c20d7637626a$export$4a21f16c33752377 = $8372c20d7637626a$var$increment();\nconst $8372c20d7637626a$export$55e9e1fbc638dc8f = $8372c20d7637626a$var$increment();\nconst $8372c20d7637626a$export$242ac3d3042558aa = $8372c20d7637626a$var$increment();\nconst $8372c20d7637626a$export$98e628dec113755e = $8372c20d7637626a$var$increment();\nconst $8372c20d7637626a$export$ab8645c862eb5a3e = $8372c20d7637626a$var$increment();\nconst $8372c20d7637626a$export$9c8d678629b3d3 = $8372c20d7637626a$var$increment();\nconst $8372c20d7637626a$export$2ad25cfebf36cacd = $8372c20d7637626a$var$increment();\nfunction $8372c20d7637626a$var$increment() {\n    return 2 ** ++$8372c20d7637626a$var$powers;\n}\n\n});\n\n\n\n\nparcelRequire.register(\"2mSAN\", function(module, exports) {\n\n$parcel$export(module.exports, \"xml\", () => $1b97fbcaee557873$export$f2913fe8983302e);\n\nvar $jbPNJ = parcelRequire(\"jbPNJ\");\nconst $1b97fbcaee557873$export$f2913fe8983302e = (0, $jbPNJ.create)({\n    space: \"xml\",\n    transform (_, prop) {\n        return \"xml:\" + prop.slice(3).toLowerCase();\n    },\n    properties: {\n        xmlLang: null,\n        xmlBase: null,\n        xmlSpace: null\n    }\n});\n\n});\n\nparcelRequire.register(\"8TXBj\", function(module, exports) {\n\n$parcel$export(module.exports, \"xmlns\", () => $67b1b149c061c281$export$e20c24a128671213);\n\nvar $jbPNJ = parcelRequire(\"jbPNJ\");\n\nvar $4PxUO = parcelRequire(\"4PxUO\");\nconst $67b1b149c061c281$export$e20c24a128671213 = (0, $jbPNJ.create)({\n    space: \"xmlns\",\n    attributes: {\n        xmlnsxlink: \"xmlns:xlink\"\n    },\n    transform: (0, $4PxUO.caseInsensitiveTransform),\n    properties: {\n        xmlns: null,\n        xmlnsXLink: null\n    }\n});\n\n});\nparcelRequire.register(\"4PxUO\", function(module, exports) {\n\n$parcel$export(module.exports, \"caseInsensitiveTransform\", () => $38463bbd80687601$export$32b9e4cec9c208e1);\n\nvar $5rtXf = parcelRequire(\"5rtXf\");\nfunction $38463bbd80687601$export$32b9e4cec9c208e1(attributes, property) {\n    return (0, $5rtXf.caseSensitiveTransform)(attributes, property.toLowerCase());\n}\n\n});\nparcelRequire.register(\"5rtXf\", function(module, exports) {\n\n$parcel$export(module.exports, \"caseSensitiveTransform\", () => $3f66b5b5be89dedb$export$5b10b3bc32d7efbc);\n/**\n * @param {Record<string, string>} attributes\n * @param {string} attribute\n * @returns {string}\n */ function $3f66b5b5be89dedb$export$5b10b3bc32d7efbc(attributes, attribute) {\n    return attribute in attributes ? attributes[attribute] : attribute;\n}\n\n});\n\n\n\nparcelRequire.register(\"7ejLl\", function(module, exports) {\n\n$parcel$export(module.exports, \"aria\", () => $54392ba55dc44eaa$export$4d2d26490572750a);\n\nvar $bhH9I = parcelRequire(\"bhH9I\");\n\nvar $jbPNJ = parcelRequire(\"jbPNJ\");\nconst $54392ba55dc44eaa$export$4d2d26490572750a = (0, $jbPNJ.create)({\n    transform (_, prop) {\n        return prop === \"role\" ? prop : \"aria-\" + prop.slice(4).toLowerCase();\n    },\n    properties: {\n        ariaActiveDescendant: null,\n        ariaAtomic: (0, $bhH9I.booleanish),\n        ariaAutoComplete: null,\n        ariaBusy: (0, $bhH9I.booleanish),\n        ariaChecked: (0, $bhH9I.booleanish),\n        ariaColCount: (0, $bhH9I.number),\n        ariaColIndex: (0, $bhH9I.number),\n        ariaColSpan: (0, $bhH9I.number),\n        ariaControls: (0, $bhH9I.spaceSeparated),\n        ariaCurrent: null,\n        ariaDescribedBy: (0, $bhH9I.spaceSeparated),\n        ariaDetails: null,\n        ariaDisabled: (0, $bhH9I.booleanish),\n        ariaDropEffect: (0, $bhH9I.spaceSeparated),\n        ariaErrorMessage: null,\n        ariaExpanded: (0, $bhH9I.booleanish),\n        ariaFlowTo: (0, $bhH9I.spaceSeparated),\n        ariaGrabbed: (0, $bhH9I.booleanish),\n        ariaHasPopup: null,\n        ariaHidden: (0, $bhH9I.booleanish),\n        ariaInvalid: null,\n        ariaKeyShortcuts: null,\n        ariaLabel: null,\n        ariaLabelledBy: (0, $bhH9I.spaceSeparated),\n        ariaLevel: (0, $bhH9I.number),\n        ariaLive: null,\n        ariaModal: (0, $bhH9I.booleanish),\n        ariaMultiLine: (0, $bhH9I.booleanish),\n        ariaMultiSelectable: (0, $bhH9I.booleanish),\n        ariaOrientation: null,\n        ariaOwns: (0, $bhH9I.spaceSeparated),\n        ariaPlaceholder: null,\n        ariaPosInSet: (0, $bhH9I.number),\n        ariaPressed: (0, $bhH9I.booleanish),\n        ariaReadOnly: (0, $bhH9I.booleanish),\n        ariaRelevant: null,\n        ariaRequired: (0, $bhH9I.booleanish),\n        ariaRoleDescription: (0, $bhH9I.spaceSeparated),\n        ariaRowCount: (0, $bhH9I.number),\n        ariaRowIndex: (0, $bhH9I.number),\n        ariaRowSpan: (0, $bhH9I.number),\n        ariaSelected: (0, $bhH9I.booleanish),\n        ariaSetSize: (0, $bhH9I.number),\n        ariaSort: null,\n        ariaValueMax: (0, $bhH9I.number),\n        ariaValueMin: (0, $bhH9I.number),\n        ariaValueNow: (0, $bhH9I.number),\n        ariaValueText: null,\n        role: null\n    }\n});\n\n});\n\nparcelRequire.register(\"cwo9C\", function(module, exports) {\n\n$parcel$export(module.exports, \"html\", () => $91db35b5689628e4$export$c0bb0b647f701bb5);\n\nvar $bhH9I = parcelRequire(\"bhH9I\");\n\nvar $jbPNJ = parcelRequire(\"jbPNJ\");\n\nvar $4PxUO = parcelRequire(\"4PxUO\");\nconst $91db35b5689628e4$export$c0bb0b647f701bb5 = (0, $jbPNJ.create)({\n    space: \"html\",\n    attributes: {\n        acceptcharset: \"accept-charset\",\n        classname: \"class\",\n        htmlfor: \"for\",\n        httpequiv: \"http-equiv\"\n    },\n    transform: (0, $4PxUO.caseInsensitiveTransform),\n    mustUseProperty: [\n        \"checked\",\n        \"multiple\",\n        \"muted\",\n        \"selected\"\n    ],\n    properties: {\n        // Standard Properties.\n        abbr: null,\n        accept: (0, $bhH9I.commaSeparated),\n        acceptCharset: (0, $bhH9I.spaceSeparated),\n        accessKey: (0, $bhH9I.spaceSeparated),\n        action: null,\n        allow: null,\n        allowFullScreen: (0, $bhH9I.boolean),\n        allowPaymentRequest: (0, $bhH9I.boolean),\n        allowUserMedia: (0, $bhH9I.boolean),\n        alt: null,\n        as: null,\n        async: (0, $bhH9I.boolean),\n        autoCapitalize: null,\n        autoComplete: (0, $bhH9I.spaceSeparated),\n        autoFocus: (0, $bhH9I.boolean),\n        autoPlay: (0, $bhH9I.boolean),\n        capture: (0, $bhH9I.boolean),\n        charSet: null,\n        checked: (0, $bhH9I.boolean),\n        cite: null,\n        className: (0, $bhH9I.spaceSeparated),\n        cols: (0, $bhH9I.number),\n        colSpan: null,\n        content: null,\n        contentEditable: (0, $bhH9I.booleanish),\n        controls: (0, $bhH9I.boolean),\n        controlsList: (0, $bhH9I.spaceSeparated),\n        coords: (0, $bhH9I.number) | (0, $bhH9I.commaSeparated),\n        crossOrigin: null,\n        data: null,\n        dateTime: null,\n        decoding: null,\n        default: (0, $bhH9I.boolean),\n        defer: (0, $bhH9I.boolean),\n        dir: null,\n        dirName: null,\n        disabled: (0, $bhH9I.boolean),\n        download: (0, $bhH9I.overloadedBoolean),\n        draggable: (0, $bhH9I.booleanish),\n        encType: null,\n        enterKeyHint: null,\n        form: null,\n        formAction: null,\n        formEncType: null,\n        formMethod: null,\n        formNoValidate: (0, $bhH9I.boolean),\n        formTarget: null,\n        headers: (0, $bhH9I.spaceSeparated),\n        height: (0, $bhH9I.number),\n        hidden: (0, $bhH9I.boolean),\n        high: (0, $bhH9I.number),\n        href: null,\n        hrefLang: null,\n        htmlFor: (0, $bhH9I.spaceSeparated),\n        httpEquiv: (0, $bhH9I.spaceSeparated),\n        id: null,\n        imageSizes: null,\n        imageSrcSet: null,\n        inputMode: null,\n        integrity: null,\n        is: null,\n        isMap: (0, $bhH9I.boolean),\n        itemId: null,\n        itemProp: (0, $bhH9I.spaceSeparated),\n        itemRef: (0, $bhH9I.spaceSeparated),\n        itemScope: (0, $bhH9I.boolean),\n        itemType: (0, $bhH9I.spaceSeparated),\n        kind: null,\n        label: null,\n        lang: null,\n        language: null,\n        list: null,\n        loading: null,\n        loop: (0, $bhH9I.boolean),\n        low: (0, $bhH9I.number),\n        manifest: null,\n        max: null,\n        maxLength: (0, $bhH9I.number),\n        media: null,\n        method: null,\n        min: null,\n        minLength: (0, $bhH9I.number),\n        multiple: (0, $bhH9I.boolean),\n        muted: (0, $bhH9I.boolean),\n        name: null,\n        nonce: null,\n        noModule: (0, $bhH9I.boolean),\n        noValidate: (0, $bhH9I.boolean),\n        onAbort: null,\n        onAfterPrint: null,\n        onAuxClick: null,\n        onBeforeMatch: null,\n        onBeforePrint: null,\n        onBeforeUnload: null,\n        onBlur: null,\n        onCancel: null,\n        onCanPlay: null,\n        onCanPlayThrough: null,\n        onChange: null,\n        onClick: null,\n        onClose: null,\n        onContextLost: null,\n        onContextMenu: null,\n        onContextRestored: null,\n        onCopy: null,\n        onCueChange: null,\n        onCut: null,\n        onDblClick: null,\n        onDrag: null,\n        onDragEnd: null,\n        onDragEnter: null,\n        onDragExit: null,\n        onDragLeave: null,\n        onDragOver: null,\n        onDragStart: null,\n        onDrop: null,\n        onDurationChange: null,\n        onEmptied: null,\n        onEnded: null,\n        onError: null,\n        onFocus: null,\n        onFormData: null,\n        onHashChange: null,\n        onInput: null,\n        onInvalid: null,\n        onKeyDown: null,\n        onKeyPress: null,\n        onKeyUp: null,\n        onLanguageChange: null,\n        onLoad: null,\n        onLoadedData: null,\n        onLoadedMetadata: null,\n        onLoadEnd: null,\n        onLoadStart: null,\n        onMessage: null,\n        onMessageError: null,\n        onMouseDown: null,\n        onMouseEnter: null,\n        onMouseLeave: null,\n        onMouseMove: null,\n        onMouseOut: null,\n        onMouseOver: null,\n        onMouseUp: null,\n        onOffline: null,\n        onOnline: null,\n        onPageHide: null,\n        onPageShow: null,\n        onPaste: null,\n        onPause: null,\n        onPlay: null,\n        onPlaying: null,\n        onPopState: null,\n        onProgress: null,\n        onRateChange: null,\n        onRejectionHandled: null,\n        onReset: null,\n        onResize: null,\n        onScroll: null,\n        onScrollEnd: null,\n        onSecurityPolicyViolation: null,\n        onSeeked: null,\n        onSeeking: null,\n        onSelect: null,\n        onSlotChange: null,\n        onStalled: null,\n        onStorage: null,\n        onSubmit: null,\n        onSuspend: null,\n        onTimeUpdate: null,\n        onToggle: null,\n        onUnhandledRejection: null,\n        onUnload: null,\n        onVolumeChange: null,\n        onWaiting: null,\n        onWheel: null,\n        open: (0, $bhH9I.boolean),\n        optimum: (0, $bhH9I.number),\n        pattern: null,\n        ping: (0, $bhH9I.spaceSeparated),\n        placeholder: null,\n        playsInline: (0, $bhH9I.boolean),\n        poster: null,\n        preload: null,\n        readOnly: (0, $bhH9I.boolean),\n        referrerPolicy: null,\n        rel: (0, $bhH9I.spaceSeparated),\n        required: (0, $bhH9I.boolean),\n        reversed: (0, $bhH9I.boolean),\n        rows: (0, $bhH9I.number),\n        rowSpan: (0, $bhH9I.number),\n        sandbox: (0, $bhH9I.spaceSeparated),\n        scope: null,\n        scoped: (0, $bhH9I.boolean),\n        seamless: (0, $bhH9I.boolean),\n        selected: (0, $bhH9I.boolean),\n        shape: null,\n        size: (0, $bhH9I.number),\n        sizes: null,\n        slot: null,\n        span: (0, $bhH9I.number),\n        spellCheck: (0, $bhH9I.booleanish),\n        src: null,\n        srcDoc: null,\n        srcLang: null,\n        srcSet: null,\n        start: (0, $bhH9I.number),\n        step: null,\n        style: null,\n        tabIndex: (0, $bhH9I.number),\n        target: null,\n        title: null,\n        translate: null,\n        type: null,\n        typeMustMatch: (0, $bhH9I.boolean),\n        useMap: null,\n        value: (0, $bhH9I.booleanish),\n        width: (0, $bhH9I.number),\n        wrap: null,\n        // Legacy.\n        // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis\n        align: null,\n        aLink: null,\n        archive: (0, $bhH9I.spaceSeparated),\n        axis: null,\n        background: null,\n        bgColor: null,\n        border: (0, $bhH9I.number),\n        borderColor: null,\n        bottomMargin: (0, $bhH9I.number),\n        cellPadding: null,\n        cellSpacing: null,\n        char: null,\n        charOff: null,\n        classId: null,\n        clear: null,\n        code: null,\n        codeBase: null,\n        codeType: null,\n        color: null,\n        compact: (0, $bhH9I.boolean),\n        declare: (0, $bhH9I.boolean),\n        event: null,\n        face: null,\n        frame: null,\n        frameBorder: null,\n        hSpace: (0, $bhH9I.number),\n        leftMargin: (0, $bhH9I.number),\n        link: null,\n        longDesc: null,\n        lowSrc: null,\n        marginHeight: (0, $bhH9I.number),\n        marginWidth: (0, $bhH9I.number),\n        noResize: (0, $bhH9I.boolean),\n        noHref: (0, $bhH9I.boolean),\n        noShade: (0, $bhH9I.boolean),\n        noWrap: (0, $bhH9I.boolean),\n        object: null,\n        profile: null,\n        prompt: null,\n        rev: null,\n        rightMargin: (0, $bhH9I.number),\n        rules: null,\n        scheme: null,\n        scrolling: (0, $bhH9I.booleanish),\n        standby: null,\n        summary: null,\n        text: null,\n        topMargin: (0, $bhH9I.number),\n        valueType: null,\n        version: null,\n        vAlign: null,\n        vLink: null,\n        vSpace: (0, $bhH9I.number),\n        // Non-standard Properties.\n        allowTransparency: null,\n        autoCorrect: null,\n        autoSave: null,\n        disablePictureInPicture: (0, $bhH9I.boolean),\n        disableRemotePlayback: (0, $bhH9I.boolean),\n        prefix: null,\n        property: null,\n        results: (0, $bhH9I.number),\n        security: null,\n        unselectable: null\n    }\n});\n\n});\n\nparcelRequire.register(\"lF5RX\", function(module, exports) {\n\n$parcel$export(module.exports, \"svg\", () => $fc51face202e8fdd$export$7ed1367e7fa1ad68);\n\nvar $bhH9I = parcelRequire(\"bhH9I\");\n\nvar $jbPNJ = parcelRequire(\"jbPNJ\");\n\nvar $5rtXf = parcelRequire(\"5rtXf\");\nconst $fc51face202e8fdd$export$7ed1367e7fa1ad68 = (0, $jbPNJ.create)({\n    space: \"svg\",\n    attributes: {\n        accentHeight: \"accent-height\",\n        alignmentBaseline: \"alignment-baseline\",\n        arabicForm: \"arabic-form\",\n        baselineShift: \"baseline-shift\",\n        capHeight: \"cap-height\",\n        className: \"class\",\n        clipPath: \"clip-path\",\n        clipRule: \"clip-rule\",\n        colorInterpolation: \"color-interpolation\",\n        colorInterpolationFilters: \"color-interpolation-filters\",\n        colorProfile: \"color-profile\",\n        colorRendering: \"color-rendering\",\n        crossOrigin: \"crossorigin\",\n        dataType: \"datatype\",\n        dominantBaseline: \"dominant-baseline\",\n        enableBackground: \"enable-background\",\n        fillOpacity: \"fill-opacity\",\n        fillRule: \"fill-rule\",\n        floodColor: \"flood-color\",\n        floodOpacity: \"flood-opacity\",\n        fontFamily: \"font-family\",\n        fontSize: \"font-size\",\n        fontSizeAdjust: \"font-size-adjust\",\n        fontStretch: \"font-stretch\",\n        fontStyle: \"font-style\",\n        fontVariant: \"font-variant\",\n        fontWeight: \"font-weight\",\n        glyphName: \"glyph-name\",\n        glyphOrientationHorizontal: \"glyph-orientation-horizontal\",\n        glyphOrientationVertical: \"glyph-orientation-vertical\",\n        hrefLang: \"hreflang\",\n        horizAdvX: \"horiz-adv-x\",\n        horizOriginX: \"horiz-origin-x\",\n        horizOriginY: \"horiz-origin-y\",\n        imageRendering: \"image-rendering\",\n        letterSpacing: \"letter-spacing\",\n        lightingColor: \"lighting-color\",\n        markerEnd: \"marker-end\",\n        markerMid: \"marker-mid\",\n        markerStart: \"marker-start\",\n        navDown: \"nav-down\",\n        navDownLeft: \"nav-down-left\",\n        navDownRight: \"nav-down-right\",\n        navLeft: \"nav-left\",\n        navNext: \"nav-next\",\n        navPrev: \"nav-prev\",\n        navRight: \"nav-right\",\n        navUp: \"nav-up\",\n        navUpLeft: \"nav-up-left\",\n        navUpRight: \"nav-up-right\",\n        onAbort: \"onabort\",\n        onActivate: \"onactivate\",\n        onAfterPrint: \"onafterprint\",\n        onBeforePrint: \"onbeforeprint\",\n        onBegin: \"onbegin\",\n        onCancel: \"oncancel\",\n        onCanPlay: \"oncanplay\",\n        onCanPlayThrough: \"oncanplaythrough\",\n        onChange: \"onchange\",\n        onClick: \"onclick\",\n        onClose: \"onclose\",\n        onCopy: \"oncopy\",\n        onCueChange: \"oncuechange\",\n        onCut: \"oncut\",\n        onDblClick: \"ondblclick\",\n        onDrag: \"ondrag\",\n        onDragEnd: \"ondragend\",\n        onDragEnter: \"ondragenter\",\n        onDragExit: \"ondragexit\",\n        onDragLeave: \"ondragleave\",\n        onDragOver: \"ondragover\",\n        onDragStart: \"ondragstart\",\n        onDrop: \"ondrop\",\n        onDurationChange: \"ondurationchange\",\n        onEmptied: \"onemptied\",\n        onEnd: \"onend\",\n        onEnded: \"onended\",\n        onError: \"onerror\",\n        onFocus: \"onfocus\",\n        onFocusIn: \"onfocusin\",\n        onFocusOut: \"onfocusout\",\n        onHashChange: \"onhashchange\",\n        onInput: \"oninput\",\n        onInvalid: \"oninvalid\",\n        onKeyDown: \"onkeydown\",\n        onKeyPress: \"onkeypress\",\n        onKeyUp: \"onkeyup\",\n        onLoad: \"onload\",\n        onLoadedData: \"onloadeddata\",\n        onLoadedMetadata: \"onloadedmetadata\",\n        onLoadStart: \"onloadstart\",\n        onMessage: \"onmessage\",\n        onMouseDown: \"onmousedown\",\n        onMouseEnter: \"onmouseenter\",\n        onMouseLeave: \"onmouseleave\",\n        onMouseMove: \"onmousemove\",\n        onMouseOut: \"onmouseout\",\n        onMouseOver: \"onmouseover\",\n        onMouseUp: \"onmouseup\",\n        onMouseWheel: \"onmousewheel\",\n        onOffline: \"onoffline\",\n        onOnline: \"ononline\",\n        onPageHide: \"onpagehide\",\n        onPageShow: \"onpageshow\",\n        onPaste: \"onpaste\",\n        onPause: \"onpause\",\n        onPlay: \"onplay\",\n        onPlaying: \"onplaying\",\n        onPopState: \"onpopstate\",\n        onProgress: \"onprogress\",\n        onRateChange: \"onratechange\",\n        onRepeat: \"onrepeat\",\n        onReset: \"onreset\",\n        onResize: \"onresize\",\n        onScroll: \"onscroll\",\n        onSeeked: \"onseeked\",\n        onSeeking: \"onseeking\",\n        onSelect: \"onselect\",\n        onShow: \"onshow\",\n        onStalled: \"onstalled\",\n        onStorage: \"onstorage\",\n        onSubmit: \"onsubmit\",\n        onSuspend: \"onsuspend\",\n        onTimeUpdate: \"ontimeupdate\",\n        onToggle: \"ontoggle\",\n        onUnload: \"onunload\",\n        onVolumeChange: \"onvolumechange\",\n        onWaiting: \"onwaiting\",\n        onZoom: \"onzoom\",\n        overlinePosition: \"overline-position\",\n        overlineThickness: \"overline-thickness\",\n        paintOrder: \"paint-order\",\n        panose1: \"panose-1\",\n        pointerEvents: \"pointer-events\",\n        referrerPolicy: \"referrerpolicy\",\n        renderingIntent: \"rendering-intent\",\n        shapeRendering: \"shape-rendering\",\n        stopColor: \"stop-color\",\n        stopOpacity: \"stop-opacity\",\n        strikethroughPosition: \"strikethrough-position\",\n        strikethroughThickness: \"strikethrough-thickness\",\n        strokeDashArray: \"stroke-dasharray\",\n        strokeDashOffset: \"stroke-dashoffset\",\n        strokeLineCap: \"stroke-linecap\",\n        strokeLineJoin: \"stroke-linejoin\",\n        strokeMiterLimit: \"stroke-miterlimit\",\n        strokeOpacity: \"stroke-opacity\",\n        strokeWidth: \"stroke-width\",\n        tabIndex: \"tabindex\",\n        textAnchor: \"text-anchor\",\n        textDecoration: \"text-decoration\",\n        textRendering: \"text-rendering\",\n        typeOf: \"typeof\",\n        underlinePosition: \"underline-position\",\n        underlineThickness: \"underline-thickness\",\n        unicodeBidi: \"unicode-bidi\",\n        unicodeRange: \"unicode-range\",\n        unitsPerEm: \"units-per-em\",\n        vAlphabetic: \"v-alphabetic\",\n        vHanging: \"v-hanging\",\n        vIdeographic: \"v-ideographic\",\n        vMathematical: \"v-mathematical\",\n        vectorEffect: \"vector-effect\",\n        vertAdvY: \"vert-adv-y\",\n        vertOriginX: \"vert-origin-x\",\n        vertOriginY: \"vert-origin-y\",\n        wordSpacing: \"word-spacing\",\n        writingMode: \"writing-mode\",\n        xHeight: \"x-height\",\n        // These were camelcased in Tiny. Now lowercased in SVG 2\n        playbackOrder: \"playbackorder\",\n        timelineBegin: \"timelinebegin\"\n    },\n    transform: (0, $5rtXf.caseSensitiveTransform),\n    properties: {\n        about: (0, $bhH9I.commaOrSpaceSeparated),\n        accentHeight: (0, $bhH9I.number),\n        accumulate: null,\n        additive: null,\n        alignmentBaseline: null,\n        alphabetic: (0, $bhH9I.number),\n        amplitude: (0, $bhH9I.number),\n        arabicForm: null,\n        ascent: (0, $bhH9I.number),\n        attributeName: null,\n        attributeType: null,\n        azimuth: (0, $bhH9I.number),\n        bandwidth: null,\n        baselineShift: null,\n        baseFrequency: null,\n        baseProfile: null,\n        bbox: null,\n        begin: null,\n        bias: (0, $bhH9I.number),\n        by: null,\n        calcMode: null,\n        capHeight: (0, $bhH9I.number),\n        className: (0, $bhH9I.spaceSeparated),\n        clip: null,\n        clipPath: null,\n        clipPathUnits: null,\n        clipRule: null,\n        color: null,\n        colorInterpolation: null,\n        colorInterpolationFilters: null,\n        colorProfile: null,\n        colorRendering: null,\n        content: null,\n        contentScriptType: null,\n        contentStyleType: null,\n        crossOrigin: null,\n        cursor: null,\n        cx: null,\n        cy: null,\n        d: null,\n        dataType: null,\n        defaultAction: null,\n        descent: (0, $bhH9I.number),\n        diffuseConstant: (0, $bhH9I.number),\n        direction: null,\n        display: null,\n        dur: null,\n        divisor: (0, $bhH9I.number),\n        dominantBaseline: null,\n        download: (0, $bhH9I.boolean),\n        dx: null,\n        dy: null,\n        edgeMode: null,\n        editable: null,\n        elevation: (0, $bhH9I.number),\n        enableBackground: null,\n        end: null,\n        event: null,\n        exponent: (0, $bhH9I.number),\n        externalResourcesRequired: null,\n        fill: null,\n        fillOpacity: (0, $bhH9I.number),\n        fillRule: null,\n        filter: null,\n        filterRes: null,\n        filterUnits: null,\n        floodColor: null,\n        floodOpacity: null,\n        focusable: null,\n        focusHighlight: null,\n        fontFamily: null,\n        fontSize: null,\n        fontSizeAdjust: null,\n        fontStretch: null,\n        fontStyle: null,\n        fontVariant: null,\n        fontWeight: null,\n        format: null,\n        fr: null,\n        from: null,\n        fx: null,\n        fy: null,\n        g1: (0, $bhH9I.commaSeparated),\n        g2: (0, $bhH9I.commaSeparated),\n        glyphName: (0, $bhH9I.commaSeparated),\n        glyphOrientationHorizontal: null,\n        glyphOrientationVertical: null,\n        glyphRef: null,\n        gradientTransform: null,\n        gradientUnits: null,\n        handler: null,\n        hanging: (0, $bhH9I.number),\n        hatchContentUnits: null,\n        hatchUnits: null,\n        height: null,\n        href: null,\n        hrefLang: null,\n        horizAdvX: (0, $bhH9I.number),\n        horizOriginX: (0, $bhH9I.number),\n        horizOriginY: (0, $bhH9I.number),\n        id: null,\n        ideographic: (0, $bhH9I.number),\n        imageRendering: null,\n        initialVisibility: null,\n        in: null,\n        in2: null,\n        intercept: (0, $bhH9I.number),\n        k: (0, $bhH9I.number),\n        k1: (0, $bhH9I.number),\n        k2: (0, $bhH9I.number),\n        k3: (0, $bhH9I.number),\n        k4: (0, $bhH9I.number),\n        kernelMatrix: (0, $bhH9I.commaOrSpaceSeparated),\n        kernelUnitLength: null,\n        keyPoints: null,\n        keySplines: null,\n        keyTimes: null,\n        kerning: null,\n        lang: null,\n        lengthAdjust: null,\n        letterSpacing: null,\n        lightingColor: null,\n        limitingConeAngle: (0, $bhH9I.number),\n        local: null,\n        markerEnd: null,\n        markerMid: null,\n        markerStart: null,\n        markerHeight: null,\n        markerUnits: null,\n        markerWidth: null,\n        mask: null,\n        maskContentUnits: null,\n        maskUnits: null,\n        mathematical: null,\n        max: null,\n        media: null,\n        mediaCharacterEncoding: null,\n        mediaContentEncodings: null,\n        mediaSize: (0, $bhH9I.number),\n        mediaTime: null,\n        method: null,\n        min: null,\n        mode: null,\n        name: null,\n        navDown: null,\n        navDownLeft: null,\n        navDownRight: null,\n        navLeft: null,\n        navNext: null,\n        navPrev: null,\n        navRight: null,\n        navUp: null,\n        navUpLeft: null,\n        navUpRight: null,\n        numOctaves: null,\n        observer: null,\n        offset: null,\n        onAbort: null,\n        onActivate: null,\n        onAfterPrint: null,\n        onBeforePrint: null,\n        onBegin: null,\n        onCancel: null,\n        onCanPlay: null,\n        onCanPlayThrough: null,\n        onChange: null,\n        onClick: null,\n        onClose: null,\n        onCopy: null,\n        onCueChange: null,\n        onCut: null,\n        onDblClick: null,\n        onDrag: null,\n        onDragEnd: null,\n        onDragEnter: null,\n        onDragExit: null,\n        onDragLeave: null,\n        onDragOver: null,\n        onDragStart: null,\n        onDrop: null,\n        onDurationChange: null,\n        onEmptied: null,\n        onEnd: null,\n        onEnded: null,\n        onError: null,\n        onFocus: null,\n        onFocusIn: null,\n        onFocusOut: null,\n        onHashChange: null,\n        onInput: null,\n        onInvalid: null,\n        onKeyDown: null,\n        onKeyPress: null,\n        onKeyUp: null,\n        onLoad: null,\n        onLoadedData: null,\n        onLoadedMetadata: null,\n        onLoadStart: null,\n        onMessage: null,\n        onMouseDown: null,\n        onMouseEnter: null,\n        onMouseLeave: null,\n        onMouseMove: null,\n        onMouseOut: null,\n        onMouseOver: null,\n        onMouseUp: null,\n        onMouseWheel: null,\n        onOffline: null,\n        onOnline: null,\n        onPageHide: null,\n        onPageShow: null,\n        onPaste: null,\n        onPause: null,\n        onPlay: null,\n        onPlaying: null,\n        onPopState: null,\n        onProgress: null,\n        onRateChange: null,\n        onRepeat: null,\n        onReset: null,\n        onResize: null,\n        onScroll: null,\n        onSeeked: null,\n        onSeeking: null,\n        onSelect: null,\n        onShow: null,\n        onStalled: null,\n        onStorage: null,\n        onSubmit: null,\n        onSuspend: null,\n        onTimeUpdate: null,\n        onToggle: null,\n        onUnload: null,\n        onVolumeChange: null,\n        onWaiting: null,\n        onZoom: null,\n        opacity: null,\n        operator: null,\n        order: null,\n        orient: null,\n        orientation: null,\n        origin: null,\n        overflow: null,\n        overlay: null,\n        overlinePosition: (0, $bhH9I.number),\n        overlineThickness: (0, $bhH9I.number),\n        paintOrder: null,\n        panose1: null,\n        path: null,\n        pathLength: (0, $bhH9I.number),\n        patternContentUnits: null,\n        patternTransform: null,\n        patternUnits: null,\n        phase: null,\n        ping: (0, $bhH9I.spaceSeparated),\n        pitch: null,\n        playbackOrder: null,\n        pointerEvents: null,\n        points: null,\n        pointsAtX: (0, $bhH9I.number),\n        pointsAtY: (0, $bhH9I.number),\n        pointsAtZ: (0, $bhH9I.number),\n        preserveAlpha: null,\n        preserveAspectRatio: null,\n        primitiveUnits: null,\n        propagate: null,\n        property: (0, $bhH9I.commaOrSpaceSeparated),\n        r: null,\n        radius: null,\n        referrerPolicy: null,\n        refX: null,\n        refY: null,\n        rel: (0, $bhH9I.commaOrSpaceSeparated),\n        rev: (0, $bhH9I.commaOrSpaceSeparated),\n        renderingIntent: null,\n        repeatCount: null,\n        repeatDur: null,\n        requiredExtensions: (0, $bhH9I.commaOrSpaceSeparated),\n        requiredFeatures: (0, $bhH9I.commaOrSpaceSeparated),\n        requiredFonts: (0, $bhH9I.commaOrSpaceSeparated),\n        requiredFormats: (0, $bhH9I.commaOrSpaceSeparated),\n        resource: null,\n        restart: null,\n        result: null,\n        rotate: null,\n        rx: null,\n        ry: null,\n        scale: null,\n        seed: null,\n        shapeRendering: null,\n        side: null,\n        slope: null,\n        snapshotTime: null,\n        specularConstant: (0, $bhH9I.number),\n        specularExponent: (0, $bhH9I.number),\n        spreadMethod: null,\n        spacing: null,\n        startOffset: null,\n        stdDeviation: null,\n        stemh: null,\n        stemv: null,\n        stitchTiles: null,\n        stopColor: null,\n        stopOpacity: null,\n        strikethroughPosition: (0, $bhH9I.number),\n        strikethroughThickness: (0, $bhH9I.number),\n        string: null,\n        stroke: null,\n        strokeDashArray: (0, $bhH9I.commaOrSpaceSeparated),\n        strokeDashOffset: null,\n        strokeLineCap: null,\n        strokeLineJoin: null,\n        strokeMiterLimit: (0, $bhH9I.number),\n        strokeOpacity: (0, $bhH9I.number),\n        strokeWidth: null,\n        style: null,\n        surfaceScale: (0, $bhH9I.number),\n        syncBehavior: null,\n        syncBehaviorDefault: null,\n        syncMaster: null,\n        syncTolerance: null,\n        syncToleranceDefault: null,\n        systemLanguage: (0, $bhH9I.commaOrSpaceSeparated),\n        tabIndex: (0, $bhH9I.number),\n        tableValues: null,\n        target: null,\n        targetX: (0, $bhH9I.number),\n        targetY: (0, $bhH9I.number),\n        textAnchor: null,\n        textDecoration: null,\n        textRendering: null,\n        textLength: null,\n        timelineBegin: null,\n        title: null,\n        transformBehavior: null,\n        type: null,\n        typeOf: (0, $bhH9I.commaOrSpaceSeparated),\n        to: null,\n        transform: null,\n        u1: null,\n        u2: null,\n        underlinePosition: (0, $bhH9I.number),\n        underlineThickness: (0, $bhH9I.number),\n        unicode: null,\n        unicodeBidi: null,\n        unicodeRange: null,\n        unitsPerEm: (0, $bhH9I.number),\n        values: null,\n        vAlphabetic: (0, $bhH9I.number),\n        vMathematical: (0, $bhH9I.number),\n        vectorEffect: null,\n        vHanging: (0, $bhH9I.number),\n        vIdeographic: (0, $bhH9I.number),\n        version: null,\n        vertAdvY: (0, $bhH9I.number),\n        vertOriginX: (0, $bhH9I.number),\n        vertOriginY: (0, $bhH9I.number),\n        viewBox: null,\n        viewTarget: null,\n        visibility: null,\n        width: null,\n        widths: null,\n        wordSpacing: null,\n        writingMode: null,\n        x: null,\n        x1: null,\n        x2: null,\n        xChannelSelector: null,\n        xHeight: (0, $bhH9I.number),\n        y: null,\n        y1: null,\n        y2: null,\n        yChannelSelector: null,\n        z: null,\n        zoomAndPan: null\n    }\n});\n\n});\n\nparcelRequire.register(\"8e8kD\", function(module, exports) {\n\n$parcel$export(module.exports, \"find\", () => $5fd6180ccffdcd4c$export$71aa6c912b956294);\n/**\n * @typedef {import('./util/schema.js').Schema} Schema\n */ \nvar $4GEAW = parcelRequire(\"4GEAW\");\n\nvar $lqZ1V = parcelRequire(\"lqZ1V\");\n\nvar $imkUs = parcelRequire(\"imkUs\");\nconst $5fd6180ccffdcd4c$var$valid = /^data[-\\w.:]+$/i;\nconst $5fd6180ccffdcd4c$var$dash = /-[a-z]/g;\nconst $5fd6180ccffdcd4c$var$cap = /[A-Z]/g;\nfunction $5fd6180ccffdcd4c$export$71aa6c912b956294(schema, value) {\n    const normal = (0, $4GEAW.normalize)(value);\n    let prop = value;\n    let Type = (0, $imkUs.Info);\n    if (normal in schema.normal) return schema.property[schema.normal[normal]];\n    if (normal.length > 4 && normal.slice(0, 4) === \"data\" && $5fd6180ccffdcd4c$var$valid.test(value)) {\n        // Attribute or property.\n        if (value.charAt(4) === \"-\") {\n            // Turn it into a property.\n            const rest = value.slice(5).replace($5fd6180ccffdcd4c$var$dash, $5fd6180ccffdcd4c$var$camelcase);\n            prop = \"data\" + rest.charAt(0).toUpperCase() + rest.slice(1);\n        } else {\n            // Turn it into an attribute.\n            const rest = value.slice(4);\n            if (!$5fd6180ccffdcd4c$var$dash.test(rest)) {\n                let dashes = rest.replace($5fd6180ccffdcd4c$var$cap, $5fd6180ccffdcd4c$var$kebab);\n                if (dashes.charAt(0) !== \"-\") dashes = \"-\" + dashes;\n                value = \"data\" + dashes;\n            }\n        }\n        Type = (0, $lqZ1V.DefinedInfo);\n    }\n    return new Type(prop, value);\n}\n/**\n * @param {string} $0\n * @returns {string}\n */ function $5fd6180ccffdcd4c$var$kebab($0) {\n    return \"-\" + $0.toLowerCase();\n}\n/**\n * @param {string} $0\n * @returns {string}\n */ function $5fd6180ccffdcd4c$var$camelcase($0) {\n    return $0.charAt(1).toUpperCase();\n}\n\n});\n\nparcelRequire.register(\"j3JRp\", function(module, exports) {\n\n$parcel$export(module.exports, \"hastToReact\", () => $de01df0dd0de2012$export$d8abd7e5fb6871f9);\n/**\n * `hast` is close to `React`, but differs in a couple of cases.\n *\n * To get a React property from a hast property, check if it is in\n * `hastToReact`, if it is, then use the corresponding value,\n * otherwise, use the hast property.\n *\n * @type {Record<string, string>}\n */ const $de01df0dd0de2012$export$d8abd7e5fb6871f9 = {\n    classId: \"classID\",\n    dataType: \"datatype\",\n    itemId: \"itemID\",\n    strokeDashArray: \"strokeDasharray\",\n    strokeDashOffset: \"strokeDashoffset\",\n    strokeLineCap: \"strokeLinecap\",\n    strokeLineJoin: \"strokeLinejoin\",\n    strokeMiterLimit: \"strokeMiterlimit\",\n    typeOf: \"typeof\",\n    xLinkActuate: \"xlinkActuate\",\n    xLinkArcRole: \"xlinkArcrole\",\n    xLinkHref: \"xlinkHref\",\n    xLinkRole: \"xlinkRole\",\n    xLinkShow: \"xlinkShow\",\n    xLinkTitle: \"xlinkTitle\",\n    xLinkType: \"xlinkType\",\n    xmlnsXLink: \"xmlnsXlink\"\n};\n\n});\n\n\nparcelRequire.register(\"1p9m5\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $105f61fb909d5bd6$export$2e2bcd8739ae039);\n\nvar $ei8wA = parcelRequire(\"ei8wA\");\nfunction $105f61fb909d5bd6$export$2e2bcd8739ae039(options) {\n    if (options.allowedElements && options.disallowedElements) throw new TypeError(\"Only one of `allowedElements` and `disallowedElements` should be defined\");\n    if (options.allowedElements || options.disallowedElements || options.allowElement) return (tree)=>{\n        (0, $ei8wA.visit)(tree, \"element\", (node, index, parent_)=>{\n            const parent = /** @type {Element|Root} */ parent_;\n            /** @type {boolean|undefined} */ let remove;\n            if (options.allowedElements) remove = !options.allowedElements.includes(node.tagName);\n            else if (options.disallowedElements) remove = options.disallowedElements.includes(node.tagName);\n            if (!remove && options.allowElement && typeof index === \"number\") remove = !options.allowElement(node, index, parent);\n            if (remove && typeof index === \"number\") {\n                if (options.unwrapDisallowed && node.children) parent.children.splice(index, 1, ...node.children);\n                else parent.children.splice(index, 1);\n                return index;\n            }\n            return undefined;\n        });\n    };\n}\n\n});\n\nparcelRequire.register(\"hM85M\", function(module, exports) {\n\n$parcel$export(module.exports, \"childrenToReact\", () => $cf0d324ac74956f1$export$4b745c302603ab5d);\n/**\n * @template T\n * @typedef {import('react').ComponentType<T>} ComponentType<T>\n */ /**\n * @template T\n * @typedef {import('react').ComponentPropsWithoutRef<T>} ComponentPropsWithoutRef<T>\n */ /**\n * @typedef {import('react').ReactNode} ReactNode\n * @typedef {import('unist').Position} Position\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('./complex-types.js').ReactMarkdownProps} ReactMarkdownProps\n *\n * @typedef Raw\n * @property {'raw'} type\n * @property {string} value\n *\n * @typedef Context\n * @property {Options} options\n * @property {Schema} schema\n * @property {number} listDepth\n *\n * @callback TransformLink\n * @param {string} href\n * @param {Array<ElementContent>} children\n * @param {string?} title\n * @returns {string}\n *\n * @callback TransformImage\n * @param {string} src\n * @param {string} alt\n * @param {string?} title\n * @returns {string}\n *\n * @typedef {import('react').HTMLAttributeAnchorTarget} TransformLinkTargetType\n *\n * @callback TransformLinkTarget\n * @param {string} href\n * @param {Array<ElementContent>} children\n * @param {string?} title\n * @returns {TransformLinkTargetType|undefined}\n *\n * @typedef {keyof JSX.IntrinsicElements} ReactMarkdownNames\n *\n * To do: is `data-sourcepos` typeable?\n *\n * @typedef {ComponentPropsWithoutRef<'code'> & ReactMarkdownProps & {inline?: boolean}} CodeProps\n * @typedef {ComponentPropsWithoutRef<'h1'> & ReactMarkdownProps & {level: number}} HeadingProps\n * @typedef {ComponentPropsWithoutRef<'li'> & ReactMarkdownProps & {checked: boolean|null, index: number, ordered: boolean}} LiProps\n * @typedef {ComponentPropsWithoutRef<'ol'> & ReactMarkdownProps & {depth: number, ordered: true}} OrderedListProps\n * @typedef {ComponentPropsWithoutRef<'td'> & ReactMarkdownProps & {style?: Record<string, unknown>, isHeader: false}} TableDataCellProps\n * @typedef {ComponentPropsWithoutRef<'th'> & ReactMarkdownProps & {style?: Record<string, unknown>, isHeader: true}} TableHeaderCellProps\n * @typedef {ComponentPropsWithoutRef<'tr'> & ReactMarkdownProps & {isHeader: boolean}} TableRowProps\n * @typedef {ComponentPropsWithoutRef<'ul'> & ReactMarkdownProps & {depth: number, ordered: false}} UnorderedListProps\n *\n * @typedef {ComponentType<CodeProps>} CodeComponent\n * @typedef {ComponentType<HeadingProps>} HeadingComponent\n * @typedef {ComponentType<LiProps>} LiComponent\n * @typedef {ComponentType<OrderedListProps>} OrderedListComponent\n * @typedef {ComponentType<TableDataCellProps>} TableDataCellComponent\n * @typedef {ComponentType<TableHeaderCellProps>} TableHeaderCellComponent\n * @typedef {ComponentType<TableRowProps>} TableRowComponent\n * @typedef {ComponentType<UnorderedListProps>} UnorderedListComponent\n *\n * @typedef SpecialComponents\n * @property {CodeComponent|ReactMarkdownNames} code\n * @property {HeadingComponent|ReactMarkdownNames} h1\n * @property {HeadingComponent|ReactMarkdownNames} h2\n * @property {HeadingComponent|ReactMarkdownNames} h3\n * @property {HeadingComponent|ReactMarkdownNames} h4\n * @property {HeadingComponent|ReactMarkdownNames} h5\n * @property {HeadingComponent|ReactMarkdownNames} h6\n * @property {LiComponent|ReactMarkdownNames} li\n * @property {OrderedListComponent|ReactMarkdownNames} ol\n * @property {TableDataCellComponent|ReactMarkdownNames} td\n * @property {TableHeaderCellComponent|ReactMarkdownNames} th\n * @property {TableRowComponent|ReactMarkdownNames} tr\n * @property {UnorderedListComponent|ReactMarkdownNames} ul\n *\n * @typedef {Partial<Omit<import('./complex-types.js').NormalComponents, keyof SpecialComponents> & SpecialComponents>} Components\n *\n * @typedef Options\n * @property {boolean} [sourcePos=false]\n * @property {boolean} [rawSourcePos=false]\n * @property {boolean} [skipHtml=false]\n * @property {boolean} [includeElementIndex=false]\n * @property {null|false|TransformLink} [transformLinkUri]\n * @property {TransformImage} [transformImageUri]\n * @property {TransformLinkTargetType|TransformLinkTarget} [linkTarget]\n * @property {Components} [components]\n */ \nvar $3TwHq = parcelRequire(\"3TwHq\");\n\nvar $5EgQh = parcelRequire(\"5EgQh\");\n\nvar $2h0WQ = parcelRequire(\"2h0WQ\");\n\nvar $8e8kD = parcelRequire(\"8e8kD\");\nvar $j3JRp = parcelRequire(\"j3JRp\");\nvar $aY292 = parcelRequire(\"aY292\");\n\nvar $9LDtD = parcelRequire(\"9LDtD\");\n\nvar $aydpb = parcelRequire(\"aydpb\");\n\nvar $aKvL7 = parcelRequire(\"aKvL7\");\n\nvar $10YAt = parcelRequire(\"10YAt\");\nconst $cf0d324ac74956f1$var$own = {}.hasOwnProperty;\n// The table-related elements that must not contain whitespace text according\n// to React.\nconst $cf0d324ac74956f1$var$tableElements = new Set([\n    \"table\",\n    \"thead\",\n    \"tbody\",\n    \"tfoot\",\n    \"tr\"\n]);\nfunction $cf0d324ac74956f1$export$4b745c302603ab5d(context, node) {\n    /** @type {Array<ReactNode>} */ const children = [];\n    let childIndex = -1;\n    /** @type {Comment|Doctype|Element|Raw|Text} */ let child;\n    while(++childIndex < node.children.length){\n        child = node.children[childIndex];\n        if (child.type === \"element\") children.push($cf0d324ac74956f1$var$toReact(context, child, childIndex, node));\n        else if (child.type === \"text\") // Currently, a warning is triggered by react for *any* white space in\n        // tables.\n        // So we drop it.\n        // See: <https://github.com/facebook/react/pull/7081>.\n        // See: <https://github.com/facebook/react/pull/7515>.\n        // See: <https://github.com/remarkjs/remark-react/issues/64>.\n        // See: <https://github.com/remarkjs/react-markdown/issues/576>.\n        {\n            if (node.type !== \"element\" || !$cf0d324ac74956f1$var$tableElements.has(node.tagName) || !(0, $2h0WQ.whitespace)(child)) children.push(child.value);\n        } else if (child.type === \"raw\" && !context.options.skipHtml) // Default behavior is to show (encoded) HTML.\n        children.push(child.value);\n    }\n    return children;\n}\n/**\n * @param {Context} context\n * @param {Element} node\n * @param {number} index\n * @param {Element|Root} parent\n */ function $cf0d324ac74956f1$var$toReact(context, node, index, parent) {\n    const options = context.options;\n    const transform = options.transformLinkUri === undefined ? (0, $10YAt.uriTransformer) : options.transformLinkUri;\n    const parentSchema = context.schema;\n    /** @type {ReactMarkdownNames} */ // @ts-expect-error assume a known HTML/SVG element.\n    const name = node.tagName;\n    /** @type {Record<string, unknown>} */ const properties = {};\n    let schema = parentSchema;\n    /** @type {string} */ let property;\n    if (parentSchema.space === \"html\" && name === \"svg\") {\n        schema = (0, $aY292.svg);\n        context.schema = schema;\n    }\n    if (node.properties) {\n        for(property in node.properties)if ($cf0d324ac74956f1$var$own.call(node.properties, property)) $cf0d324ac74956f1$var$addProperty(properties, property, node.properties[property], context);\n    }\n    if (name === \"ol\" || name === \"ul\") context.listDepth++;\n    const children = $cf0d324ac74956f1$export$4b745c302603ab5d(context, node);\n    if (name === \"ol\" || name === \"ul\") context.listDepth--;\n    // Restore parent schema.\n    context.schema = parentSchema;\n    // Nodes created by plugins do not have positional info, in which case we use\n    // an object that matches the position interface.\n    const position = node.position || {\n        start: {\n            line: null,\n            column: null,\n            offset: null\n        },\n        end: {\n            line: null,\n            column: null,\n            offset: null\n        }\n    };\n    const component = options.components && $cf0d324ac74956f1$var$own.call(options.components, name) ? options.components[name] : name;\n    const basic = typeof component === \"string\" || component === (0, $3TwHq.default).Fragment;\n    if (!(0, (/*@__PURE__*/$parcel$interopDefault($5EgQh))).isValidElementType(component)) throw new TypeError(`Component for name \\`${name}\\` not defined or is not renderable`);\n    properties.key = [\n        name,\n        position.start.line,\n        position.start.column,\n        index\n    ].join(\"-\");\n    if (name === \"a\" && options.linkTarget) properties.target = typeof options.linkTarget === \"function\" ? options.linkTarget(String(properties.href || \"\"), node.children, typeof properties.title === \"string\" ? properties.title : null) : options.linkTarget;\n    if (name === \"a\" && transform) properties.href = transform(String(properties.href || \"\"), node.children, typeof properties.title === \"string\" ? properties.title : null);\n    if (!basic && name === \"code\" && parent.type === \"element\" && parent.tagName !== \"pre\") properties.inline = true;\n    if (!basic && (name === \"h1\" || name === \"h2\" || name === \"h3\" || name === \"h4\" || name === \"h5\" || name === \"h6\")) properties.level = Number.parseInt(name.charAt(1), 10);\n    if (name === \"img\" && options.transformImageUri) properties.src = options.transformImageUri(String(properties.src || \"\"), String(properties.alt || \"\"), typeof properties.title === \"string\" ? properties.title : null);\n    if (!basic && name === \"li\" && parent.type === \"element\") {\n        const input = $cf0d324ac74956f1$var$getInputElement(node);\n        properties.checked = input && input.properties ? Boolean(input.properties.checked) : null;\n        properties.index = $cf0d324ac74956f1$var$getElementsBeforeCount(parent, node);\n        properties.ordered = parent.tagName === \"ol\";\n    }\n    if (!basic && (name === \"ol\" || name === \"ul\")) {\n        properties.ordered = name === \"ol\";\n        properties.depth = context.listDepth;\n    }\n    if (name === \"td\" || name === \"th\") {\n        if (properties.align) {\n            if (!properties.style) properties.style = {};\n            // @ts-expect-error assume `style` is an object\n            properties.style.textAlign = properties.align;\n            delete properties.align;\n        }\n        if (!basic) properties.isHeader = name === \"th\";\n    }\n    if (!basic && name === \"tr\" && parent.type === \"element\") properties.isHeader = Boolean(parent.tagName === \"thead\");\n    // If `sourcePos` is given, pass source information (line/column info from markdown source).\n    if (options.sourcePos) properties[\"data-sourcepos\"] = $cf0d324ac74956f1$var$flattenPosition(position);\n    if (!basic && options.rawSourcePos) properties.sourcePosition = node.position;\n    // If `includeElementIndex` is given, pass node index info to components.\n    if (!basic && options.includeElementIndex) {\n        properties.index = $cf0d324ac74956f1$var$getElementsBeforeCount(parent, node);\n        properties.siblingCount = $cf0d324ac74956f1$var$getElementsBeforeCount(parent);\n    }\n    if (!basic) properties.node = node;\n    // Ensure no React warnings are emitted for void elements w/ children.\n    return children.length > 0 ? (0, $3TwHq.default).createElement(component, properties, children) : (0, $3TwHq.default).createElement(component, properties);\n}\n/**\n * @param {Element|Root} node\n * @returns {Element?}\n */ function $cf0d324ac74956f1$var$getInputElement(node) {\n    let index = -1;\n    while(++index < node.children.length){\n        const child = node.children[index];\n        if (child.type === \"element\" && child.tagName === \"input\") return child;\n    }\n    return null;\n}\n/**\n * @param {Element|Root} parent\n * @param {Element} [node]\n * @returns {number}\n */ function $cf0d324ac74956f1$var$getElementsBeforeCount(parent, node) {\n    let index = -1;\n    let count = 0;\n    while(++index < parent.children.length){\n        if (parent.children[index] === node) break;\n        if (parent.children[index].type === \"element\") count++;\n    }\n    return count;\n}\n/**\n * @param {Record<string, unknown>} props\n * @param {string} prop\n * @param {unknown} value\n * @param {Context} ctx\n */ function $cf0d324ac74956f1$var$addProperty(props, prop, value, ctx) {\n    const info = (0, $8e8kD.find)(ctx.schema, prop);\n    let result = value;\n    // Ignore nullish and `NaN` values.\n    // eslint-disable-next-line no-self-compare\n    if (result === null || result === undefined || result !== result) return;\n    // Accept `array`.\n    // Most props are space-separated.\n    if (Array.isArray(result)) result = info.commaSeparated ? (0, $aydpb.stringify)(result) : (0, $9LDtD.stringify)(result);\n    if (info.property === \"style\" && typeof result === \"string\") result = $cf0d324ac74956f1$var$parseStyle(result);\n    if (info.space && info.property) props[$cf0d324ac74956f1$var$own.call((0, $j3JRp.hastToReact), info.property) ? (0, $j3JRp.hastToReact)[info.property] : info.property] = result;\n    else if (info.attribute) props[info.attribute] = result;\n}\n/**\n * @param {string} value\n * @returns {Record<string, string>}\n */ function $cf0d324ac74956f1$var$parseStyle(value) {\n    /** @type {Record<string, string>} */ const result = {};\n    try {\n        (0, $aKvL7.default)(value, iterator);\n    } catch  {\n    // Silent.\n    }\n    return result;\n    /**\n   * @param {string} name\n   * @param {string} v\n   */ function iterator(name, v) {\n        const k = name.slice(0, 4) === \"-ms-\" ? `ms-${name.slice(4)}` : name;\n        result[k.replace(/-([a-z])/g, $cf0d324ac74956f1$var$styleReplacer)] = v;\n    }\n}\n/**\n * @param {unknown} _\n * @param {string} $1\n */ function $cf0d324ac74956f1$var$styleReplacer(_, $1) {\n    return $1.toUpperCase();\n}\n/**\n * @param {Position|{start: {line: null, column: null, offset: null}, end: {line: null, column: null, offset: null}}} pos\n * @returns {string}\n */ function $cf0d324ac74956f1$var$flattenPosition(pos) {\n    return [\n        pos.start.line,\n        \":\",\n        pos.start.column,\n        \"-\",\n        pos.end.line,\n        \":\",\n        pos.end.column\n    ].map(String).join(\"\");\n}\n\n});\nparcelRequire.register(\"2h0WQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"whitespace\", () => $1a7de79656976693$export$7af1228ff777d175);\n/**\n * Check if the given value is *inter-element whitespace*.\n *\n * @param {unknown} thing\n *   Thing to check (typically `Node` or `string`).\n * @returns {boolean}\n *   Whether the `value` is inter-element whitespace (`boolean`): consisting of\n *   zero or more of space, tab (`\\t`), line feed (`\\n`), carriage return\n *   (`\\r`), or form feed (`\\f`).\n *   If a node is passed it must be a `Text` node, whose `value` field is\n *   checked.\n */ function $1a7de79656976693$export$7af1228ff777d175(thing) {\n    /** @type {string} */ const value = // @ts-expect-error looks like a node.\n    thing && typeof thing === \"object\" && thing.type === \"text\" ? thing.value || \"\" : thing;\n    // HTML whitespace expression.\n    // See <https://infra.spec.whatwg.org/#ascii-whitespace>.\n    return typeof value === \"string\" && value.replace(/[ \\t\\n\\f\\r]/g, \"\") === \"\";\n}\n\n});\n\nparcelRequire.register(\"9LDtD\", function(module, exports) {\n\n$parcel$export(module.exports, \"stringify\", () => $71c7202b4e4c47aa$export$fac44ee5b035f737);\n/**\n * Parse space-separated tokens to an array of strings.\n *\n * @param {string} value\n *   Space-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */ function $71c7202b4e4c47aa$export$98e6a39c04603d36(value) {\n    const input = String(value || \"\").trim();\n    return input ? input.split(/[ \\t\\n\\r\\f]+/g) : [];\n}\nfunction $71c7202b4e4c47aa$export$fac44ee5b035f737(values) {\n    return values.join(\" \").trim();\n}\n\n});\n\nparcelRequire.register(\"aydpb\", function(module, exports) {\n\n$parcel$export(module.exports, \"stringify\", () => $7ae77a5ec40be267$export$fac44ee5b035f737);\n/**\n * @typedef Options\n *   Configuration for `stringify`.\n * @property {boolean} [padLeft=true]\n *   Whether to pad a space before a token.\n * @property {boolean} [padRight=false]\n *   Whether to pad a space after a token.\n */ /**\n * @typedef {Options} StringifyOptions\n *   Please use `StringifyOptions` instead.\n */ /**\n * Parse comma-separated tokens to an array.\n *\n * @param {string} value\n *   Comma-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */ function $7ae77a5ec40be267$export$98e6a39c04603d36(value) {\n    /** @type {Array<string>} */ const tokens = [];\n    const input = String(value || \"\");\n    let index = input.indexOf(\",\");\n    let start = 0;\n    /** @type {boolean} */ let end = false;\n    while(!end){\n        if (index === -1) {\n            index = input.length;\n            end = true;\n        }\n        const token = input.slice(start, index).trim();\n        if (token || !end) tokens.push(token);\n        start = index + 1;\n        index = input.indexOf(\",\", start);\n    }\n    return tokens;\n}\nfunction $7ae77a5ec40be267$export$fac44ee5b035f737(values, options) {\n    const settings = options || {};\n    // Ensure the last empty entry is seen.\n    const input = values[values.length - 1] === \"\" ? [\n        ...values,\n        \"\"\n    ] : values;\n    return input.join((settings.padRight ? \" \" : \"\") + \",\" + (settings.padLeft === false ? \"\" : \" \")).trim();\n}\n\n});\n\nparcelRequire.register(\"aKvL7\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $8a48ffc0108afa92$export$2e2bcd8739ae039);\n\nvar $7eE9J = parcelRequire(\"7eE9J\");\nvar $8a48ffc0108afa92$export$2e2bcd8739ae039 = (0, (/*@__PURE__*/$parcel$interopDefault($7eE9J)));\n\n});\nparcelRequire.register(\"7eE9J\", function(module, exports) {\n\nvar $c2Dp1 = parcelRequire(\"c2Dp1\");\n/**\n * Parses inline style to object.\n *\n * @example\n * // returns { 'line-height': '42' }\n * StyleToObject('line-height: 42;');\n *\n * @param  {String}      style      - The inline style.\n * @param  {Function}    [iterator] - The iterator function.\n * @return {null|Object}\n */ function $5448fd54a0960326$var$StyleToObject(style, iterator) {\n    var output = null;\n    if (!style || typeof style !== \"string\") return output;\n    var declaration;\n    var declarations = $c2Dp1(style);\n    var hasIterator = typeof iterator === \"function\";\n    var property;\n    var value;\n    for(var i = 0, len = declarations.length; i < len; i++){\n        declaration = declarations[i];\n        property = declaration.property;\n        value = declaration.value;\n        if (hasIterator) iterator(property, value, declaration);\n        else if (value) {\n            output || (output = {});\n            output[property] = value;\n        }\n    }\n    return output;\n}\nmodule.exports = $5448fd54a0960326$var$StyleToObject;\nmodule.exports.default = $5448fd54a0960326$var$StyleToObject; // ESM support\n\n});\nparcelRequire.register(\"c2Dp1\", function(module, exports) {\n// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nvar $8c443c74d39aad73$var$COMMENT_REGEX = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\nvar $8c443c74d39aad73$var$NEWLINE_REGEX = /\\n/g;\nvar $8c443c74d39aad73$var$WHITESPACE_REGEX = /^\\s*/;\n// declaration\nvar $8c443c74d39aad73$var$PROPERTY_REGEX = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/;\nvar $8c443c74d39aad73$var$COLON_REGEX = /^:\\s*/;\nvar $8c443c74d39aad73$var$VALUE_REGEX = /^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};])+)/;\nvar $8c443c74d39aad73$var$SEMICOLON_REGEX = /^[;\\s]*/;\n// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\nvar $8c443c74d39aad73$var$TRIM_REGEX = /^\\s+|\\s+$/g;\n// strings\nvar $8c443c74d39aad73$var$NEWLINE = \"\\n\";\nvar $8c443c74d39aad73$var$FORWARD_SLASH = \"/\";\nvar $8c443c74d39aad73$var$ASTERISK = \"*\";\nvar $8c443c74d39aad73$var$EMPTY_STRING = \"\";\n// types\nvar $8c443c74d39aad73$var$TYPE_COMMENT = \"comment\";\nvar $8c443c74d39aad73$var$TYPE_DECLARATION = \"declaration\";\n/**\n * @param {String} style\n * @param {Object} [options]\n * @return {Object[]}\n * @throws {TypeError}\n * @throws {Error}\n */ module.exports = function(style, options) {\n    if (typeof style !== \"string\") throw new TypeError(\"First argument must be a string\");\n    if (!style) return [];\n    options = options || {};\n    /**\n   * Positional.\n   */ var lineno = 1;\n    var column = 1;\n    /**\n   * Update lineno and column based on `str`.\n   *\n   * @param {String} str\n   */ function updatePosition(str) {\n        var lines = str.match($8c443c74d39aad73$var$NEWLINE_REGEX);\n        if (lines) lineno += lines.length;\n        var i = str.lastIndexOf($8c443c74d39aad73$var$NEWLINE);\n        column = ~i ? str.length - i : column + str.length;\n    }\n    /**\n   * Mark position and patch `node.position`.\n   *\n   * @return {Function}\n   */ function position() {\n        var start = {\n            line: lineno,\n            column: column\n        };\n        return function(node) {\n            node.position = new Position(start);\n            whitespace();\n            return node;\n        };\n    }\n    /**\n   * Store position information for a node.\n   *\n   * @constructor\n   * @property {Object} start\n   * @property {Object} end\n   * @property {undefined|String} source\n   */ function Position(start) {\n        this.start = start;\n        this.end = {\n            line: lineno,\n            column: column\n        };\n        this.source = options.source;\n    }\n    /**\n   * Non-enumerable source string.\n   */ Position.prototype.content = style;\n    var errorsList = [];\n    /**\n   * Error `msg`.\n   *\n   * @param {String} msg\n   * @throws {Error}\n   */ function error(msg) {\n        var err = new Error(options.source + \":\" + lineno + \":\" + column + \": \" + msg);\n        err.reason = msg;\n        err.filename = options.source;\n        err.line = lineno;\n        err.column = column;\n        err.source = style;\n        if (options.silent) errorsList.push(err);\n        else throw err;\n    }\n    /**\n   * Match `re` and return captures.\n   *\n   * @param {RegExp} re\n   * @return {undefined|Array}\n   */ function match(re) {\n        var m = re.exec(style);\n        if (!m) return;\n        var str = m[0];\n        updatePosition(str);\n        style = style.slice(str.length);\n        return m;\n    }\n    /**\n   * Parse whitespace.\n   */ function whitespace() {\n        match($8c443c74d39aad73$var$WHITESPACE_REGEX);\n    }\n    /**\n   * Parse comments.\n   *\n   * @param {Object[]} [rules]\n   * @return {Object[]}\n   */ function comments(rules) {\n        var c;\n        rules = rules || [];\n        while(c = comment())if (c !== false) rules.push(c);\n        return rules;\n    }\n    /**\n   * Parse comment.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */ function comment() {\n        var pos = position();\n        if ($8c443c74d39aad73$var$FORWARD_SLASH != style.charAt(0) || $8c443c74d39aad73$var$ASTERISK != style.charAt(1)) return;\n        var i = 2;\n        while($8c443c74d39aad73$var$EMPTY_STRING != style.charAt(i) && ($8c443c74d39aad73$var$ASTERISK != style.charAt(i) || $8c443c74d39aad73$var$FORWARD_SLASH != style.charAt(i + 1)))++i;\n        i += 2;\n        if ($8c443c74d39aad73$var$EMPTY_STRING === style.charAt(i - 1)) return error(\"End of comment missing\");\n        var str = style.slice(2, i - 2);\n        column += 2;\n        updatePosition(str);\n        style = style.slice(i);\n        column += 2;\n        return pos({\n            type: $8c443c74d39aad73$var$TYPE_COMMENT,\n            comment: str\n        });\n    }\n    /**\n   * Parse declaration.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */ function declaration() {\n        var pos = position();\n        // prop\n        var prop = match($8c443c74d39aad73$var$PROPERTY_REGEX);\n        if (!prop) return;\n        comment();\n        // :\n        if (!match($8c443c74d39aad73$var$COLON_REGEX)) return error(\"property missing ':'\");\n        // val\n        var val = match($8c443c74d39aad73$var$VALUE_REGEX);\n        var ret = pos({\n            type: $8c443c74d39aad73$var$TYPE_DECLARATION,\n            property: $8c443c74d39aad73$var$trim(prop[0].replace($8c443c74d39aad73$var$COMMENT_REGEX, $8c443c74d39aad73$var$EMPTY_STRING)),\n            value: val ? $8c443c74d39aad73$var$trim(val[0].replace($8c443c74d39aad73$var$COMMENT_REGEX, $8c443c74d39aad73$var$EMPTY_STRING)) : $8c443c74d39aad73$var$EMPTY_STRING\n        });\n        // ;\n        match($8c443c74d39aad73$var$SEMICOLON_REGEX);\n        return ret;\n    }\n    /**\n   * Parse declarations.\n   *\n   * @return {Object[]}\n   */ function declarations() {\n        var decls = [];\n        comments(decls);\n        // declarations\n        var decl;\n        while(decl = declaration())if (decl !== false) {\n            decls.push(decl);\n            comments(decls);\n        }\n        return decls;\n    }\n    whitespace();\n    return declarations();\n};\n/**\n * Trim `str`.\n *\n * @param {String} str\n * @return {String}\n */ function $8c443c74d39aad73$var$trim(str) {\n    return str ? str.replace($8c443c74d39aad73$var$TRIM_REGEX, $8c443c74d39aad73$var$EMPTY_STRING) : $8c443c74d39aad73$var$EMPTY_STRING;\n}\n\n});\n\n\n\nparcelRequire.register(\"10YAt\", function(module, exports) {\n\n$parcel$export(module.exports, \"uriTransformer\", () => $0bd4c9e9b9330ba0$export$b83532a10e2e268b);\nconst $0bd4c9e9b9330ba0$var$protocols = [\n    \"http\",\n    \"https\",\n    \"mailto\",\n    \"tel\"\n];\nfunction $0bd4c9e9b9330ba0$export$b83532a10e2e268b(uri) {\n    const url = (uri || \"\").trim();\n    const first = url.charAt(0);\n    if (first === \"#\" || first === \"/\") return url;\n    const colon = url.indexOf(\":\");\n    if (colon === -1) return url;\n    let index = -1;\n    while(++index < $0bd4c9e9b9330ba0$var$protocols.length){\n        const protocol = $0bd4c9e9b9330ba0$var$protocols[index];\n        if (colon === protocol.length && url.slice(0, protocol.length).toLowerCase() === protocol) return url;\n    }\n    index = url.indexOf(\"?\");\n    if (index !== -1 && colon > index) return url;\n    index = url.indexOf(\"#\");\n    if (index !== -1 && colon > index) return url;\n    // eslint-disable-next-line no-script-url\n    return \"javascript:void(0)\";\n}\n\n});\n\n\n\nparcelRequire.register(\"b6AxM\", function(module, exports) {\n\n$parcel$export(module.exports, \"posts_content\", () => $815c9a1adfb144b5$export$2b55d7630a748f79, (v) => $815c9a1adfb144b5$export$2b55d7630a748f79 = v);\n$parcel$export(module.exports, \"posts_content_code\", () => $815c9a1adfb144b5$export$e13597a754cb43a1, (v) => $815c9a1adfb144b5$export$e13597a754cb43a1 = v);\nvar $815c9a1adfb144b5$export$2b55d7630a748f79;\nvar $815c9a1adfb144b5$export$e13597a754cb43a1;\n$815c9a1adfb144b5$export$2b55d7630a748f79 = \"_postsContent-module__posts_content\";\n$815c9a1adfb144b5$export$e13597a754cb43a1 = \"_postsContent-module__posts_content_code\";\n\n});\n\n\n\n//# sourceMappingURL=postsContent.component.9600151c.js.map\n","import { useParams } from \"react-router-dom\";\nimport ReactMarkdown from \"react-markdown\";\n\nimport { useAppSelector } from \"src/app/store\";\nimport { Theme } from \"src/features/theme/theme.slice\";\nimport { Card } from \"src/common/card/card.component\";\nimport {\n  SyntaxHighlighter,\n  styleLight,\n  styleDark,\n} from \"src/utilities/syntaxHighlighter\";\n\nimport posts from \"./markdown\";\nimport styles from \"./postsContent.module.scss\";\n\nconst PostsContent = () => {\n  const { id = \"\" } = useParams<{ id: string }>();\n  const {\n    content,\n    data: { title, date },\n  } = posts[id];\n\n  const theme = useAppSelector((state) => state.theme.theme);\n\n  return (\n    <section>\n      <Card\n        primary={title}\n        secondary={<time>{new Date(date).toDateString()}</time>}\n      />\n      <ReactMarkdown\n        className={styles.posts_content}\n        children={content}\n        components={{\n          code({ inline, className, children, ...props }) {\n            const match = /language-(\\w+)/.exec(className || \"\");\n            return (\n              <SyntaxHighlighter\n                className={styles.posts_content_code}\n                children={String(children).replace(/\\n$/, \"\")}\n                language={!inline && match ? match[1] : \"text\"}\n                {...props}\n                style={theme === Theme.DARKMODE ? styleDark : styleLight}\n              />\n            );\n          },\n        }}\n      />\n    </section>\n  );\n};\n\nexport default PostsContent;\n","/**\n * @typedef {import('react').ReactNode} ReactNode\n * @typedef {import('react').ReactElement<{}>} ReactElement\n * @typedef {import('unified').PluggableList} PluggableList\n * @typedef {import('hast').Root} Root\n * @typedef {import('./rehype-filter.js').Options} FilterOptions\n * @typedef {import('./ast-to-react.js').Options} TransformOptions\n *\n * @typedef CoreOptions\n * @property {string} children\n *\n * @typedef PluginOptions\n * @property {PluggableList} [remarkPlugins=[]]\n * @property {PluggableList} [rehypePlugins=[]]\n * @property {import('remark-rehype').Options | undefined} [remarkRehypeOptions={}]\n *\n * @typedef LayoutOptions\n * @property {string} [className]\n *\n * @typedef {CoreOptions & PluginOptions & LayoutOptions & FilterOptions & TransformOptions} ReactMarkdownOptions\n *\n * @typedef Deprecation\n * @property {string} id\n * @property {string} [to]\n */\n\nimport React from 'react'\nimport {VFile} from 'vfile'\nimport {unified} from 'unified'\nimport remarkParse from 'remark-parse'\nimport remarkRehype from 'remark-rehype'\nimport PropTypes from 'prop-types'\nimport {html} from 'property-information'\nimport rehypeFilter from './rehype-filter.js'\nimport {childrenToReact} from './ast-to-react.js'\n\nconst own = {}.hasOwnProperty\nconst changelog =\n  'https://github.com/remarkjs/react-markdown/blob/main/changelog.md'\n\n/** @type {Record<string, Deprecation>} */\nconst deprecated = {\n  plugins: {to: 'remarkPlugins', id: 'change-plugins-to-remarkplugins'},\n  renderers: {to: 'components', id: 'change-renderers-to-components'},\n  astPlugins: {id: 'remove-buggy-html-in-markdown-parser'},\n  allowDangerousHtml: {id: 'remove-buggy-html-in-markdown-parser'},\n  escapeHtml: {id: 'remove-buggy-html-in-markdown-parser'},\n  source: {to: 'children', id: 'change-source-to-children'},\n  allowNode: {\n    to: 'allowElement',\n    id: 'replace-allownode-allowedtypes-and-disallowedtypes'\n  },\n  allowedTypes: {\n    to: 'allowedElements',\n    id: 'replace-allownode-allowedtypes-and-disallowedtypes'\n  },\n  disallowedTypes: {\n    to: 'disallowedElements',\n    id: 'replace-allownode-allowedtypes-and-disallowedtypes'\n  },\n  includeNodeIndex: {\n    to: 'includeElementIndex',\n    id: 'change-includenodeindex-to-includeelementindex'\n  }\n}\n\n/**\n * React component to render markdown.\n *\n * @param {ReactMarkdownOptions} options\n * @returns {ReactElement}\n */\nexport function ReactMarkdown(options) {\n  for (const key in deprecated) {\n    if (own.call(deprecated, key) && own.call(options, key)) {\n      const deprecation = deprecated[key]\n      console.warn(\n        `[react-markdown] Warning: please ${\n          deprecation.to ? `use \\`${deprecation.to}\\` instead of` : 'remove'\n        } \\`${key}\\` (see <${changelog}#${deprecation.id}> for more info)`\n      )\n      delete deprecated[key]\n    }\n  }\n\n  const processor = unified()\n    .use(remarkParse)\n    .use(options.remarkPlugins || [])\n    .use(remarkRehype, {\n      ...options.remarkRehypeOptions,\n      allowDangerousHtml: true\n    })\n    .use(options.rehypePlugins || [])\n    .use(rehypeFilter, options)\n\n  const file = new VFile()\n\n  if (typeof options.children === 'string') {\n    file.value = options.children\n  } else if (options.children !== undefined && options.children !== null) {\n    console.warn(\n      `[react-markdown] Warning: please pass a string as \\`children\\` (not: \\`${options.children}\\`)`\n    )\n  }\n\n  const hastNode = processor.runSync(processor.parse(file), file)\n\n  if (hastNode.type !== 'root') {\n    throw new TypeError('Expected a `root` node')\n  }\n\n  /** @type {ReactElement} */\n  let result = React.createElement(\n    React.Fragment,\n    {},\n    childrenToReact({options, schema: html, listDepth: 0}, hastNode)\n  )\n\n  if (options.className) {\n    result = React.createElement('div', {className: options.className}, result)\n  }\n\n  return result\n}\n\nReactMarkdown.propTypes = {\n  // Core options:\n  children: PropTypes.string,\n  // Layout options:\n  className: PropTypes.string,\n  // Filter options:\n  allowElement: PropTypes.func,\n  allowedElements: PropTypes.arrayOf(PropTypes.string),\n  disallowedElements: PropTypes.arrayOf(PropTypes.string),\n  unwrapDisallowed: PropTypes.bool,\n  // Plugin options:\n  remarkPlugins: PropTypes.arrayOf(\n    PropTypes.oneOfType([\n      PropTypes.object,\n      PropTypes.func,\n      PropTypes.arrayOf(\n        PropTypes.oneOfType([\n          PropTypes.bool,\n          PropTypes.string,\n          PropTypes.object,\n          PropTypes.func,\n          PropTypes.arrayOf(\n            // prettier-ignore\n            // type-coverage:ignore-next-line\n            PropTypes.any\n          )\n        ])\n      )\n    ])\n  ),\n  rehypePlugins: PropTypes.arrayOf(\n    PropTypes.oneOfType([\n      PropTypes.object,\n      PropTypes.func,\n      PropTypes.arrayOf(\n        PropTypes.oneOfType([\n          PropTypes.bool,\n          PropTypes.string,\n          PropTypes.object,\n          PropTypes.func,\n          PropTypes.arrayOf(\n            // prettier-ignore\n            // type-coverage:ignore-next-line\n            PropTypes.any\n          )\n        ])\n      )\n    ])\n  ),\n  // Transform options:\n  sourcePos: PropTypes.bool,\n  rawSourcePos: PropTypes.bool,\n  skipHtml: PropTypes.bool,\n  includeElementIndex: PropTypes.bool,\n  transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  transformImageUri: PropTypes.func,\n  components: PropTypes.object\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('./minurl.shared.js').URL} URL\n * @typedef {import('../index.js').Data} Data\n * @typedef {import('../index.js').Value} Value\n */\n\n/**\n * @typedef {Record<string, unknown> & {type: string, position?: Position | undefined}} NodeLike\n *\n * @typedef {'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'base64url' | 'latin1' | 'binary' | 'hex'} BufferEncoding\n *   Encodings supported by the buffer class.\n *\n *   This is a copy of the types from Node, copied to prevent Node globals from\n *   being needed.\n *   Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>\n *\n * @typedef {Options | URL | Value | VFile} Compatible\n *   Things that can be passed to the constructor.\n *\n * @typedef VFileCoreOptions\n *   Set multiple values.\n * @property {Value | null | undefined} [value]\n *   Set `value`.\n * @property {string | null | undefined} [cwd]\n *   Set `cwd`.\n * @property {Array<string> | null | undefined} [history]\n *   Set `history`.\n * @property {URL | string | null | undefined} [path]\n *   Set `path`.\n * @property {string | null | undefined} [basename]\n *   Set `basename`.\n * @property {string | null | undefined} [stem]\n *   Set `stem`.\n * @property {string | null | undefined} [extname]\n *   Set `extname`.\n * @property {string | null | undefined} [dirname]\n *   Set `dirname`.\n * @property {Data | null | undefined} [data]\n *   Set `data`.\n *\n * @typedef Map\n *   Raw source map.\n *\n *   See:\n *   <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.\n * @property {number} version\n *   Which version of the source map spec this map is following.\n * @property {Array<string>} sources\n *   An array of URLs to the original source files.\n * @property {Array<string>} names\n *   An array of identifiers which can be referenced by individual mappings.\n * @property {string | undefined} [sourceRoot]\n *   The URL root from which all sources are relative.\n * @property {Array<string> | undefined} [sourcesContent]\n *   An array of contents of the original source files.\n * @property {string} mappings\n *   A string of base64 VLQs which contain the actual mappings.\n * @property {string} file\n *   The generated file this source map is associated with.\n *\n * @typedef {{[key: string]: unknown} & VFileCoreOptions} Options\n *   Configuration.\n *\n *   A bunch of keys that will be shallow copied over to the new file.\n *\n * @typedef {Record<string, unknown>} ReporterSettings\n *   Configuration for reporters.\n */\n\n/**\n * @template {ReporterSettings} Settings\n *   Options type.\n * @callback Reporter\n *   Type for a reporter.\n * @param {Array<VFile>} files\n *   Files to report.\n * @param {Settings} options\n *   Configuration.\n * @returns {string}\n *   Report.\n */\n\nimport bufferLike from 'is-buffer'\nimport {VFileMessage} from 'vfile-message'\nimport {path} from './minpath.js'\nimport {proc} from './minproc.js'\nimport {urlToPath, isUrl} from './minurl.js'\n\n/**\n * Order of setting (least specific to most), we need this because otherwise\n * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n * stem can be set.\n *\n * @type {Array<'basename' | 'dirname' | 'extname' | 'history' | 'path' | 'stem'>}\n */\nconst order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']\n\nexport class VFile {\n  /**\n   * Create a new virtual file.\n   *\n   * `options` is treated as:\n   *\n   * *   `string` or `Buffer`  `{value: options}`\n   * *   `URL`  `{path: options}`\n   * *   `VFile`  shallow copies its data over to the new file\n   * *   `object`  all fields are shallow copied over to the new file\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * You cannot set `dirname` or `extname` without setting either `history`,\n   * `path`, `basename`, or `stem` too.\n   *\n   * @param {Compatible | null | undefined} [value]\n   *   File value.\n   * @returns\n   *   New instance.\n   */\n  constructor(value) {\n    /** @type {Options | VFile} */\n    let options\n\n    if (!value) {\n      options = {}\n    } else if (typeof value === 'string' || buffer(value)) {\n      options = {value}\n    } else if (isUrl(value)) {\n      options = {path: value}\n    } else {\n      options = value\n    }\n\n    /**\n     * Place to store custom information (default: `{}`).\n     *\n     * Its OK to store custom data directly on the file but moving it to\n     * `data` is recommended.\n     *\n     * @type {Data}\n     */\n    this.data = {}\n\n    /**\n     * List of messages associated with the file.\n     *\n     * @type {Array<VFileMessage>}\n     */\n    this.messages = []\n\n    /**\n     * List of filepaths the file moved between.\n     *\n     * The first is the original path and the last is the current path.\n     *\n     * @type {Array<string>}\n     */\n    this.history = []\n\n    /**\n     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).\n     *\n     * @type {string}\n     */\n    this.cwd = proc.cwd()\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * Raw value.\n     *\n     * @type {Value}\n     */\n    this.value\n\n    // The below are non-standard, they are well-known.\n    // As in, used in several tools.\n\n    /**\n     * Whether a file was saved to disk.\n     *\n     * This is used by vfile reporters.\n     *\n     * @type {boolean}\n     */\n    this.stored\n\n    /**\n     * Custom, non-string, compiled, representation.\n     *\n     * This is used by unified to store non-string results.\n     * One example is when turning markdown into React nodes.\n     *\n     * @type {unknown}\n     */\n    this.result\n\n    /**\n     * Source map.\n     *\n     * This type is equivalent to the `RawSourceMap` type from the `source-map`\n     * module.\n     *\n     * @type {Map | null | undefined}\n     */\n    this.map\n    /* eslint-enable no-unused-expressions */\n\n    // Set path related properties in the correct order.\n    let index = -1\n\n    while (++index < order.length) {\n      const prop = order[index]\n\n      // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n      // `vfile`s too.\n      if (\n        prop in options &&\n        options[prop] !== undefined &&\n        options[prop] !== null\n      ) {\n        // @ts-expect-error: TS doesnt understand basic reality.\n        this[prop] = prop === 'history' ? [...options[prop]] : options[prop]\n      }\n    }\n\n    /** @type {string} */\n    let prop\n\n    // Set non-path related properties.\n    for (prop in options) {\n      // @ts-expect-error: fine to set other things.\n      if (!order.includes(prop)) {\n        // @ts-expect-error: fine to set other things.\n        this[prop] = options[prop]\n      }\n    }\n  }\n\n  /**\n   * Get the full path (example: `'~/index.min.js'`).\n   *\n   * @returns {string}\n   */\n  get path() {\n    return this.history[this.history.length - 1]\n  }\n\n  /**\n   * Set the full path (example: `'~/index.min.js'`).\n   *\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   *\n   * @param {string | URL} path\n   */\n  set path(path) {\n    if (isUrl(path)) {\n      path = urlToPath(path)\n    }\n\n    assertNonEmpty(path, 'path')\n\n    if (this.path !== path) {\n      this.history.push(path)\n    }\n  }\n\n  /**\n   * Get the parent path (example: `'~'`).\n   */\n  get dirname() {\n    return typeof this.path === 'string' ? path.dirname(this.path) : undefined\n  }\n\n  /**\n   * Set the parent path (example: `'~'`).\n   *\n   * Cannot be set if theres no `path` yet.\n   */\n  set dirname(dirname) {\n    assertPath(this.basename, 'dirname')\n    this.path = path.join(dirname || '', this.basename)\n  }\n\n  /**\n   * Get the basename (including extname) (example: `'index.min.js'`).\n   */\n  get basename() {\n    return typeof this.path === 'string' ? path.basename(this.path) : undefined\n  }\n\n  /**\n   * Set basename (including extname) (`'index.min.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set basename(basename) {\n    assertNonEmpty(basename, 'basename')\n    assertPart(basename, 'basename')\n    this.path = path.join(this.dirname || '', basename)\n  }\n\n  /**\n   * Get the extname (including dot) (example: `'.js'`).\n   */\n  get extname() {\n    return typeof this.path === 'string' ? path.extname(this.path) : undefined\n  }\n\n  /**\n   * Set the extname (including dot) (example: `'.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be set if theres no `path` yet.\n   */\n  set extname(extname) {\n    assertPart(extname, 'extname')\n    assertPath(this.dirname, 'extname')\n\n    if (extname) {\n      if (extname.charCodeAt(0) !== 46 /* `.` */) {\n        throw new Error('`extname` must start with `.`')\n      }\n\n      if (extname.includes('.', 1)) {\n        throw new Error('`extname` cannot contain multiple dots')\n      }\n    }\n\n    this.path = path.join(this.dirname, this.stem + (extname || ''))\n  }\n\n  /**\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\n   */\n  get stem() {\n    return typeof this.path === 'string'\n      ? path.basename(this.path, this.extname)\n      : undefined\n  }\n\n  /**\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set stem(stem) {\n    assertNonEmpty(stem, 'stem')\n    assertPart(stem, 'stem')\n    this.path = path.join(this.dirname || '', stem + (this.extname || ''))\n  }\n\n  /**\n   * Serialize the file.\n   *\n   * @param {BufferEncoding | null | undefined} [encoding='utf8']\n   *   Character encoding to understand `value` as when its a `Buffer`\n   *   (default: `'utf8'`).\n   * @returns {string}\n   *   Serialized file.\n   */\n  toString(encoding) {\n    return (this.value || '').toString(encoding || undefined)\n  }\n\n  /**\n   * Create a warning message associated with the file.\n   *\n   * Its `fatal` is set to `false` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  message(reason, place, origin) {\n    const message = new VFileMessage(reason, place, origin)\n\n    if (this.path) {\n      message.name = this.path + ':' + message.name\n      message.file = this.path\n    }\n\n    message.fatal = false\n\n    this.messages.push(message)\n\n    return message\n  }\n\n  /**\n   * Create an info message associated with the file.\n   *\n   * Its `fatal` is set to `null` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  info(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = null\n\n    return message\n  }\n\n  /**\n   * Create a fatal error associated with the file.\n   *\n   * Its `fatal` is set to `true` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * >  **Note**: a fatal error means that a file is no longer processable.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {never}\n   *   Message.\n   * @throws {VFileMessage}\n   *   Message.\n   */\n  fail(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = true\n\n    throw message\n  }\n}\n\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string | null | undefined} part\n *   File path part.\n * @param {string} name\n *   Part name.\n * @returns {void}\n *   Nothing.\n */\nfunction assertPart(part, name) {\n  if (part && part.includes(path.sep)) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + path.sep + '`'\n    )\n  }\n}\n\n/**\n * Assert that `part` is not empty.\n *\n * @param {string | undefined} part\n *   Thing.\n * @param {string} name\n *   Part name.\n * @returns {asserts part is string}\n *   Nothing.\n */\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n/**\n * Assert `path` exists.\n *\n * @param {string | undefined} path\n *   Path.\n * @param {string} name\n *   Dependency name.\n * @returns {asserts path is string}\n *   Nothing.\n */\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n\n/**\n * Assert `value` is a buffer.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Buffer}\n *   Whether `value` is a Node.js buffer.\n */\nfunction buffer(value) {\n  return bufferLike(value)\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {object & {type: string, position?: Position | undefined}} NodeLike\n */\n\nimport {stringifyPosition} from 'unist-util-stringify-position'\n\n/**\n * Message.\n */\nexport class VFileMessage extends Error {\n  /**\n   * Create a message for `reason` at `place` from `origin`.\n   *\n   * When an error is passed in as `reason`, the `stack` is copied.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   *\n   *   >  **Note**: you should use markdown.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns\n   *   Instance of `VFileMessage`.\n   */\n  // To do: next major: expose `undefined` everywhere instead of `null`.\n  constructor(reason, place, origin) {\n    /** @type {[string | null, string | null]} */\n    const parts = [null, null]\n    /** @type {Position} */\n    let position = {\n      // @ts-expect-error: we always follows the structure of `position`.\n      start: {line: null, column: null},\n      // @ts-expect-error: \"\n      end: {line: null, column: null}\n    }\n\n    super()\n\n    if (typeof place === 'string') {\n      origin = place\n      place = undefined\n    }\n\n    if (typeof origin === 'string') {\n      const index = origin.indexOf(':')\n\n      if (index === -1) {\n        parts[1] = origin\n      } else {\n        parts[0] = origin.slice(0, index)\n        parts[1] = origin.slice(index + 1)\n      }\n    }\n\n    if (place) {\n      // Node.\n      if ('type' in place || 'position' in place) {\n        if (place.position) {\n          // To do: next major: deep clone.\n          // @ts-expect-error: looks like a position.\n          position = place.position\n        }\n      }\n      // Position.\n      else if ('start' in place || 'end' in place) {\n        // @ts-expect-error: looks like a position.\n        // To do: next major: deep clone.\n        position = place\n      }\n      // Point.\n      else if ('line' in place || 'column' in place) {\n        // To do: next major: deep clone.\n        position.start = place\n      }\n    }\n\n    // Fields from `Error`.\n    /**\n     * Serialized positional info of error.\n     *\n     * On normal errors, this would be something like `ParseError`, buit in\n     * `VFile` messages we use this space to show where an error happened.\n     */\n    this.name = stringifyPosition(place) || '1:1'\n\n    /**\n     * Reason for message.\n     *\n     * @type {string}\n     */\n    this.message = typeof reason === 'object' ? reason.message : reason\n\n    /**\n     * Stack of message.\n     *\n     * This is used by normal errors to show where something happened in\n     * programming code, irrelevant for `VFile` messages,\n     *\n     * @type {string}\n     */\n    this.stack = ''\n\n    if (typeof reason === 'object' && reason.stack) {\n      this.stack = reason.stack\n    }\n\n    /**\n     * Reason for message.\n     *\n     * >  **Note**: you should use markdown.\n     *\n     * @type {string}\n     */\n    this.reason = this.message\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * State of problem.\n     *\n     * * `true`  marks associated file as no longer processable (error)\n     * * `false`  necessitates a (potential) change (warning)\n     * * `null | undefined`  for things that might not need changing (info)\n     *\n     * @type {boolean | null | undefined}\n     */\n    this.fatal\n\n    /**\n     * Starting line of error.\n     *\n     * @type {number | null}\n     */\n    this.line = position.start.line\n\n    /**\n     * Starting column of error.\n     *\n     * @type {number | null}\n     */\n    this.column = position.start.column\n\n    /**\n     * Full unist position.\n     *\n     * @type {Position | null}\n     */\n    this.position = position\n\n    /**\n     * Namespace of message (example: `'my-package'`).\n     *\n     * @type {string | null}\n     */\n    this.source = parts[0]\n\n    /**\n     * Category of message (example: `'my-rule'`).\n     *\n     * @type {string | null}\n     */\n    this.ruleId = parts[1]\n\n    /**\n     * Path of a file (used throughout the `VFile` ecosystem).\n     *\n     * @type {string | null}\n     */\n    this.file\n\n    // The following fields are well known.\n    // Not standard.\n    // Feel free to add other non-standard fields to your messages.\n\n    /**\n     * Specify the source value thats being reported, which is deemed\n     * incorrect.\n     *\n     * @type {string | null}\n     */\n    this.actual\n\n    /**\n     * Suggest acceptable values that can be used instead of `actual`.\n     *\n     * @type {Array<string> | null}\n     */\n    this.expected\n\n    /**\n     * Link to docs for the message.\n     *\n     * >  **Note**: this must be an absolute URL that can be passed as `x`\n     * > to `new URL(x)`.\n     *\n     * @type {string | null}\n     */\n    this.url\n\n    /**\n     * Long form description of the message (you should use markdown).\n     *\n     * @type {string | null}\n     */\n    this.note\n    /* eslint-enable no-unused-expressions */\n  }\n}\n\nVFileMessage.prototype.file = ''\nVFileMessage.prototype.name = ''\nVFileMessage.prototype.reason = ''\nVFileMessage.prototype.message = ''\nVFileMessage.prototype.stack = ''\nVFileMessage.prototype.fatal = null\nVFileMessage.prototype.column = null\nVFileMessage.prototype.line = null\nVFileMessage.prototype.source = null\nVFileMessage.prototype.ruleId = null\nVFileMessage.prototype.position = null\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Serialize the positional info of a point, position (start and end points),\n * or node.\n *\n * @param {Node | NodeLike | Position | PositionLike | Point | PointLike | null | undefined} [value]\n *   Node, position, or point.\n * @returns {string}\n *   Pretty printed positional info of a node (`string`).\n *\n *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)\n *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for\n *   column, `s` for `start`, and `e` for end.\n *   An empty string (`''`) is returned if the given value is neither `node`,\n *   `position`, nor `point`.\n */\nexport function stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if ('position' in value || 'type' in value) {\n    return position(value.position)\n  }\n\n  // Position.\n  if ('start' in value || 'end' in value) {\n    return position(value)\n  }\n\n  // Point.\n  if ('line' in value || 'column' in value) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\n/**\n * @param {Point | PointLike | null | undefined} point\n * @returns {string}\n */\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column)\n}\n\n/**\n * @param {Position | PositionLike | null | undefined} pos\n * @returns {string}\n */\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end)\n}\n\n/**\n * @param {number | null | undefined} value\n * @returns {number}\n */\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n","// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Nodes internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexport const path = {basename, dirname, extname, join, sep: '/'}\n\n/* eslint-disable max-depth, complexity */\n\n/**\n * Get the basename from a path.\n *\n * @param {string} path\n *   File path.\n * @param {string | undefined} [ext]\n *   Extension to strip.\n * @returns {string}\n *   Stem or basename.\n */\nfunction basename(path, ext) {\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string')\n  }\n\n  assertPath(path)\n  let start = 0\n  let end = -1\n  let index = path.length\n  /** @type {boolean | undefined} */\n  let seenNonSlash\n\n  if (ext === undefined || ext.length === 0 || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1\n          break\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true\n        end = index + 1\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end)\n  }\n\n  if (ext === path) {\n    return ''\n  }\n\n  let firstNonSlashEnd = -1\n  let extIndex = ext.length - 1\n\n  while (index--) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1\n        break\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true\n        firstNonSlashEnd = index + 1\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1\n          end = firstNonSlashEnd\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd\n  } else if (end < 0) {\n    end = path.length\n  }\n\n  return path.slice(start, end)\n}\n\n/**\n * Get the dirname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\nfunction dirname(path) {\n  assertPath(path)\n\n  if (path.length === 0) {\n    return '.'\n  }\n\n  let end = -1\n  let index = path.length\n  /** @type {boolean | undefined} */\n  let unmatchedSlash\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index\n        break\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true\n    }\n  }\n\n  return end < 0\n    ? path.charCodeAt(0) === 47 /* `/` */\n      ? '/'\n      : '.'\n    : end === 1 && path.charCodeAt(0) === 47 /* `/` */\n    ? '//'\n    : path.slice(0, end)\n}\n\n/**\n * Get an extname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   Extname.\n */\nfunction extname(path) {\n  assertPath(path)\n\n  let index = path.length\n\n  let end = -1\n  let startPart = 0\n  let startDot = -1\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  let preDotState = 0\n  /** @type {boolean | undefined} */\n  let unmatchedSlash\n\n  while (index--) {\n    const code = path.charCodeAt(index)\n\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1\n        break\n      }\n\n      continue\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true\n      end = index + 1\n    }\n\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index\n      } else if (preDotState !== 1) {\n        preDotState = 1\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1\n    }\n  }\n\n  if (\n    startDot < 0 ||\n    end < 0 ||\n    // We saw a non-dot character immediately before the dot.\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly `..`.\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return ''\n  }\n\n  return path.slice(startDot, end)\n}\n\n/**\n * Join segments from a path.\n *\n * @param {Array<string>} segments\n *   Path segments.\n * @returns {string}\n *   File path.\n */\nfunction join(...segments) {\n  let index = -1\n  /** @type {string | undefined} */\n  let joined\n\n  while (++index < segments.length) {\n    assertPath(segments[index])\n\n    if (segments[index]) {\n      joined =\n        joined === undefined ? segments[index] : joined + '/' + segments[index]\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined)\n}\n\n/**\n * Normalize a basic file path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\n// Note: `normalize` is not exposed as `path.normalize`, so some code is\n// manually removed from it.\nfunction normalize(path) {\n  assertPath(path)\n\n  const absolute = path.charCodeAt(0) === 47 /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  let value = normalizeString(path, !absolute)\n\n  if (value.length === 0 && !absolute) {\n    value = '.'\n  }\n\n  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47 /* / */) {\n    value += '/'\n  }\n\n  return absolute ? '/' + value : value\n}\n\n/**\n * Resolve `.` and `..` elements in a path with directory names.\n *\n * @param {string} path\n *   File path.\n * @param {boolean} allowAboveRoot\n *   Whether `..` can move above root.\n * @returns {string}\n *   File path.\n */\nfunction normalizeString(path, allowAboveRoot) {\n  let result = ''\n  let lastSegmentLength = 0\n  let lastSlash = -1\n  let dots = 0\n  let index = -1\n  /** @type {number | undefined} */\n  let code\n  /** @type {number} */\n  let lastSlashIndex\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index)\n    } else if (code === 47 /* `/` */) {\n      break\n    } else {\n      code = 47 /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (\n          result.length < 2 ||\n          lastSegmentLength !== 2 ||\n          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||\n          result.charCodeAt(result.length - 2) !== 46 /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/')\n\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = ''\n                lastSegmentLength = 0\n              } else {\n                result = result.slice(0, lastSlashIndex)\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\n              }\n\n              lastSlash = index\n              dots = 0\n              continue\n            }\n          } else if (result.length > 0) {\n            result = ''\n            lastSegmentLength = 0\n            lastSlash = index\n            dots = 0\n            continue\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length > 0 ? result + '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (result.length > 0) {\n          result += '/' + path.slice(lastSlash + 1, index)\n        } else {\n          result = path.slice(lastSlash + 1, index)\n        }\n\n        lastSegmentLength = index - lastSlash - 1\n      }\n\n      lastSlash = index\n      dots = 0\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++\n    } else {\n      dots = -1\n    }\n  }\n\n  return result\n}\n\n/**\n * Make sure `path` is a string.\n *\n * @param {string} path\n *   File path.\n * @returns {asserts path is string}\n *   Nothing.\n */\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\n      'Path must be a string. Received ' + JSON.stringify(path)\n    )\n  }\n}\n\n/* eslint-enable max-depth, complexity */\n","// Somewhat based on:\n// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.\n// But I dont think one tiny line of code can be copyrighted. \nexport const proc = {cwd}\n\nfunction cwd() {\n  return '/'\n}\n","/// <reference lib=\"dom\" />\n\nimport {isUrl} from './minurl.shared.js'\n\n// See: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js>\n\n/**\n * @param {string | URL} path\n *   File URL.\n * @returns {string}\n *   File URL.\n */\nexport function urlToPath(path) {\n  if (typeof path === 'string') {\n    path = new URL(path)\n  } else if (!isUrl(path)) {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'The \"path\" argument must be of type string or an instance of URL. Received `' +\n        path +\n        '`'\n    )\n    error.code = 'ERR_INVALID_ARG_TYPE'\n    throw error\n  }\n\n  if (path.protocol !== 'file:') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError('The URL must be of scheme file')\n    error.code = 'ERR_INVALID_URL_SCHEME'\n    throw error\n  }\n\n  return getPathFromURLPosix(path)\n}\n\n/**\n * Get a path from a POSIX URL.\n *\n * @param {URL} url\n *   URL.\n * @returns {string}\n *   File path.\n */\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'File URL host must be \"localhost\" or empty on darwin'\n    )\n    error.code = 'ERR_INVALID_FILE_URL_HOST'\n    throw error\n  }\n\n  const pathname = url.pathname\n  let index = -1\n\n  while (++index < pathname.length) {\n    if (\n      pathname.charCodeAt(index) === 37 /* `%` */ &&\n      pathname.charCodeAt(index + 1) === 50 /* `2` */\n    ) {\n      const third = pathname.charCodeAt(index + 2)\n      if (third === 70 /* `F` */ || third === 102 /* `f` */) {\n        /** @type {NodeJS.ErrnoException} */\n        const error = new TypeError(\n          'File URL path must not include encoded / characters'\n        )\n        error.code = 'ERR_INVALID_FILE_URL_PATH'\n        throw error\n      }\n    }\n  }\n\n  return decodeURIComponent(pathname)\n}\n\nexport {isUrl} from './minurl.shared.js'\n","/**\n * @typedef URL\n * @property {string} hash\n * @property {string} host\n * @property {string} hostname\n * @property {string} href\n * @property {string} origin\n * @property {string} password\n * @property {string} pathname\n * @property {string} port\n * @property {string} protocol\n * @property {string} search\n * @property {any} searchParams\n * @property {string} username\n * @property {() => string} toString\n * @property {() => string} toJSON\n */\n\n/**\n * Check if `fileUrlOrPath` looks like a URL.\n *\n * @param {unknown} fileUrlOrPath\n *   File path or URL.\n * @returns {fileUrlOrPath is URL}\n *   Whether its a URL.\n */\n// From: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js#L1501>\nexport function isUrl(fileUrlOrPath) {\n  return (\n    fileUrlOrPath !== null &&\n    typeof fileUrlOrPath === 'object' &&\n    // @ts-expect-error: indexable.\n    fileUrlOrPath.href &&\n    // @ts-expect-error: indexable.\n    fileUrlOrPath.origin\n  )\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */\n\nimport {bail} from 'bail'\nimport isBuffer from 'is-buffer'\nimport extend from 'extend'\nimport isPlainObj from 'is-plain-obj'\nimport {trough} from 'trough'\nimport {VFile} from 'vfile'\n\n// Expose a frozen processor.\nexport const unified = base().freeze()\n\nconst own = {}.hasOwnProperty\n\n// Function to create the first processor.\n/**\n * @returns {Processor}\n */\nfunction base() {\n  const transformers = trough()\n  /** @type {Processor['attachers']} */\n  const attachers = []\n  /** @type {Record<string, unknown>} */\n  let namespace = {}\n  /** @type {boolean|undefined} */\n  let frozen\n  let freezeIndex = -1\n\n  // Data management.\n  // @ts-expect-error: overloads are handled.\n  processor.data = data\n  processor.Parser = undefined\n  processor.Compiler = undefined\n\n  // Lock.\n  processor.freeze = freeze\n\n  // Plugins.\n  processor.attachers = attachers\n  // @ts-expect-error: overloads are handled.\n  processor.use = use\n\n  // API.\n  processor.parse = parse\n  processor.stringify = stringify\n  // @ts-expect-error: overloads are handled.\n  processor.run = run\n  processor.runSync = runSync\n  // @ts-expect-error: overloads are handled.\n  processor.process = process\n  processor.processSync = processSync\n\n  // Expose.\n  return processor\n\n  // Create a new processor based on the processor in the current scope.\n  /** @type {Processor} */\n  function processor() {\n    const destination = base()\n    let index = -1\n\n    while (++index < attachers.length) {\n      destination.use(...attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n        namespace[key] = value\n        return processor\n      }\n\n      // Get `key`.\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    // Get space.\n    return namespace\n  }\n\n  /** @type {Processor['freeze']} */\n  function freeze() {\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      const [attacher, ...options] = attachers[freezeIndex]\n\n      if (options[0] === false) {\n        continue\n      }\n\n      if (options[0] === true) {\n        options[0] = undefined\n      }\n\n      /** @type {Transformer|void} */\n      const transformer = attacher.call(processor, ...options)\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Number.POSITIVE_INFINITY\n\n    return processor\n  }\n\n  /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */\n  function use(value, ...options) {\n    /** @type {Record<string, unknown>|undefined} */\n    let settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, ...options)\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = Object.assign(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...options] = value\n          addPlugin(plugin, ...options)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    /**\n     * @param {Preset} result\n     * @returns {void}\n     */\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = Object.assign(settings || {}, result.settings)\n      }\n    }\n\n    /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */\n    function addList(plugins) {\n      let index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index]\n          add(thing)\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */\n    function addPlugin(plugin, value) {\n      let index = -1\n      /** @type {Processor['attachers'][number]|undefined} */\n      let entry\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entry = attachers[index]\n          break\n        }\n      }\n\n      if (entry) {\n        if (isPlainObj(entry[1]) && isPlainObj(value)) {\n          value = extend(true, entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        // @ts-expect-error: fine.\n        attachers.push([...arguments])\n      }\n    }\n  }\n\n  /** @type {Processor['parse']} */\n  function parse(doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser, 'parse')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Parser(String(file), file).parse()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  /** @type {Processor['stringify']} */\n  function stringify(node, doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler, 'compile')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Compiler(node, file).compile()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */\n  function run(node, doc, callback) {\n    assertNode(node)\n    processor.freeze()\n\n    if (!callback && typeof doc === 'function') {\n      callback = doc\n      doc = undefined\n    }\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      // @ts-expect-error: `doc` cant be a callback anymore, we checked.\n      transformers.run(node, vfile(doc), done)\n\n      /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */\n      function done(error, tree, file) {\n        tree = tree || node\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, tree, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['runSync']} */\n  function runSync(node, file) {\n    /** @type {Node|undefined} */\n    let result\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    // @ts-expect-error: we either bailed on an error or have a tree.\n    return result\n\n    /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */\n    function done(error, tree) {\n      bail(error)\n      result = tree\n      complete = true\n    }\n  }\n\n  /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */\n  function process(doc, callback) {\n    processor.freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      const file = vfile(doc)\n\n      processor.run(processor.parse(file), file, (error, tree, file) => {\n        if (error || !tree || !file) {\n          done(error)\n        } else {\n          /** @type {unknown} */\n          const result = processor.stringify(tree, file)\n\n          if (result === undefined || result === null) {\n            // Empty.\n          } else if (looksLikeAVFileValue(result)) {\n            file.value = result\n          } else {\n            file.result = result\n          }\n\n          done(error, file)\n        }\n      })\n\n      /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */\n      function done(error, file) {\n        if (error || !file) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['processSync']} */\n  function processSync(doc) {\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n\n    const file = vfile(doc)\n\n    processor.process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */\n    function done(error) {\n      complete = true\n      bail(error)\n    }\n  }\n}\n\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */\nfunction newable(value, name) {\n  return (\n    typeof value === 'function' &&\n    // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    value.prototype &&\n    // A function with keys in its prototype is probably a constructor.\n    // Classes prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    // type-coverage:ignore-next-line\n    (keys(value.prototype) || name in value.prototype)\n  )\n}\n\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */\nfunction keys(value) {\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot call `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`')\n    // Fine.\n  }\n}\n\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value)\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'message' in value &&\n      'messages' in value\n  )\n}\n\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */\nfunction looksLikeAVFileValue(value) {\n  return typeof value === 'string' || isBuffer(value)\n}\n","/**\n * Throw a given error.\n *\n * @param {Error|null|undefined} [error]\n *   Maybe error.\n * @returns {asserts error is null|undefined}\n */\nexport function bail(error) {\n  if (error) {\n    throw error\n  }\n}\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n","/**\n * @typedef {(error?: Error|null|undefined, ...output: Array<any>) => void} Callback\n * @typedef {(...input: Array<any>) => any} Middleware\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add `fn` (middleware) to the list.\n * @typedef {{run: Run, use: Use}} Pipeline\n *   Middleware.\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n */\nexport function trough() {\n  /** @type {Array<Middleware>} */\n  const fns = []\n  /** @type {Pipeline} */\n  const pipeline = {run, use}\n\n  return pipeline\n\n  /** @type {Run} */\n  function run(...values) {\n    let middlewareIndex = -1\n    /** @type {Callback} */\n    const callback = values.pop()\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback)\n    }\n\n    next(null, ...values)\n\n    /**\n     * Run the next `fn`, or were done.\n     *\n     * @param {Error|null|undefined} error\n     * @param {Array<any>} output\n     */\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex]\n      let index = -1\n\n      if (error) {\n        callback(error)\n        return\n      }\n\n      // Copy non-nullish input into values.\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index]\n        }\n      }\n\n      // Save the newly created `output` for the next call.\n      values = output\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next)(...output)\n      } else {\n        callback(null, ...output)\n      }\n    }\n  }\n\n  /** @type {Use} */\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError(\n        'Expected `middelware` to be a function, not ' + middelware\n      )\n    }\n\n    fns.push(middelware)\n    return pipeline\n  }\n}\n\n/**\n * Wrap `middleware`.\n * Can be sync or async; return a promise, receive a callback, or return new\n * values and errors.\n *\n * @param {Middleware} middleware\n * @param {Callback} callback\n */\nexport function wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called\n\n  return wrapped\n\n  /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length\n    /** @type {any} */\n    let result\n\n    if (fnExpectsCallback) {\n      parameters.push(done)\n    }\n\n    try {\n      result = middleware.apply(this, parameters)\n    } catch (error) {\n      const exception = /** @type {Error} */ (error)\n\n      // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n      if (fnExpectsCallback && called) {\n        throw exception\n      }\n\n      return done(exception)\n    }\n\n    if (!fnExpectsCallback) {\n      if (result instanceof Promise) {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /**\n   * Call `callback`, only once.\n   * @type {Callback}\n   */\n  function done(error, ...output) {\n    if (!called) {\n      called = true\n      callback(error, ...output)\n    }\n  }\n\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n  function then(value) {\n    done(null, value)\n  }\n}\n","import remarkParse from './lib/index.js'\n\nexport default remarkParse\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-from-markdown').Options} Options\n */\n\nimport {fromMarkdown} from 'mdast-util-from-markdown'\n\n/** @type {import('unified').Plugin<[Options?] | void[], string, Root>} */\nexport default function remarkParse(options) {\n  /** @type {import('unified').ParserFunction<Root>} */\n  const parser = (doc) => {\n    // Assume options.\n    const settings = /** @type {Options} */ (this.data('settings'))\n\n    return fromMarkdown(\n      doc,\n      Object.assign({}, settings, options, {\n        // Note: these options are not in the readme.\n        // The goal is for them to be set by plugins on `data` instead of being\n        // passed by users.\n        extensions: this.data('micromarkExtensions') || [],\n        mdastExtensions: this.data('fromMarkdownExtensions') || []\n      })\n    )\n  }\n\n  Object.assign(this, {Parser: parser})\n}\n","/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('../index.js').CompileData} CompileData\n */\n\n/**\n * @typedef {Root | Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n *\n * @typedef {Omit<UnistParent, 'type' | 'children'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */\n\n/**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | undefined | null | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isnt closed properly.\n */\n\n/**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Node | Fragment>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {<Key extends keyof CompileData>(key: Key) => CompileData[Key]} getData\n *   Get data from the key/value store.\n * @property {<Key extends keyof CompileData>(key: Key, value?: CompileData[Key]) => void} setData\n *   Set data into the key/value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<Kind extends Node>(this: CompileContext, node: Kind, token: Token, onError?: OnEnterError) => Kind} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */\n\n// To do: micromark: create a registry of tokens?\n// To do: next major: dont return given `Node` from `enter`.\n// To do: next major: remove setter/getter.\n\nimport {toString} from 'mdast-util-to-string'\nimport {parse} from 'micromark/lib/parse.js'\nimport {preprocess} from 'micromark/lib/preprocess.js'\nimport {postprocess} from 'micromark/lib/postprocess.js'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {decodeString} from 'micromark-util-decode-string'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nconst own = {}.hasOwnProperty\n\n/**\n * @param value\n *   Markdown to parse.\n * @param encoding\n *   Character encoding for when `value` is `Buffer`.\n * @param options\n *   Configuration.\n * @returns\n *   mdast tree.\n */\nexport const fromMarkdown =\n  /**\n   * @type {(\n   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &\n   *   ((value: Value, options?: Options | null | undefined) => Root)\n   * )}\n   */\n\n  /**\n   * @param {Value} value\n   * @param {Encoding | Options | null | undefined} [encoding]\n   * @param {Options | null | undefined} [options]\n   * @returns {Root}\n   */\n  function (value, encoding, options) {\n    if (typeof encoding !== 'string') {\n      options = encoding\n      encoding = undefined\n    }\n    return compiler(options)(\n      postprocess(\n        // @ts-expect-error: micromark types need to accept `null`.\n        parse(options).document().write(preprocess()(value, encoding, true))\n      )\n    )\n  }\n\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  }\n  configure(config, (options || {}).mdastExtensions || [])\n\n  /** @type {CompileData} */\n  const data = {}\n  return compile\n\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    }\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      setData,\n      getData\n    }\n    /** @type {Array<number>} */\n    const listStack = []\n    let index = -1\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (\n        events[index][1].type === 'listOrdered' ||\n        events[index][1].type === 'listUnordered'\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          const tail = listStack.pop()\n          index = prepareList(events, tail, index)\n        }\n      }\n    }\n    index = -1\n    while (++index < events.length) {\n      const handler = config[events[index][0]]\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(\n          Object.assign(\n            {\n              sliceSerialize: events[index][2].sliceSerialize\n            },\n            context\n          ),\n          events[index][1]\n        )\n      }\n    }\n\n    // Handle tokens still being open.\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1]\n      const handler = tail[1] || defaultOnError\n      handler.call(context, undefined, tail[0])\n    }\n\n    // Figure out `root` position.\n    tree.position = {\n      start: point(\n        events.length > 0\n          ? events[0][1].start\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      ),\n      end: point(\n        events.length > 0\n          ? events[events.length - 2][1].end\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      )\n    }\n\n    // Call transforms.\n    index = -1\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree\n    }\n    return tree\n  }\n\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n  function prepareList(events, start, length) {\n    let index = start - 1\n    let containerBalance = -1\n    let listSpread = false\n    /** @type {Token | undefined} */\n    let listItem\n    /** @type {number | undefined} */\n    let lineIndex\n    /** @type {number | undefined} */\n    let firstBlankLineIndex\n    /** @type {boolean | undefined} */\n    let atMarker\n    while (++index <= length) {\n      const event = events[index]\n      if (\n        event[1].type === 'listUnordered' ||\n        event[1].type === 'listOrdered' ||\n        event[1].type === 'blockQuote'\n      ) {\n        if (event[0] === 'enter') {\n          containerBalance++\n        } else {\n          containerBalance--\n        }\n        atMarker = undefined\n      } else if (event[1].type === 'lineEndingBlank') {\n        if (event[0] === 'enter') {\n          if (\n            listItem &&\n            !atMarker &&\n            !containerBalance &&\n            !firstBlankLineIndex\n          ) {\n            firstBlankLineIndex = index\n          }\n          atMarker = undefined\n        }\n      } else if (\n        event[1].type === 'linePrefix' ||\n        event[1].type === 'listItemValue' ||\n        event[1].type === 'listItemMarker' ||\n        event[1].type === 'listItemPrefix' ||\n        event[1].type === 'listItemPrefixWhitespace'\n      ) {\n        // Empty.\n      } else {\n        atMarker = undefined\n      }\n      if (\n        (!containerBalance &&\n          event[0] === 'enter' &&\n          event[1].type === 'listItemPrefix') ||\n        (containerBalance === -1 &&\n          event[0] === 'exit' &&\n          (event[1].type === 'listUnordered' ||\n            event[1].type === 'listOrdered'))\n      ) {\n        if (listItem) {\n          let tailIndex = index\n          lineIndex = undefined\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex]\n            if (\n              tailEvent[1].type === 'lineEnding' ||\n              tailEvent[1].type === 'lineEndingBlank'\n            ) {\n              if (tailEvent[0] === 'exit') continue\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank'\n                listSpread = true\n              }\n              tailEvent[1].type = 'lineEnding'\n              lineIndex = tailIndex\n            } else if (\n              tailEvent[1].type === 'linePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||\n              tailEvent[1].type === 'blockQuoteMarker' ||\n              tailEvent[1].type === 'listItemIndent'\n            ) {\n              // Empty\n            } else {\n              break\n            }\n          }\n          if (\n            firstBlankLineIndex &&\n            (!lineIndex || firstBlankLineIndex < lineIndex)\n          ) {\n            // @ts-expect-error Patched.\n            listItem._spread = true\n          }\n\n          // Fix position.\n          listItem.end = Object.assign(\n            {},\n            lineIndex ? events[lineIndex][1].start : event[1].end\n          )\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])\n          index++\n          length++\n        }\n\n        // Create a new list item.\n        if (event[1].type === 'listItemPrefix') {\n          listItem = {\n            type: 'listItem',\n            // @ts-expect-error Patched\n            _spread: false,\n            start: Object.assign({}, event[1].start)\n          }\n          // @ts-expect-error: `listItem` is most definitely defined, TS...\n          events.splice(index, 0, ['enter', listItem, event[2]])\n          index++\n          length++\n          firstBlankLineIndex = undefined\n          atMarker = true\n        }\n      }\n    }\n\n    // @ts-expect-error Patched.\n    events[start][1]._spread = listSpread\n    return length\n  }\n\n  /**\n   * Set data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @param {CompileData[Key]} [value]\n   *   New value.\n   * @returns {void}\n   *   Nothing.\n   */\n  function setData(key, value) {\n    data[key] = value\n  }\n\n  /**\n   * Get data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @returns {CompileData[Key]}\n   *   Value.\n   */\n  function getData(key) {\n    return data[key]\n  }\n\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Node} create\n   *   Create a node.\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function opener(create, and) {\n    return open\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n    function open(token) {\n      enter.call(this, create(token), token)\n      if (and) and.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {void}\n   */\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    })\n  }\n\n  /**\n   * @template {Node} Kind\n   *   Node type.\n   * @this {CompileContext}\n   *   Context.\n   * @param {Kind} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {Kind}\n   *   The given node.\n   */\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1]\n    // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n    parent.children.push(node)\n    this.stack.push(node)\n    this.tokenStack.push([token, errorHandler])\n    // @ts-expect-error: `end` will be patched later.\n    node.position = {\n      start: point(token.start)\n    }\n    return node\n  }\n\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function closer(and) {\n    return close\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n    function close(token) {\n      if (and) and.call(this, token)\n      exit.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {Node}\n   *   The closed node.\n   */\n  function exit(token, onExitError) {\n    const node = this.stack.pop()\n    const open = this.tokenStack.pop()\n    if (!open) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({\n            start: token.start,\n            end: token.end\n          }) +\n          '): its not open'\n      )\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0])\n      } else {\n        const handler = open[1] || defaultOnError\n        handler.call(this, token, open[0])\n      }\n    }\n    node.position.end = point(token.end)\n    return node\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n  function resume() {\n    return toString(this.stack.pop())\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      const ancestor = this.stack[this.stack.length - 2]\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10)\n      setData('expectingFirstListItemValue')\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.lang = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfencemeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return\n    this.buffer()\n    setData('flowCodeInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefenced() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    setData('flowCodeInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeindented() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length\n      node.depth = depth\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1]\n    let tail = node.children[node.children.length - 1]\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text()\n      // @ts-expect-error: well add `end` later.\n      tail.position = {\n        start: point(token.start)\n      }\n      // @ts-expect-error: Assume `parent` accepts `text`.\n      node.children.push(tail)\n    }\n    this.stack.push(tail)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop()\n    tail.value += this.sliceSerialize(token)\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]\n    // If were at a hard break, include the line ending in there.\n    if (getData('atHardBreak')) {\n      const tail = context.children[context.children.length - 1]\n      tail.position.end = point(token.end)\n      setData('atHardBreak')\n      return\n    }\n    if (\n      !getData('setextHeadingSlurpLineEnding') &&\n      config.canContainEols.includes(context.type)\n    ) {\n      onenterdata.call(this, token)\n      onexitdata.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithardbreak() {\n    setData('atHardBreak', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmlflow() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmltext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcodetext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1]\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut'\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n    setData('referenceType')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1]\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut'\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n    setData('referenceType')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token)\n    const ancestor = this.stack[this.stack.length - 2]\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    ancestor.label = decodeString(string)\n    // @ts-expect-error: same as above.\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1]\n    const value = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    // Assume a reference.\n    setData('inReference', true)\n    if (node.type === 'link') {\n      /** @type {Array<StaticPhrasingContent>} */\n      // @ts-expect-error: Assume static phrasing content.\n      const children = fragment.children\n      node.children = children\n    } else {\n      node.alt = value\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresource() {\n    setData('inReference')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitreferencestring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    node.label = label\n    // @ts-expect-error: same as above.\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n    setData('referenceType', 'full')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token)\n    const type = getData('characterReferenceType')\n    /** @type {string} */\n    let value\n    if (type) {\n      value = decodeNumericCharacterReference(\n        data,\n        type === 'characterReferenceMarkerNumeric' ? 10 : 16\n      )\n      setData('characterReferenceType')\n    } else {\n      const result = decodeNamedCharacterReference(data)\n      value = result\n    }\n    const tail = this.stack.pop()\n    tail.value += value\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = 'mailto:' + this.sliceSerialize(token)\n  }\n\n  //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    }\n  }\n\n  /** @returns {Code} */\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    }\n  }\n\n  /** @returns {InlineCode} */\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    }\n  }\n\n  /** @returns {Definition} */\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    }\n  }\n\n  /** @returns {Emphasis} */\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    }\n  }\n\n  /** @returns {Heading} */\n  function heading() {\n    // @ts-expect-error `depth` will be set later.\n    return {\n      type: 'heading',\n      depth: undefined,\n      children: []\n    }\n  }\n\n  /** @returns {Break} */\n  function hardBreak() {\n    return {\n      type: 'break'\n    }\n  }\n\n  /** @returns {HTML} */\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    }\n  }\n\n  /** @returns {Image} */\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    }\n  }\n\n  /** @returns {Link} */\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      checked: null,\n      children: []\n    }\n  }\n\n  /** @returns {Paragraph} */\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    }\n  }\n\n  /** @returns {Strong} */\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    }\n  }\n\n  /** @returns {Text} */\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    }\n  }\n\n  /** @returns {ThematicBreak} */\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    }\n  }\n}\n\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\nfunction point(d) {\n  return {\n    line: d.line,\n    column: d.column,\n    offset: d.offset\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Array<Extension | Array<Extension>>} extensions\n * @returns {void}\n */\nfunction configure(combined, extensions) {\n  let index = -1\n  while (++index < extensions.length) {\n    const value = extensions[index]\n    if (Array.isArray(value)) {\n      configure(combined, value)\n    } else {\n      extension(combined, value)\n    }\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {void}\n */\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      if (key === 'canContainEols') {\n        const right = extension[key]\n        if (right) {\n          combined[key].push(...right)\n        }\n      } else if (key === 'transforms') {\n        const right = extension[key]\n        if (right) {\n          combined[key].push(...right)\n        }\n      } else if (key === 'enter' || key === 'exit') {\n        const right = extension[key]\n        if (right) {\n          Object.assign(combined[key], right)\n        }\n      }\n    }\n  }\n}\n\n/** @type {OnEnterError} */\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error(\n      'Cannot close `' +\n        left.type +\n        '` (' +\n        stringifyPosition({\n          start: left.start,\n          end: left.end\n        }) +\n        '): a different token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is open'\n    )\n  } else {\n    throw new Error(\n      'Cannot close document, a token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is still open'\n    )\n  }\n}\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s.\n */\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the nodes plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} value\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const includeImageAlt = (options || {}).includeImageAlt\n  return one(\n    value,\n    typeof includeImageAlt === 'boolean' ? includeImageAlt : true\n  )\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt) {\n  return (\n    (node(value) &&\n      (('value' in value && value.value) ||\n        (includeImageAlt && 'alt' in value && value.alt) ||\n        ('children' in value && all(value.children, includeImageAlt)))) ||\n    (Array.isArray(value) && all(value, includeImageAlt)) ||\n    ''\n  )\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Node}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').FullNormalizedExtension} FullNormalizedExtension\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').ParseContext} ParseContext\n * @typedef {import('micromark-util-types').Create} Create\n */\nimport {combineExtensions} from 'micromark-util-combine-extensions'\nimport {content} from './initialize/content.js'\nimport {document} from './initialize/document.js'\nimport {flow} from './initialize/flow.js'\nimport {text, string} from './initialize/text.js'\nimport {createTokenizer} from './create-tokenizer.js'\nimport * as defaultConstructs from './constructs.js'\n/**\n * @param {ParseOptions} [options]\n * @returns {ParseContext}\n */\n\nexport function parse(options = {}) {\n  /** @type {FullNormalizedExtension} */\n  // @ts-expect-error `defaultConstructs` is full, so the result will be too.\n  const constructs = combineExtensions(\n    // @ts-expect-error Same as above.\n    [defaultConstructs].concat(options.extensions || [])\n  )\n  /** @type {ParseContext} */\n\n  const parser = {\n    defined: [],\n    lazy: {},\n    constructs,\n    content: create(content),\n    document: create(document),\n    flow: create(flow),\n    string: create(string),\n    text: create(text)\n  }\n  return parser\n  /**\n   * @param {InitialConstruct} initial\n   */\n\n  function create(initial) {\n    return creator\n    /** @type {Create} */\n\n    function creator(from) {\n      return createTokenizer(parser, initial, from)\n    }\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\nimport {splice} from 'micromark-util-chunked'\n\nconst hasOwnProperty = {}.hasOwnProperty\n\n/**\n * Combine several syntax extensions into one.\n *\n * @param {Extension[]} extensions List of syntax extensions.\n * @returns {NormalizedExtension} A single combined extension.\n */\nexport function combineExtensions(extensions) {\n  /** @type {NormalizedExtension} */\n  const all = {}\n  let index = -1\n\n  while (++index < extensions.length) {\n    syntaxExtension(all, extensions[index])\n  }\n\n  return all\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {NormalizedExtension} all Extension to merge into.\n * @param {Extension} extension Extension to merge.\n * @returns {void}\n */\nfunction syntaxExtension(all, extension) {\n  /** @type {string} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    const left = maybe || (all[hook] = {})\n    const right = extension[hook]\n    /** @type {string} */\n    let code\n\n    for (code in right) {\n      if (!hasOwnProperty.call(left, code)) left[code] = []\n      const value = right[code]\n      constructs(\n        // @ts-expect-error Looks like a list.\n        left[code],\n        Array.isArray(value) ? value : value ? [value] : []\n      )\n    }\n  }\n}\n\n/**\n * Merge `list` into `existing` (both lists of constructs).\n * Mutates `existing`.\n *\n * @param {unknown[]} existing\n * @param {unknown[]} list\n * @returns {void}\n */\nfunction constructs(existing, list) {\n  let index = -1\n  /** @type {unknown[]} */\n  const before = []\n\n  while (++index < list.length) {\n    // @ts-expect-error Looks like an object.\n    ;(list[index].add === 'after' ? existing : before).push(list[index])\n  }\n\n  splice(existing, 0, 0, before)\n}\n\n/**\n * Combine several HTML extensions into one.\n *\n * @param {HtmlExtension[]} htmlExtensions List of HTML extensions.\n * @returns {HtmlExtension} A single combined extension.\n */\nexport function combineHtmlExtensions(htmlExtensions) {\n  /** @type {HtmlExtension} */\n  const handlers = {}\n  let index = -1\n\n  while (++index < htmlExtensions.length) {\n    htmlExtension(handlers, htmlExtensions[index])\n  }\n\n  return handlers\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {HtmlExtension} all Extension to merge into.\n * @param {HtmlExtension} extension Extension to merge.\n * @returns {void}\n */\nfunction htmlExtension(all, extension) {\n  /** @type {string} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    const left = maybe || (all[hook] = {})\n    const right = extension[hook]\n    /** @type {string} */\n    let type\n\n    if (right) {\n      for (type in right) {\n        left[type] = right[type]\n      }\n    }\n  }\n}\n","/**\n * Like `Array#splice`, but smarter for giant arrays.\n *\n * `Array#splice` takes all items to be inserted as individual argument which\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\n *\n * Otherwise, this does not return the removed items, and takes `items` as an\n * array instead of rest parameters.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {number} start\n * @param {number} remove\n * @param {T[]} items\n * @returns {void}\n */\nexport function splice(list, start, remove, items) {\n  const end = list.length\n  let chunkStart = 0\n  /** @type {unknown[]} */\n\n  let parameters // Make start between zero and `end` (included).\n\n  if (start < 0) {\n    start = -start > end ? 0 : end + start\n  } else {\n    start = start > end ? end : start\n  }\n\n  remove = remove > 0 ? remove : 0 // No need to chunk the items if theres only a couple (10k) items.\n\n  if (items.length < 10000) {\n    parameters = Array.from(items)\n    parameters.unshift(start, remove) // @ts-expect-error Hush, its fine.\n    ;[].splice.apply(list, parameters)\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) [].splice.apply(list, [start, remove]) // Insert the items in chunks to not cause stack overflows.\n\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000)\n      parameters.unshift(start, 0) // @ts-expect-error Hush, its fine.\n      ;[].splice.apply(list, parameters)\n      chunkStart += 10000\n      start += 10000\n    }\n  }\n}\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {T[]} items\n * @returns {T[]}\n */\n\nexport function push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items)\n    return list\n  }\n\n  return items\n}\n","/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {InitialConstruct} */\nexport const content = {\n  tokenize: initializeContent\n}\n/** @type {Initializer} */\n\nfunction initializeContent(effects) {\n  const contentStart = effects.attempt(\n    this.parser.constructs.contentInitial,\n    afterContentStartConstruct,\n    paragraphInitial\n  )\n  /** @type {Token} */\n\n  let previous\n  return contentStart\n  /** @type {State} */\n\n  function afterContentStartConstruct(code) {\n    if (code === null) {\n      effects.consume(code)\n      return\n    }\n\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, contentStart, 'linePrefix')\n  }\n  /** @type {State} */\n\n  function paragraphInitial(code) {\n    effects.enter('paragraph')\n    return lineStart(code)\n  }\n  /** @type {State} */\n\n  function lineStart(code) {\n    const token = effects.enter('chunkText', {\n      contentType: 'text',\n      previous\n    })\n\n    if (previous) {\n      previous.next = token\n    }\n\n    previous = token\n    return data(code)\n  }\n  /** @type {State} */\n\n  function data(code) {\n    if (code === null) {\n      effects.exit('chunkText')\n      effects.exit('paragraph')\n      effects.consume(code)\n      return\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      effects.exit('chunkText')\n      return lineStart\n    } // Data.\n\n    effects.consume(code)\n    return data\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */\nimport {markdownSpace} from 'micromark-util-character'\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\n\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n\n    effects.exit(type)\n    return ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\n\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexport const asciiDigit = regexCheck(/\\d/)\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\nexport const unicodeWhitespace = regexCheck(/\\s/)\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nfunction regexCheck(regex) {\n  return check\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\nexport const unicodePunctuationRegex =\n  /[!-/:-@[-`{-~\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n","/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Point} Point\n */\n\n/**\n * @typedef {Record<string, unknown>} StackState\n * @typedef {[Construct, StackState]} StackItem\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\n/** @type {InitialConstruct} */\n\nexport const document = {\n  tokenize: initializeDocument\n}\n/** @type {Construct} */\n\nconst containerConstruct = {\n  tokenize: tokenizeContainer\n}\n/** @type {Initializer} */\n\nfunction initializeDocument(effects) {\n  const self = this\n  /** @type {Array<StackItem>} */\n\n  const stack = []\n  let continued = 0\n  /** @type {TokenizeContext|undefined} */\n\n  let childFlow\n  /** @type {Token|undefined} */\n\n  let childToken\n  /** @type {number} */\n\n  let lineStartOffset\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // First we iterate through the open blocks, starting with the root\n    // document, and descending through last children down to the last open\n    // block.\n    // Each block imposes a condition that the line must satisfy if the block is\n    // to remain open.\n    // For example, a block quote requires a `>` character.\n    // A paragraph requires a non-blank line.\n    // In this phase we may match all or just some of the open blocks.\n    // But we cannot close unmatched blocks yet, because we may have a lazy\n    // continuation line.\n    if (continued < stack.length) {\n      const item = stack[continued]\n      self.containerState = item[1]\n      return effects.attempt(\n        item[0].continuation,\n        documentContinue,\n        checkNewContainers\n      )(code)\n    } // Done.\n\n    return checkNewContainers(code)\n  }\n  /** @type {State} */\n\n  function documentContinue(code) {\n    continued++ // Note: this field is called `_closeFlow` but it also closes containers.\n    // Perhaps a good idea to rename it but its already used in the wild by\n    // extensions.\n\n    if (self.containerState._closeFlow) {\n      self.containerState._closeFlow = undefined\n\n      if (childFlow) {\n        closeFlow()\n      } // Note: this algorithm for moving events around is similar to the\n      // algorithm when dealing with lazy lines in `writeToChild`.\n\n      const indexBeforeExits = self.events.length\n      let indexBeforeFlow = indexBeforeExits\n      /** @type {Point|undefined} */\n\n      let point // Find the flow chunk.\n\n      while (indexBeforeFlow--) {\n        if (\n          self.events[indexBeforeFlow][0] === 'exit' &&\n          self.events[indexBeforeFlow][1].type === 'chunkFlow'\n        ) {\n          point = self.events[indexBeforeFlow][1].end\n          break\n        }\n      }\n\n      exitContainers(continued) // Fix positions.\n\n      let index = indexBeforeExits\n\n      while (index < self.events.length) {\n        self.events[index][1].end = Object.assign({}, point)\n        index++\n      } // Inject the exits earlier (theyre still also at the end).\n\n      splice(\n        self.events,\n        indexBeforeFlow + 1,\n        0,\n        self.events.slice(indexBeforeExits)\n      ) // Discard the duplicate exits.\n\n      self.events.length = index\n      return checkNewContainers(code)\n    }\n\n    return start(code)\n  }\n  /** @type {State} */\n\n  function checkNewContainers(code) {\n    // Next, after consuming the continuation markers for existing blocks, we\n    // look for new block starts (e.g. `>` for a block quote).\n    // If we encounter a new block start, we close any blocks unmatched in\n    // step 1 before creating the new block as a child of the last matched\n    // block.\n    if (continued === stack.length) {\n      // No need to `check` whether theres a container, of `exitContainers`\n      // would be moot.\n      // We can instead immediately `attempt` to parse one.\n      if (!childFlow) {\n        return documentContinued(code)\n      } // If we have concrete content, such as block HTML or fenced code,\n      // we cant have containers pierce into them, so we can immediately\n      // start.\n\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        return flowStart(code)\n      } // If we do have flow, it could still be a blank line,\n      // but wed be interrupting it w/ a new container if theres a current\n      // construct.\n\n      self.interrupt = Boolean(\n        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack\n      )\n    } // Check if there is a new container.\n\n    self.containerState = {}\n    return effects.check(\n      containerConstruct,\n      thereIsANewContainer,\n      thereIsNoNewContainer\n    )(code)\n  }\n  /** @type {State} */\n\n  function thereIsANewContainer(code) {\n    if (childFlow) closeFlow()\n    exitContainers(continued)\n    return documentContinued(code)\n  }\n  /** @type {State} */\n\n  function thereIsNoNewContainer(code) {\n    self.parser.lazy[self.now().line] = continued !== stack.length\n    lineStartOffset = self.now().offset\n    return flowStart(code)\n  }\n  /** @type {State} */\n\n  function documentContinued(code) {\n    // Try new containers.\n    self.containerState = {}\n    return effects.attempt(\n      containerConstruct,\n      containerContinue,\n      flowStart\n    )(code)\n  }\n  /** @type {State} */\n\n  function containerContinue(code) {\n    continued++\n    stack.push([self.currentConstruct, self.containerState]) // Try another.\n\n    return documentContinued(code)\n  }\n  /** @type {State} */\n\n  function flowStart(code) {\n    if (code === null) {\n      if (childFlow) closeFlow()\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n\n    childFlow = childFlow || self.parser.flow(self.now())\n    effects.enter('chunkFlow', {\n      contentType: 'flow',\n      previous: childToken,\n      _tokenizer: childFlow\n    })\n    return flowContinue(code)\n  }\n  /** @type {State} */\n\n  function flowContinue(code) {\n    if (code === null) {\n      writeToChild(effects.exit('chunkFlow'), true)\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      writeToChild(effects.exit('chunkFlow')) // Get ready for the next line.\n\n      continued = 0\n      self.interrupt = undefined\n      return start\n    }\n\n    effects.consume(code)\n    return flowContinue\n  }\n  /**\n   * @param {Token} token\n   * @param {boolean} [eof]\n   * @returns {void}\n   */\n\n  function writeToChild(token, eof) {\n    const stream = self.sliceStream(token)\n    if (eof) stream.push(null)\n    token.previous = childToken\n    if (childToken) childToken.next = token\n    childToken = token\n    childFlow.defineSkip(token.start)\n    childFlow.write(stream) // Alright, so we just added a lazy line:\n    //\n    // ```markdown\n    // > a\n    // b.\n    //\n    // Or:\n    //\n    // > ~~~c\n    // d\n    //\n    // Or:\n    //\n    // > | e |\n    // f\n    // ```\n    //\n    // The construct in the second example (fenced code) does not accept lazy\n    // lines, so it marked itself as done at the end of its first line, and\n    // then the content construct parses `d`.\n    // Most constructs in markdown match on the first line: if the first line\n    // forms a construct, a non-lazy line cant unmake it.\n    //\n    // The construct in the third example is potentially a GFM table, and\n    // those are *weird*.\n    // It *could* be a table, from the first line, if the following line\n    // matches a condition.\n    // In this case, that second line is lazy, which unmakes the first line\n    // and turns the whole into one content block.\n    //\n    // Weve now parsed the non-lazy and the lazy line, and can figure out\n    // whether the lazy line started a new flow block.\n    // If it did, we exit the current containers between the two flow blocks.\n\n    if (self.parser.lazy[token.start.line]) {\n      let index = childFlow.events.length\n\n      while (index--) {\n        if (\n          // The token starts before the line ending\n          childFlow.events[index][1].start.offset < lineStartOffset && // and either is not ended yet\n          (!childFlow.events[index][1].end || // or ends after it.\n            childFlow.events[index][1].end.offset > lineStartOffset)\n        ) {\n          // Exit: theres still something open, which means its a lazy line\n          // part of something.\n          return\n        }\n      } // Note: this algorithm for moving events around is similar to the\n      // algorithm when closing flow in `documentContinue`.\n\n      const indexBeforeExits = self.events.length\n      let indexBeforeFlow = indexBeforeExits\n      /** @type {boolean|undefined} */\n\n      let seen\n      /** @type {Point|undefined} */\n\n      let point // Find the previous chunk (the one before the lazy line).\n\n      while (indexBeforeFlow--) {\n        if (\n          self.events[indexBeforeFlow][0] === 'exit' &&\n          self.events[indexBeforeFlow][1].type === 'chunkFlow'\n        ) {\n          if (seen) {\n            point = self.events[indexBeforeFlow][1].end\n            break\n          }\n\n          seen = true\n        }\n      }\n\n      exitContainers(continued) // Fix positions.\n\n      index = indexBeforeExits\n\n      while (index < self.events.length) {\n        self.events[index][1].end = Object.assign({}, point)\n        index++\n      } // Inject the exits earlier (theyre still also at the end).\n\n      splice(\n        self.events,\n        indexBeforeFlow + 1,\n        0,\n        self.events.slice(indexBeforeExits)\n      ) // Discard the duplicate exits.\n\n      self.events.length = index\n    }\n  }\n  /**\n   * @param {number} size\n   * @returns {void}\n   */\n\n  function exitContainers(size) {\n    let index = stack.length // Exit open containers.\n\n    while (index-- > size) {\n      const entry = stack[index]\n      self.containerState = entry[1]\n      entry[0].exit.call(self, effects)\n    }\n\n    stack.length = size\n  }\n\n  function closeFlow() {\n    childFlow.write([null])\n    childToken = undefined\n    childFlow = undefined\n    self.containerState._closeFlow = undefined\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeContainer(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.attempt(this.parser.constructs.document, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4\n  )\n}\n","/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {blankLine, content} from 'micromark-core-commonmark'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {InitialConstruct} */\nexport const flow = {\n  tokenize: initializeFlow\n}\n/** @type {Initializer} */\n\nfunction initializeFlow(effects) {\n  const self = this\n  const initial = effects.attempt(\n    // Try to parse a blank line.\n    blankLine,\n    atBlankEnding, // Try to parse initial flow (essentially, only code).\n    effects.attempt(\n      this.parser.constructs.flowInitial,\n      afterConstruct,\n      factorySpace(\n        effects,\n        effects.attempt(\n          this.parser.constructs.flow,\n          afterConstruct,\n          effects.attempt(content, afterConstruct)\n        ),\n        'linePrefix'\n      )\n    )\n  )\n  return initial\n  /** @type {State} */\n\n  function atBlankEnding(code) {\n    if (code === null) {\n      effects.consume(code)\n      return\n    }\n\n    effects.enter('lineEndingBlank')\n    effects.consume(code)\n    effects.exit('lineEndingBlank')\n    self.currentConstruct = undefined\n    return initial\n  }\n  /** @type {State} */\n\n  function afterConstruct(code) {\n    if (code === null) {\n      effects.consume(code)\n      return\n    }\n\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    self.currentConstruct = undefined\n    return initial\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const blankLine = {\n  tokenize: tokenizeBlankLine,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeBlankLine(effects, ok, nok) {\n  return factorySpace(effects, afterWhitespace, 'linePrefix')\n  /** @type {State} */\n\n  function afterWhitespace(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {subtokenize} from 'micromark-util-subtokenize'\n\n/**\n * No name because it must not be turned off.\n * @type {Construct}\n */\nexport const content = {\n  tokenize: tokenizeContent,\n  resolve: resolveContent\n}\n/** @type {Construct} */\n\nconst continuationConstruct = {\n  tokenize: tokenizeContinuation,\n  partial: true\n}\n/**\n * Content is transparent: its parsed right now. That way, definitions are also\n * parsed right now: before text in paragraphs (specifically, media) are parsed.\n *\n * @type {Resolver}\n */\n\nfunction resolveContent(events) {\n  subtokenize(events)\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeContent(effects, ok) {\n  /** @type {Token} */\n  let previous\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('content')\n    previous = effects.enter('chunkContent', {\n      contentType: 'content'\n    })\n    return data(code)\n  }\n  /** @type {State} */\n\n  function data(code) {\n    if (code === null) {\n      return contentEnd(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.check(\n        continuationConstruct,\n        contentContinue,\n        contentEnd\n      )(code)\n    } // Data.\n\n    effects.consume(code)\n    return data\n  }\n  /** @type {State} */\n\n  function contentEnd(code) {\n    effects.exit('chunkContent')\n    effects.exit('content')\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function contentContinue(code) {\n    effects.consume(code)\n    effects.exit('chunkContent')\n    previous.next = effects.enter('chunkContent', {\n      contentType: 'content',\n      previous\n    })\n    previous = previous.next\n    return data\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeContinuation(effects, ok, nok) {\n  const self = this\n  return startLookahead\n  /** @type {State} */\n\n  function startLookahead(code) {\n    effects.exit('chunkContent')\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, prefixed, 'linePrefix')\n  }\n  /** @type {State} */\n\n  function prefixed(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    const tail = self.events[self.events.length - 1]\n\n    if (\n      !self.parser.constructs.disable.null.includes('codeIndented') &&\n      tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n    ) {\n      return ok(code)\n    }\n\n    return effects.interrupt(self.parser.constructs.flow, nok, ok)(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Event} Event\n */\nimport {splice} from 'micromark-util-chunked'\n\n/**\n * Tokenize subcontent.\n *\n * @param {Event[]} events\n * @returns {boolean}\n */\nexport function subtokenize(events) {\n  /** @type {Record<string, number>} */\n  const jumps = {}\n  let index = -1\n  /** @type {Event} */\n\n  let event\n  /** @type {number|undefined} */\n\n  let lineIndex\n  /** @type {number} */\n\n  let otherIndex\n  /** @type {Event} */\n\n  let otherEvent\n  /** @type {Event[]} */\n\n  let parameters\n  /** @type {Event[]} */\n\n  let subevents\n  /** @type {boolean|undefined} */\n\n  let more\n\n  while (++index < events.length) {\n    while (index in jumps) {\n      index = jumps[index]\n    }\n\n    event = events[index] // Add a hook for the GFM tasklist extension, which needs to know if text\n    // is in the first content of a list item.\n\n    if (\n      index &&\n      event[1].type === 'chunkFlow' &&\n      events[index - 1][1].type === 'listItemPrefix'\n    ) {\n      subevents = event[1]._tokenizer.events\n      otherIndex = 0\n\n      if (\n        otherIndex < subevents.length &&\n        subevents[otherIndex][1].type === 'lineEndingBlank'\n      ) {\n        otherIndex += 2\n      }\n\n      if (\n        otherIndex < subevents.length &&\n        subevents[otherIndex][1].type === 'content'\n      ) {\n        while (++otherIndex < subevents.length) {\n          if (subevents[otherIndex][1].type === 'content') {\n            break\n          }\n\n          if (subevents[otherIndex][1].type === 'chunkText') {\n            subevents[otherIndex][1]._isInFirstContentOfListItem = true\n            otherIndex++\n          }\n        }\n      }\n    } // Enter.\n\n    if (event[0] === 'enter') {\n      if (event[1].contentType) {\n        Object.assign(jumps, subcontent(events, index))\n        index = jumps[index]\n        more = true\n      }\n    } // Exit.\n    else if (event[1]._container) {\n      otherIndex = index\n      lineIndex = undefined\n\n      while (otherIndex--) {\n        otherEvent = events[otherIndex]\n\n        if (\n          otherEvent[1].type === 'lineEnding' ||\n          otherEvent[1].type === 'lineEndingBlank'\n        ) {\n          if (otherEvent[0] === 'enter') {\n            if (lineIndex) {\n              events[lineIndex][1].type = 'lineEndingBlank'\n            }\n\n            otherEvent[1].type = 'lineEnding'\n            lineIndex = otherIndex\n          }\n        } else {\n          break\n        }\n      }\n\n      if (lineIndex) {\n        // Fix position.\n        event[1].end = Object.assign({}, events[lineIndex][1].start) // Switch container exit w/ line endings.\n\n        parameters = events.slice(lineIndex, index)\n        parameters.unshift(event)\n        splice(events, lineIndex, index - lineIndex + 1, parameters)\n      }\n    }\n  }\n\n  return !more\n}\n/**\n * Tokenize embedded tokens.\n *\n * @param {Event[]} events\n * @param {number} eventIndex\n * @returns {Record<string, number>}\n */\n\nfunction subcontent(events, eventIndex) {\n  const token = events[eventIndex][1]\n  const context = events[eventIndex][2]\n  let startPosition = eventIndex - 1\n  /** @type {number[]} */\n\n  const startPositions = []\n  const tokenizer =\n    token._tokenizer || context.parser[token.contentType](token.start)\n  const childEvents = tokenizer.events\n  /** @type {[number, number][]} */\n\n  const jumps = []\n  /** @type {Record<string, number>} */\n\n  const gaps = {}\n  /** @type {Chunk[]} */\n\n  let stream\n  /** @type {Token|undefined} */\n\n  let previous\n  let index = -1\n  /** @type {Token|undefined} */\n\n  let current = token\n  let adjust = 0\n  let start = 0\n  const breaks = [start] // Loop forward through the linked tokens to pass them in order to the\n  // subtokenizer.\n\n  while (current) {\n    // Find the position of the event for this token.\n    while (events[++startPosition][1] !== current) {\n      // Empty.\n    }\n\n    startPositions.push(startPosition)\n\n    if (!current._tokenizer) {\n      stream = context.sliceStream(current)\n\n      if (!current.next) {\n        stream.push(null)\n      }\n\n      if (previous) {\n        tokenizer.defineSkip(current.start)\n      }\n\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = true\n      }\n\n      tokenizer.write(stream)\n\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined\n      }\n    } // Unravel the next token.\n\n    previous = current\n    current = current.next\n  } // Now, loop back through all events (and linked tokens), to figure out which\n  // parts belong where.\n\n  current = token\n\n  while (++index < childEvents.length) {\n    if (\n      // Find a void token that includes a break.\n      childEvents[index][0] === 'exit' &&\n      childEvents[index - 1][0] === 'enter' &&\n      childEvents[index][1].type === childEvents[index - 1][1].type &&\n      childEvents[index][1].start.line !== childEvents[index][1].end.line\n    ) {\n      start = index + 1\n      breaks.push(start) // Help GC.\n\n      current._tokenizer = undefined\n      current.previous = undefined\n      current = current.next\n    }\n  } // Help GC.\n\n  tokenizer.events = [] // If theres one more token (which is the cases for lines that end in an\n  // EOF), thats perfect: the last point we found starts it.\n  // If there isnt then make sure any remaining content is added to it.\n\n  if (current) {\n    // Help GC.\n    current._tokenizer = undefined\n    current.previous = undefined\n  } else {\n    breaks.pop()\n  } // Now splice the events from the subtokenizer into the current events,\n  // moving back to front so that splice indices arent affected.\n\n  index = breaks.length\n\n  while (index--) {\n    const slice = childEvents.slice(breaks[index], breaks[index + 1])\n    const start = startPositions.pop()\n    jumps.unshift([start, start + slice.length - 1])\n    splice(events, start, 2, slice)\n  }\n\n  index = -1\n\n  while (++index < jumps.length) {\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1]\n    adjust += jumps[index][1] - jumps[index][0] - 1\n  }\n\n  return gaps\n}\n","/**\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nexport const resolver = {\n  resolveAll: createResolver()\n}\nexport const string = initializeFactory('string')\nexport const text = initializeFactory('text')\n/**\n * @param {'string'|'text'} field\n * @returns {InitialConstruct}\n */\n\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: createResolver(\n      field === 'text' ? resolveAllLineSuffixes : undefined\n    )\n  }\n  /** @type {Initializer} */\n\n  function initializeText(effects) {\n    const self = this\n    const constructs = this.parser.constructs[field]\n    const text = effects.attempt(constructs, start, notText)\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code)\n    }\n    /** @type {State} */\n\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code)\n        return\n      }\n\n      effects.enter('data')\n      effects.consume(code)\n      return data\n    }\n    /** @type {State} */\n\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data')\n        return text(code)\n      } // Data.\n\n      effects.consume(code)\n      return data\n    }\n    /**\n     * @param {Code} code\n     * @returns {boolean}\n     */\n\n    function atBreak(code) {\n      if (code === null) {\n        return true\n      }\n\n      const list = constructs[code]\n      let index = -1\n\n      if (list) {\n        while (++index < list.length) {\n          const item = list[index]\n\n          if (!item.previous || item.previous.call(self, self.previous)) {\n            return true\n          }\n        }\n      }\n\n      return false\n    }\n  }\n}\n/**\n * @param {Resolver} [extraResolver]\n * @returns {Resolver}\n */\n\nfunction createResolver(extraResolver) {\n  return resolveAllText\n  /** @type {Resolver} */\n\n  function resolveAllText(events, context) {\n    let index = -1\n    /** @type {number|undefined} */\n\n    let enter // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index\n          index++\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Dont do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end\n          events.splice(enter + 2, index - enter - 2)\n          index = enter + 2\n        }\n\n        enter = undefined\n      }\n    }\n\n    return extraResolver ? extraResolver(events, context) : events\n  }\n}\n/**\n * A rather ugly set of instructions which again looks at chunks in the input\n * stream.\n * The reason to do this here is that it is *much* faster to parse in reverse.\n * And that we cant hook into `null` to split the line suffix before an EOF.\n * To do: figure out if we can make this into a clean utility, or even in core.\n * As it will be useful for GFMs literal autolink extension (and maybe even\n * tables?)\n *\n * @type {Resolver}\n */\n\nfunction resolveAllLineSuffixes(events, context) {\n  let eventIndex = 0 // Skip first.\n\n  while (++eventIndex <= events.length) {\n    if (\n      (eventIndex === events.length ||\n        events[eventIndex][1].type === 'lineEnding') &&\n      events[eventIndex - 1][1].type === 'data'\n    ) {\n      const data = events[eventIndex - 1][1]\n      const chunks = context.sliceStream(data)\n      let index = chunks.length\n      let bufferIndex = -1\n      let size = 0\n      /** @type {boolean|undefined} */\n\n      let tabs\n\n      while (index--) {\n        const chunk = chunks[index]\n\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length\n\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++\n            bufferIndex--\n          }\n\n          if (bufferIndex) break\n          bufferIndex = -1\n        } // Number\n        else if (chunk === -2) {\n          tabs = true\n          size++\n        } else if (chunk === -1) {\n          // Empty\n        } else {\n          // Replacement character, exit.\n          index++\n          break\n        }\n      }\n\n      if (size) {\n        const token = {\n          type:\n            eventIndex === events.length || tabs || size < 2\n              ? 'lineSuffix'\n              : 'hardBreakTrailing',\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index\n              ? bufferIndex\n              : data.start._bufferIndex + bufferIndex\n          },\n          end: Object.assign({}, data.end)\n        }\n        data.end = Object.assign({}, token.start)\n\n        if (data.start.offset === data.end.offset) {\n          Object.assign(data, token)\n        } else {\n          events.splice(\n            eventIndex,\n            0,\n            ['enter', token, context],\n            ['exit', token, context]\n          )\n          eventIndex += 2\n        }\n      }\n\n      eventIndex++\n    }\n  }\n\n  return events\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').ParseContext} ParseContext\n */\n\n/**\n * @typedef Info\n * @property {() => void} restore\n * @property {number} from\n *\n * @callback ReturnHandle\n *   Handle a successful run.\n * @param {Construct} construct\n * @param {Info} info\n * @returns {void}\n */\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/**\n * Create a tokenizer.\n * Tokenizers deal with one type of data (e.g., containers, flow, text).\n * The parser is the object dealing with it all.\n * `initialize` works like other constructs, except that only its `tokenize`\n * function is used, in which case it doesnt receive an `ok` or `nok`.\n * `from` can be given to set the point before the first character, although\n * when further lines are indented, they must be set with `defineSkip`.\n *\n * @param {ParseContext} parser\n * @param {InitialConstruct} initialize\n * @param {Omit<Point, '_index'|'_bufferIndex'>} [from]\n * @returns {TokenizeContext}\n */\nexport function createTokenizer(parser, initialize, from) {\n  /** @type {Point} */\n  let point = Object.assign(\n    from\n      ? Object.assign({}, from)\n      : {\n          line: 1,\n          column: 1,\n          offset: 0\n        },\n    {\n      _index: 0,\n      _bufferIndex: -1\n    }\n  )\n  /** @type {Record<string, number>} */\n\n  const columnStart = {}\n  /** @type {Array<Construct>} */\n\n  const resolveAllConstructs = []\n  /** @type {Array<Chunk>} */\n\n  let chunks = []\n  /** @type {Array<Token>} */\n\n  let stack = []\n  /** @type {boolean|undefined} */\n\n  let consumed = true\n  /**\n   * Tools used for tokenizing.\n   *\n   * @type {Effects}\n   */\n\n  const effects = {\n    consume,\n    enter,\n    exit,\n    attempt: constructFactory(onsuccessfulconstruct),\n    check: constructFactory(onsuccessfulcheck),\n    interrupt: constructFactory(onsuccessfulcheck, {\n      interrupt: true\n    })\n  }\n  /**\n   * State and tools for resolving and serializing.\n   *\n   * @type {TokenizeContext}\n   */\n\n  const context = {\n    previous: null,\n    code: null,\n    containerState: {},\n    events: [],\n    parser,\n    sliceStream,\n    sliceSerialize,\n    now,\n    defineSkip,\n    write\n  }\n  /**\n   * The state function.\n   *\n   * @type {State|void}\n   */\n\n  let state = initialize.tokenize.call(context, effects)\n  /**\n   * Track which character we expect to be consumed, to catch bugs.\n   *\n   * @type {Code}\n   */\n\n  let expectedCode\n\n  if (initialize.resolveAll) {\n    resolveAllConstructs.push(initialize)\n  }\n\n  return context\n  /** @type {TokenizeContext['write']} */\n\n  function write(slice) {\n    chunks = push(chunks, slice)\n    main() // Exit if were not done, resolve might change stuff.\n\n    if (chunks[chunks.length - 1] !== null) {\n      return []\n    }\n\n    addResult(initialize, 0) // Otherwise, resolve, and exit.\n\n    context.events = resolveAll(resolveAllConstructs, context.events, context)\n    return context.events\n  } //\n  // Tools.\n  //\n\n  /** @type {TokenizeContext['sliceSerialize']} */\n\n  function sliceSerialize(token, expandTabs) {\n    return serializeChunks(sliceStream(token), expandTabs)\n  }\n  /** @type {TokenizeContext['sliceStream']} */\n\n  function sliceStream(token) {\n    return sliceChunks(chunks, token)\n  }\n  /** @type {TokenizeContext['now']} */\n\n  function now() {\n    return Object.assign({}, point)\n  }\n  /** @type {TokenizeContext['defineSkip']} */\n\n  function defineSkip(value) {\n    columnStart[value.line] = value.column\n    accountForPotentialSkip()\n  } //\n  // State management.\n  //\n\n  /**\n   * Main loop (note that `_index` and `_bufferIndex` in `point` are modified by\n   * `consume`).\n   * Here is where we walk through the chunks, which either include strings of\n   * several characters, or numerical character codes.\n   * The reason to do this in a loop instead of a call is so the stack can\n   * drain.\n   *\n   * @returns {void}\n   */\n\n  function main() {\n    /** @type {number} */\n    let chunkIndex\n\n    while (point._index < chunks.length) {\n      const chunk = chunks[point._index] // If were in a buffer chunk, loop through it.\n\n      if (typeof chunk === 'string') {\n        chunkIndex = point._index\n\n        if (point._bufferIndex < 0) {\n          point._bufferIndex = 0\n        }\n\n        while (\n          point._index === chunkIndex &&\n          point._bufferIndex < chunk.length\n        ) {\n          go(chunk.charCodeAt(point._bufferIndex))\n        }\n      } else {\n        go(chunk)\n      }\n    }\n  }\n  /**\n   * Deal with one code.\n   *\n   * @param {Code} code\n   * @returns {void}\n   */\n\n  function go(code) {\n    consumed = undefined\n    expectedCode = code\n    state = state(code)\n  }\n  /** @type {Effects['consume']} */\n\n  function consume(code) {\n    if (markdownLineEnding(code)) {\n      point.line++\n      point.column = 1\n      point.offset += code === -3 ? 2 : 1\n      accountForPotentialSkip()\n    } else if (code !== -1) {\n      point.column++\n      point.offset++\n    } // Not in a string chunk.\n\n    if (point._bufferIndex < 0) {\n      point._index++\n    } else {\n      point._bufferIndex++ // At end of string chunk.\n      // @ts-expect-error Points w/ non-negative `_bufferIndex` reference\n      // strings.\n\n      if (point._bufferIndex === chunks[point._index].length) {\n        point._bufferIndex = -1\n        point._index++\n      }\n    } // Expose the previous character.\n\n    context.previous = code // Mark as consumed.\n\n    consumed = true\n  }\n  /** @type {Effects['enter']} */\n\n  function enter(type, fields) {\n    /** @type {Token} */\n    // @ts-expect-error Patch instead of assign required fields to help GC.\n    const token = fields || {}\n    token.type = type\n    token.start = now()\n    context.events.push(['enter', token, context])\n    stack.push(token)\n    return token\n  }\n  /** @type {Effects['exit']} */\n\n  function exit(type) {\n    const token = stack.pop()\n    token.end = now()\n    context.events.push(['exit', token, context])\n    return token\n  }\n  /**\n   * Use results.\n   *\n   * @type {ReturnHandle}\n   */\n\n  function onsuccessfulconstruct(construct, info) {\n    addResult(construct, info.from)\n  }\n  /**\n   * Discard results.\n   *\n   * @type {ReturnHandle}\n   */\n\n  function onsuccessfulcheck(_, info) {\n    info.restore()\n  }\n  /**\n   * Factory to attempt/check/interrupt.\n   *\n   * @param {ReturnHandle} onreturn\n   * @param {Record<string, unknown>} [fields]\n   */\n\n  function constructFactory(onreturn, fields) {\n    return hook\n    /**\n     * Handle either an object mapping codes to constructs, a list of\n     * constructs, or a single construct.\n     *\n     * @param {Construct|Array<Construct>|ConstructRecord} constructs\n     * @param {State} returnState\n     * @param {State} [bogusState]\n     * @returns {State}\n     */\n\n    function hook(constructs, returnState, bogusState) {\n      /** @type {Array<Construct>} */\n      let listOfConstructs\n      /** @type {number} */\n\n      let constructIndex\n      /** @type {Construct} */\n\n      let currentConstruct\n      /** @type {Info} */\n\n      let info\n      return Array.isArray(constructs)\n        ? /* c8 ignore next 1 */\n          handleListOfConstructs(constructs)\n        : 'tokenize' in constructs // @ts-expect-error Looks like a construct.\n        ? handleListOfConstructs([constructs])\n        : handleMapOfConstructs(constructs)\n      /**\n       * Handle a list of construct.\n       *\n       * @param {ConstructRecord} map\n       * @returns {State}\n       */\n\n      function handleMapOfConstructs(map) {\n        return start\n        /** @type {State} */\n\n        function start(code) {\n          const def = code !== null && map[code]\n          const all = code !== null && map.null\n          const list = [\n            // To do: add more extension tests.\n\n            /* c8 ignore next 2 */\n            ...(Array.isArray(def) ? def : def ? [def] : []),\n            ...(Array.isArray(all) ? all : all ? [all] : [])\n          ]\n          return handleListOfConstructs(list)(code)\n        }\n      }\n      /**\n       * Handle a list of construct.\n       *\n       * @param {Array<Construct>} list\n       * @returns {State}\n       */\n\n      function handleListOfConstructs(list) {\n        listOfConstructs = list\n        constructIndex = 0\n\n        if (list.length === 0) {\n          return bogusState\n        }\n\n        return handleConstruct(list[constructIndex])\n      }\n      /**\n       * Handle a single construct.\n       *\n       * @param {Construct} construct\n       * @returns {State}\n       */\n\n      function handleConstruct(construct) {\n        return start\n        /** @type {State} */\n\n        function start(code) {\n          // To do: not needed to store if there is no bogus state, probably?\n          // Currently doesnt work because `inspect` in document does a check\n          // w/o a bogus, which doesnt make sense. But it does seem to help perf\n          // by not storing.\n          info = store()\n          currentConstruct = construct\n\n          if (!construct.partial) {\n            context.currentConstruct = construct\n          }\n\n          if (\n            construct.name &&\n            context.parser.constructs.disable.null.includes(construct.name)\n          ) {\n            return nok(code)\n          }\n\n          return construct.tokenize.call(\n            // If we do have fields, create an object w/ `context` as its\n            // prototype.\n            // This allows a live binding, which is needed for `interrupt`.\n            fields ? Object.assign(Object.create(context), fields) : context,\n            effects,\n            ok,\n            nok\n          )(code)\n        }\n      }\n      /** @type {State} */\n\n      function ok(code) {\n        consumed = true\n        onreturn(currentConstruct, info)\n        return returnState\n      }\n      /** @type {State} */\n\n      function nok(code) {\n        consumed = true\n        info.restore()\n\n        if (++constructIndex < listOfConstructs.length) {\n          return handleConstruct(listOfConstructs[constructIndex])\n        }\n\n        return bogusState\n      }\n    }\n  }\n  /**\n   * @param {Construct} construct\n   * @param {number} from\n   * @returns {void}\n   */\n\n  function addResult(construct, from) {\n    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {\n      resolveAllConstructs.push(construct)\n    }\n\n    if (construct.resolve) {\n      splice(\n        context.events,\n        from,\n        context.events.length - from,\n        construct.resolve(context.events.slice(from), context)\n      )\n    }\n\n    if (construct.resolveTo) {\n      context.events = construct.resolveTo(context.events, context)\n    }\n  }\n  /**\n   * Store state.\n   *\n   * @returns {Info}\n   */\n\n  function store() {\n    const startPoint = now()\n    const startPrevious = context.previous\n    const startCurrentConstruct = context.currentConstruct\n    const startEventsIndex = context.events.length\n    const startStack = Array.from(stack)\n    return {\n      restore,\n      from: startEventsIndex\n    }\n    /**\n     * Restore state.\n     *\n     * @returns {void}\n     */\n\n    function restore() {\n      point = startPoint\n      context.previous = startPrevious\n      context.currentConstruct = startCurrentConstruct\n      context.events.length = startEventsIndex\n      stack = startStack\n      accountForPotentialSkip()\n    }\n  }\n  /**\n   * Move the current point a bit forward in the line when its on a column\n   * skip.\n   *\n   * @returns {void}\n   */\n\n  function accountForPotentialSkip() {\n    if (point.line in columnStart && point.column < 2) {\n      point.column = columnStart[point.line]\n      point.offset += columnStart[point.line] - 1\n    }\n  }\n}\n/**\n * Get the chunks from a slice of chunks in the range of a token.\n *\n * @param {Array<Chunk>} chunks\n * @param {Pick<Token, 'start'|'end'>} token\n * @returns {Array<Chunk>}\n */\n\nfunction sliceChunks(chunks, token) {\n  const startIndex = token.start._index\n  const startBufferIndex = token.start._bufferIndex\n  const endIndex = token.end._index\n  const endBufferIndex = token.end._bufferIndex\n  /** @type {Array<Chunk>} */\n\n  let view\n\n  if (startIndex === endIndex) {\n    // @ts-expect-error `_bufferIndex` is used on string chunks.\n    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)]\n  } else {\n    view = chunks.slice(startIndex, endIndex)\n\n    if (startBufferIndex > -1) {\n      // @ts-expect-error `_bufferIndex` is used on string chunks.\n      view[0] = view[0].slice(startBufferIndex)\n    }\n\n    if (endBufferIndex > 0) {\n      // @ts-expect-error `_bufferIndex` is used on string chunks.\n      view.push(chunks[endIndex].slice(0, endBufferIndex))\n    }\n  }\n\n  return view\n}\n/**\n * Get the string value of a slice of chunks.\n *\n * @param {Array<Chunk>} chunks\n * @param {boolean} [expandTabs=false]\n * @returns {string}\n */\n\nfunction serializeChunks(chunks, expandTabs) {\n  let index = -1\n  /** @type {Array<string>} */\n\n  const result = []\n  /** @type {boolean|undefined} */\n\n  let atTab\n\n  while (++index < chunks.length) {\n    const chunk = chunks[index]\n    /** @type {string} */\n\n    let value\n\n    if (typeof chunk === 'string') {\n      value = chunk\n    } else\n      switch (chunk) {\n        case -5: {\n          value = '\\r'\n          break\n        }\n\n        case -4: {\n          value = '\\n'\n          break\n        }\n\n        case -3: {\n          value = '\\r' + '\\n'\n          break\n        }\n\n        case -2: {\n          value = expandTabs ? ' ' : '\\t'\n          break\n        }\n\n        case -1: {\n          if (!expandTabs && atTab) continue\n          value = ' '\n          break\n        }\n\n        default: {\n          // Currently only replacement character.\n          value = String.fromCharCode(chunk)\n        }\n      }\n\n    atTab = chunk === -2\n    result.push(value)\n  }\n\n  return result.join('')\n}\n","/**\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n */\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {{resolveAll?: Resolver}[]} constructs\n * @param {Event[]} events\n * @param {TokenizeContext} context\n * @returns {Event[]}\n */\nexport function resolveAll(constructs, events, context) {\n  /** @type {Resolver[]} */\n  const called = []\n  let index = -1\n\n  while (++index < constructs.length) {\n    const resolve = constructs[index].resolveAll\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n */\nimport {\n  attention,\n  autolink,\n  blockQuote,\n  characterEscape,\n  characterReference,\n  codeFenced,\n  codeIndented,\n  codeText,\n  definition,\n  hardBreakEscape,\n  headingAtx,\n  htmlFlow,\n  htmlText,\n  labelEnd,\n  labelStartImage,\n  labelStartLink,\n  lineEnding,\n  list,\n  setextUnderline,\n  thematicBreak\n} from 'micromark-core-commonmark'\nimport {resolver as resolveText} from './initialize/text.js'\n/** @type {Extension['document']} */\n\nexport const document = {\n  [42]: list,\n  [43]: list,\n  [45]: list,\n  [48]: list,\n  [49]: list,\n  [50]: list,\n  [51]: list,\n  [52]: list,\n  [53]: list,\n  [54]: list,\n  [55]: list,\n  [56]: list,\n  [57]: list,\n  [62]: blockQuote\n}\n/** @type {Extension['contentInitial']} */\n\nexport const contentInitial = {\n  [91]: definition\n}\n/** @type {Extension['flowInitial']} */\n\nexport const flowInitial = {\n  [-2]: codeIndented,\n  [-1]: codeIndented,\n  [32]: codeIndented\n}\n/** @type {Extension['flow']} */\n\nexport const flow = {\n  [35]: headingAtx,\n  [42]: thematicBreak,\n  [45]: [setextUnderline, thematicBreak],\n  [60]: htmlFlow,\n  [61]: setextUnderline,\n  [95]: thematicBreak,\n  [96]: codeFenced,\n  [126]: codeFenced\n}\n/** @type {Extension['string']} */\n\nexport const string = {\n  [38]: characterReference,\n  [92]: characterEscape\n}\n/** @type {Extension['text']} */\n\nexport const text = {\n  [-5]: lineEnding,\n  [-4]: lineEnding,\n  [-3]: lineEnding,\n  [33]: labelStartImage,\n  [38]: characterReference,\n  [42]: attention,\n  [60]: [autolink, htmlText],\n  [91]: labelStartLink,\n  [92]: [hardBreakEscape, characterEscape],\n  [93]: labelEnd,\n  [95]: attention,\n  [96]: codeText\n}\n/** @type {Extension['insideSpan']} */\n\nexport const insideSpan = {\n  null: [attention, resolveText]\n}\n/** @type {Extension['attentionMarkers']} */\n\nexport const attentionMarkers = {\n  null: [42, 95]\n}\n/** @type {Extension['disable']} */\n\nexport const disable = {\n  null: []\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Point} Point\n */\nimport {push, splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/** @type {Construct} */\nexport const attention = {\n  name: 'attention',\n  tokenize: tokenizeAttention,\n  resolveAll: resolveAllAttention\n}\n/**\n * Take all events and resolve attention to emphasis or strong.\n *\n * @type {Resolver}\n */\n\nfunction resolveAllAttention(events, context) {\n  let index = -1\n  /** @type {number} */\n\n  let open\n  /** @type {Token} */\n\n  let group\n  /** @type {Token} */\n\n  let text\n  /** @type {Token} */\n\n  let openingSequence\n  /** @type {Token} */\n\n  let closingSequence\n  /** @type {number} */\n\n  let use\n  /** @type {Event[]} */\n\n  let nextEvents\n  /** @type {number} */\n\n  let offset // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but its\n  // a bottleneck for malicious stuff.\n\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === 'attentionSequence' &&\n      events[index][1]._close\n    ) {\n      open = index // Now walk back to find an opener.\n\n      while (open--) {\n        // Find a token that can open the closer.\n        if (\n          events[open][0] === 'exit' &&\n          events[open][1].type === 'attentionSequence' &&\n          events[open][1]._open && // If the markers are the same:\n          context.sliceSerialize(events[open][1]).charCodeAt(0) ===\n            context.sliceSerialize(events[index][1]).charCodeAt(0)\n        ) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then dont match.\n          if (\n            (events[open][1]._close || events[index][1]._open) &&\n            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&\n            !(\n              (events[open][1].end.offset -\n                events[open][1].start.offset +\n                events[index][1].end.offset -\n                events[index][1].start.offset) %\n              3\n            )\n          ) {\n            continue\n          } // Number of markers to use from the sequence.\n\n          use =\n            events[open][1].end.offset - events[open][1].start.offset > 1 &&\n            events[index][1].end.offset - events[index][1].start.offset > 1\n              ? 2\n              : 1\n          const start = Object.assign({}, events[open][1].end)\n          const end = Object.assign({}, events[index][1].start)\n          movePoint(start, -use)\n          movePoint(end, use)\n          openingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start,\n            end: Object.assign({}, events[open][1].end)\n          }\n          closingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: Object.assign({}, events[index][1].start),\n            end\n          }\n          text = {\n            type: use > 1 ? 'strongText' : 'emphasisText',\n            start: Object.assign({}, events[open][1].end),\n            end: Object.assign({}, events[index][1].start)\n          }\n          group = {\n            type: use > 1 ? 'strong' : 'emphasis',\n            start: Object.assign({}, openingSequence.start),\n            end: Object.assign({}, closingSequence.end)\n          }\n          events[open][1].end = Object.assign({}, openingSequence.start)\n          events[index][1].start = Object.assign({}, closingSequence.end)\n          nextEvents = [] // If there are more markers in the opening, add them before.\n\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = push(nextEvents, [\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context]\n            ])\n          } // Opening.\n\n          nextEvents = push(nextEvents, [\n            ['enter', group, context],\n            ['enter', openingSequence, context],\n            ['exit', openingSequence, context],\n            ['enter', text, context]\n          ]) // Between.\n\n          nextEvents = push(\n            nextEvents,\n            resolveAll(\n              context.parser.constructs.insideSpan.null,\n              events.slice(open + 1, index),\n              context\n            )\n          ) // Closing.\n\n          nextEvents = push(nextEvents, [\n            ['exit', text, context],\n            ['enter', closingSequence, context],\n            ['exit', closingSequence, context],\n            ['exit', group, context]\n          ]) // If there are more markers in the closing, add them after.\n\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2\n            nextEvents = push(nextEvents, [\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context]\n            ])\n          } else {\n            offset = 0\n          }\n\n          splice(events, open - 1, index - open + 3, nextEvents)\n          index = open + nextEvents.length - offset - 2\n          break\n        }\n      }\n    }\n  } // Remove remaining sequences.\n\n  index = -1\n\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data'\n    }\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeAttention(effects, ok) {\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null\n  const previous = this.previous\n  const before = classifyCharacter(previous)\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('attentionSequence')\n    marker = code\n    return sequence(code)\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return sequence\n    }\n\n    const token = effects.exit('attentionSequence')\n    const after = classifyCharacter(code)\n    const open =\n      !after || (after === 2 && before) || attentionMarkers.includes(code)\n    const close =\n      !before || (before === 2 && after) || attentionMarkers.includes(previous)\n    token._open = Boolean(marker === 42 ? open : open && (before || !close))\n    token._close = Boolean(marker === 42 ? close : close && (after || !open))\n    return ok(code)\n  }\n}\n/**\n * Move a point a bit.\n *\n * Note: `move` only works inside lines! Its not possible to move past other\n * chunks (replacement characters, tabs, or line endings).\n *\n * @param {Point} point\n * @param {number} offset\n * @returns {void}\n */\n\nfunction movePoint(point, offset) {\n  point.column += offset\n  point.offset += offset\n  point._bufferIndex += offset\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\n\n/**\n * Classify whether a character code represents whitespace, punctuation, or\n * something else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * Note that eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n * @returns {number|undefined}\n */\nexport function classifyCharacter(code) {\n  if (\n    code === null ||\n    markdownLineEndingOrSpace(code) ||\n    unicodeWhitespace(code)\n  ) {\n    return 1\n  }\n\n  if (unicodePunctuation(code)) {\n    return 2\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiAtext,\n  asciiControl\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const autolink = {\n  name: 'autolink',\n  tokenize: tokenizeAutolink\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeAutolink(effects, ok, nok) {\n  let size = 1\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('autolink')\n    effects.enter('autolinkMarker')\n    effects.consume(code)\n    effects.exit('autolinkMarker')\n    effects.enter('autolinkProtocol')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return schemeOrEmailAtext\n    }\n\n    return asciiAtext(code) ? emailAtext(code) : nok(code)\n  }\n  /** @type {State} */\n\n  function schemeOrEmailAtext(code) {\n    return code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)\n      ? schemeInsideOrEmailAtext(code)\n      : emailAtext(code)\n  }\n  /** @type {State} */\n\n  function schemeInsideOrEmailAtext(code) {\n    if (code === 58) {\n      effects.consume(code)\n      return urlInside\n    }\n\n    if (\n      (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) &&\n      size++ < 32\n    ) {\n      effects.consume(code)\n      return schemeInsideOrEmailAtext\n    }\n\n    return emailAtext(code)\n  }\n  /** @type {State} */\n\n  function urlInside(code) {\n    if (code === 62) {\n      effects.exit('autolinkProtocol')\n      return end(code)\n    }\n\n    if (code === null || code === 32 || code === 60 || asciiControl(code)) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return urlInside\n  }\n  /** @type {State} */\n\n  function emailAtext(code) {\n    if (code === 64) {\n      effects.consume(code)\n      size = 0\n      return emailAtSignOrDot\n    }\n\n    if (asciiAtext(code)) {\n      effects.consume(code)\n      return emailAtext\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function emailAtSignOrDot(code) {\n    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)\n  }\n  /** @type {State} */\n\n  function emailLabel(code) {\n    if (code === 46) {\n      effects.consume(code)\n      size = 0\n      return emailAtSignOrDot\n    }\n\n    if (code === 62) {\n      // Exit, then change the type.\n      effects.exit('autolinkProtocol').type = 'autolinkEmail'\n      return end(code)\n    }\n\n    return emailValue(code)\n  }\n  /** @type {State} */\n\n  function emailValue(code) {\n    if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {\n      effects.consume(code)\n      return code === 45 ? emailValue : emailLabel\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function end(code) {\n    effects.enter('autolinkMarker')\n    effects.consume(code)\n    effects.exit('autolinkMarker')\n    effects.exit('autolink')\n    return ok\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownSpace} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {\n    tokenize: tokenizeBlockQuoteContinuation\n  },\n  exit\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (code === 62) {\n      const state = self.containerState\n\n      if (!state.open) {\n        effects.enter('blockQuote', {\n          _container: true\n        })\n        state.open = true\n      }\n\n      effects.enter('blockQuotePrefix')\n      effects.enter('blockQuoteMarker')\n      effects.consume(code)\n      effects.exit('blockQuoteMarker')\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter('blockQuotePrefixWhitespace')\n      effects.consume(code)\n      effects.exit('blockQuotePrefixWhitespace')\n      effects.exit('blockQuotePrefix')\n      return ok\n    }\n\n    effects.exit('blockQuotePrefix')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.attempt(blockQuote, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4\n  )\n}\n/** @type {Exiter} */\n\nfunction exit(effects) {\n  effects.exit('blockQuote')\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {asciiPunctuation} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const characterEscape = {\n  name: 'characterEscape',\n  tokenize: tokenizeCharacterEscape\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCharacterEscape(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('characterEscape')\n    effects.enter('escapeMarker')\n    effects.consume(code)\n    effects.exit('escapeMarker')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (asciiPunctuation(code)) {\n      effects.enter('characterEscapeValue')\n      effects.consume(code)\n      effects.exit('characterEscapeValue')\n      effects.exit('characterEscape')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {\n  asciiAlphanumeric,\n  asciiDigit,\n  asciiHexDigit\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const characterReference = {\n  name: 'characterReference',\n  tokenize: tokenizeCharacterReference\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCharacterReference(effects, ok, nok) {\n  const self = this\n  let size = 0\n  /** @type {number} */\n\n  let max\n  /** @type {(code: Code) => code is number} */\n\n  let test\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('characterReference')\n    effects.enter('characterReferenceMarker')\n    effects.consume(code)\n    effects.exit('characterReferenceMarker')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 35) {\n      effects.enter('characterReferenceMarkerNumeric')\n      effects.consume(code)\n      effects.exit('characterReferenceMarkerNumeric')\n      return numeric\n    }\n\n    effects.enter('characterReferenceValue')\n    max = 31\n    test = asciiAlphanumeric\n    return value(code)\n  }\n  /** @type {State} */\n\n  function numeric(code) {\n    if (code === 88 || code === 120) {\n      effects.enter('characterReferenceMarkerHexadecimal')\n      effects.consume(code)\n      effects.exit('characterReferenceMarkerHexadecimal')\n      effects.enter('characterReferenceValue')\n      max = 6\n      test = asciiHexDigit\n      return value\n    }\n\n    effects.enter('characterReferenceValue')\n    max = 7\n    test = asciiDigit\n    return value(code)\n  }\n  /** @type {State} */\n\n  function value(code) {\n    /** @type {Token} */\n    let token\n\n    if (code === 59 && size) {\n      token = effects.exit('characterReferenceValue')\n\n      if (\n        test === asciiAlphanumeric &&\n        !decodeNamedCharacterReference(self.sliceSerialize(token))\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('characterReferenceMarker')\n      effects.consume(code)\n      effects.exit('characterReferenceMarker')\n      effects.exit('characterReference')\n      return ok\n    }\n\n    if (test(code) && size++ < max) {\n      effects.consume(code)\n      return value\n    }\n\n    return nok(code)\n  }\n}\n","import {characterEntities} from 'character-entities'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Decode a single character reference (without the `&` or `;`).\n * You probably only need this when youre building parsers yourself that follow\n * different rules compared to HTML.\n * This is optimized to be tiny in browsers.\n *\n * @param {string} value\n *   `notin` (named), `#123` (deci), `#x123` (hexa).\n * @returns {string|false}\n *   Decoded reference.\n */\nexport function decodeNamedCharacterReference(value) {\n  return own.call(characterEntities, value) ? characterEntities[value] : false\n}\n","/**\n * Map of named character references.\n *\n * @type {Record<string, string>}\n */\nexport const characterEntities = {\n  AElig: '',\n  AMP: '&',\n  Aacute: '',\n  Abreve: '',\n  Acirc: '',\n  Acy: '',\n  Afr: '',\n  Agrave: '',\n  Alpha: '',\n  Amacr: '',\n  And: '',\n  Aogon: '',\n  Aopf: '',\n  ApplyFunction: '',\n  Aring: '',\n  Ascr: '',\n  Assign: '',\n  Atilde: '',\n  Auml: '',\n  Backslash: '',\n  Barv: '',\n  Barwed: '',\n  Bcy: '',\n  Because: '',\n  Bernoullis: '',\n  Beta: '',\n  Bfr: '',\n  Bopf: '',\n  Breve: '',\n  Bscr: '',\n  Bumpeq: '',\n  CHcy: '',\n  COPY: '',\n  Cacute: '',\n  Cap: '',\n  CapitalDifferentialD: '',\n  Cayleys: '',\n  Ccaron: '',\n  Ccedil: '',\n  Ccirc: '',\n  Cconint: '',\n  Cdot: '',\n  Cedilla: '',\n  CenterDot: '',\n  Cfr: '',\n  Chi: '',\n  CircleDot: '',\n  CircleMinus: '',\n  CirclePlus: '',\n  CircleTimes: '',\n  ClockwiseContourIntegral: '',\n  CloseCurlyDoubleQuote: '',\n  CloseCurlyQuote: '',\n  Colon: '',\n  Colone: '',\n  Congruent: '',\n  Conint: '',\n  ContourIntegral: '',\n  Copf: '',\n  Coproduct: '',\n  CounterClockwiseContourIntegral: '',\n  Cross: '',\n  Cscr: '',\n  Cup: '',\n  CupCap: '',\n  DD: '',\n  DDotrahd: '',\n  DJcy: '',\n  DScy: '',\n  DZcy: '',\n  Dagger: '',\n  Darr: '',\n  Dashv: '',\n  Dcaron: '',\n  Dcy: '',\n  Del: '',\n  Delta: '',\n  Dfr: '',\n  DiacriticalAcute: '',\n  DiacriticalDot: '',\n  DiacriticalDoubleAcute: '',\n  DiacriticalGrave: '`',\n  DiacriticalTilde: '',\n  Diamond: '',\n  DifferentialD: '',\n  Dopf: '',\n  Dot: '',\n  DotDot: '',\n  DotEqual: '',\n  DoubleContourIntegral: '',\n  DoubleDot: '',\n  DoubleDownArrow: '',\n  DoubleLeftArrow: '',\n  DoubleLeftRightArrow: '',\n  DoubleLeftTee: '',\n  DoubleLongLeftArrow: '',\n  DoubleLongLeftRightArrow: '',\n  DoubleLongRightArrow: '',\n  DoubleRightArrow: '',\n  DoubleRightTee: '',\n  DoubleUpArrow: '',\n  DoubleUpDownArrow: '',\n  DoubleVerticalBar: '',\n  DownArrow: '',\n  DownArrowBar: '',\n  DownArrowUpArrow: '',\n  DownBreve: '',\n  DownLeftRightVector: '',\n  DownLeftTeeVector: '',\n  DownLeftVector: '',\n  DownLeftVectorBar: '',\n  DownRightTeeVector: '',\n  DownRightVector: '',\n  DownRightVectorBar: '',\n  DownTee: '',\n  DownTeeArrow: '',\n  Downarrow: '',\n  Dscr: '',\n  Dstrok: '',\n  ENG: '',\n  ETH: '',\n  Eacute: '',\n  Ecaron: '',\n  Ecirc: '',\n  Ecy: '',\n  Edot: '',\n  Efr: '',\n  Egrave: '',\n  Element: '',\n  Emacr: '',\n  EmptySmallSquare: '',\n  EmptyVerySmallSquare: '',\n  Eogon: '',\n  Eopf: '',\n  Epsilon: '',\n  Equal: '',\n  EqualTilde: '',\n  Equilibrium: '',\n  Escr: '',\n  Esim: '',\n  Eta: '',\n  Euml: '',\n  Exists: '',\n  ExponentialE: '',\n  Fcy: '',\n  Ffr: '',\n  FilledSmallSquare: '',\n  FilledVerySmallSquare: '',\n  Fopf: '',\n  ForAll: '',\n  Fouriertrf: '',\n  Fscr: '',\n  GJcy: '',\n  GT: '>',\n  Gamma: '',\n  Gammad: '',\n  Gbreve: '',\n  Gcedil: '',\n  Gcirc: '',\n  Gcy: '',\n  Gdot: '',\n  Gfr: '',\n  Gg: '',\n  Gopf: '',\n  GreaterEqual: '',\n  GreaterEqualLess: '',\n  GreaterFullEqual: '',\n  GreaterGreater: '',\n  GreaterLess: '',\n  GreaterSlantEqual: '',\n  GreaterTilde: '',\n  Gscr: '',\n  Gt: '',\n  HARDcy: '',\n  Hacek: '',\n  Hat: '^',\n  Hcirc: '',\n  Hfr: '',\n  HilbertSpace: '',\n  Hopf: '',\n  HorizontalLine: '',\n  Hscr: '',\n  Hstrok: '',\n  HumpDownHump: '',\n  HumpEqual: '',\n  IEcy: '',\n  IJlig: '',\n  IOcy: '',\n  Iacute: '',\n  Icirc: '',\n  Icy: '',\n  Idot: '',\n  Ifr: '',\n  Igrave: '',\n  Im: '',\n  Imacr: '',\n  ImaginaryI: '',\n  Implies: '',\n  Int: '',\n  Integral: '',\n  Intersection: '',\n  InvisibleComma: '',\n  InvisibleTimes: '',\n  Iogon: '',\n  Iopf: '',\n  Iota: '',\n  Iscr: '',\n  Itilde: '',\n  Iukcy: '',\n  Iuml: '',\n  Jcirc: '',\n  Jcy: '',\n  Jfr: '',\n  Jopf: '',\n  Jscr: '',\n  Jsercy: '',\n  Jukcy: '',\n  KHcy: '',\n  KJcy: '',\n  Kappa: '',\n  Kcedil: '',\n  Kcy: '',\n  Kfr: '',\n  Kopf: '',\n  Kscr: '',\n  LJcy: '',\n  LT: '<',\n  Lacute: '',\n  Lambda: '',\n  Lang: '',\n  Laplacetrf: '',\n  Larr: '',\n  Lcaron: '',\n  Lcedil: '',\n  Lcy: '',\n  LeftAngleBracket: '',\n  LeftArrow: '',\n  LeftArrowBar: '',\n  LeftArrowRightArrow: '',\n  LeftCeiling: '',\n  LeftDoubleBracket: '',\n  LeftDownTeeVector: '',\n  LeftDownVector: '',\n  LeftDownVectorBar: '',\n  LeftFloor: '',\n  LeftRightArrow: '',\n  LeftRightVector: '',\n  LeftTee: '',\n  LeftTeeArrow: '',\n  LeftTeeVector: '',\n  LeftTriangle: '',\n  LeftTriangleBar: '',\n  LeftTriangleEqual: '',\n  LeftUpDownVector: '',\n  LeftUpTeeVector: '',\n  LeftUpVector: '',\n  LeftUpVectorBar: '',\n  LeftVector: '',\n  LeftVectorBar: '',\n  Leftarrow: '',\n  Leftrightarrow: '',\n  LessEqualGreater: '',\n  LessFullEqual: '',\n  LessGreater: '',\n  LessLess: '',\n  LessSlantEqual: '',\n  LessTilde: '',\n  Lfr: '',\n  Ll: '',\n  Lleftarrow: '',\n  Lmidot: '',\n  LongLeftArrow: '',\n  LongLeftRightArrow: '',\n  LongRightArrow: '',\n  Longleftarrow: '',\n  Longleftrightarrow: '',\n  Longrightarrow: '',\n  Lopf: '',\n  LowerLeftArrow: '',\n  LowerRightArrow: '',\n  Lscr: '',\n  Lsh: '',\n  Lstrok: '',\n  Lt: '',\n  Map: '',\n  Mcy: '',\n  MediumSpace: '',\n  Mellintrf: '',\n  Mfr: '',\n  MinusPlus: '',\n  Mopf: '',\n  Mscr: '',\n  Mu: '',\n  NJcy: '',\n  Nacute: '',\n  Ncaron: '',\n  Ncedil: '',\n  Ncy: '',\n  NegativeMediumSpace: '',\n  NegativeThickSpace: '',\n  NegativeThinSpace: '',\n  NegativeVeryThinSpace: '',\n  NestedGreaterGreater: '',\n  NestedLessLess: '',\n  NewLine: '\\n',\n  Nfr: '',\n  NoBreak: '',\n  NonBreakingSpace: '',\n  Nopf: '',\n  Not: '',\n  NotCongruent: '',\n  NotCupCap: '',\n  NotDoubleVerticalBar: '',\n  NotElement: '',\n  NotEqual: '',\n  NotEqualTilde: '',\n  NotExists: '',\n  NotGreater: '',\n  NotGreaterEqual: '',\n  NotGreaterFullEqual: '',\n  NotGreaterGreater: '',\n  NotGreaterLess: '',\n  NotGreaterSlantEqual: '',\n  NotGreaterTilde: '',\n  NotHumpDownHump: '',\n  NotHumpEqual: '',\n  NotLeftTriangle: '',\n  NotLeftTriangleBar: '',\n  NotLeftTriangleEqual: '',\n  NotLess: '',\n  NotLessEqual: '',\n  NotLessGreater: '',\n  NotLessLess: '',\n  NotLessSlantEqual: '',\n  NotLessTilde: '',\n  NotNestedGreaterGreater: '',\n  NotNestedLessLess: '',\n  NotPrecedes: '',\n  NotPrecedesEqual: '',\n  NotPrecedesSlantEqual: '',\n  NotReverseElement: '',\n  NotRightTriangle: '',\n  NotRightTriangleBar: '',\n  NotRightTriangleEqual: '',\n  NotSquareSubset: '',\n  NotSquareSubsetEqual: '',\n  NotSquareSuperset: '',\n  NotSquareSupersetEqual: '',\n  NotSubset: '',\n  NotSubsetEqual: '',\n  NotSucceeds: '',\n  NotSucceedsEqual: '',\n  NotSucceedsSlantEqual: '',\n  NotSucceedsTilde: '',\n  NotSuperset: '',\n  NotSupersetEqual: '',\n  NotTilde: '',\n  NotTildeEqual: '',\n  NotTildeFullEqual: '',\n  NotTildeTilde: '',\n  NotVerticalBar: '',\n  Nscr: '',\n  Ntilde: '',\n  Nu: '',\n  OElig: '',\n  Oacute: '',\n  Ocirc: '',\n  Ocy: '',\n  Odblac: '',\n  Ofr: '',\n  Ograve: '',\n  Omacr: '',\n  Omega: '',\n  Omicron: '',\n  Oopf: '',\n  OpenCurlyDoubleQuote: '',\n  OpenCurlyQuote: '',\n  Or: '',\n  Oscr: '',\n  Oslash: '',\n  Otilde: '',\n  Otimes: '',\n  Ouml: '',\n  OverBar: '',\n  OverBrace: '',\n  OverBracket: '',\n  OverParenthesis: '',\n  PartialD: '',\n  Pcy: '',\n  Pfr: '',\n  Phi: '',\n  Pi: '',\n  PlusMinus: '',\n  Poincareplane: '',\n  Popf: '',\n  Pr: '',\n  Precedes: '',\n  PrecedesEqual: '',\n  PrecedesSlantEqual: '',\n  PrecedesTilde: '',\n  Prime: '',\n  Product: '',\n  Proportion: '',\n  Proportional: '',\n  Pscr: '',\n  Psi: '',\n  QUOT: '\"',\n  Qfr: '',\n  Qopf: '',\n  Qscr: '',\n  RBarr: '',\n  REG: '',\n  Racute: '',\n  Rang: '',\n  Rarr: '',\n  Rarrtl: '',\n  Rcaron: '',\n  Rcedil: '',\n  Rcy: '',\n  Re: '',\n  ReverseElement: '',\n  ReverseEquilibrium: '',\n  ReverseUpEquilibrium: '',\n  Rfr: '',\n  Rho: '',\n  RightAngleBracket: '',\n  RightArrow: '',\n  RightArrowBar: '',\n  RightArrowLeftArrow: '',\n  RightCeiling: '',\n  RightDoubleBracket: '',\n  RightDownTeeVector: '',\n  RightDownVector: '',\n  RightDownVectorBar: '',\n  RightFloor: '',\n  RightTee: '',\n  RightTeeArrow: '',\n  RightTeeVector: '',\n  RightTriangle: '',\n  RightTriangleBar: '',\n  RightTriangleEqual: '',\n  RightUpDownVector: '',\n  RightUpTeeVector: '',\n  RightUpVector: '',\n  RightUpVectorBar: '',\n  RightVector: '',\n  RightVectorBar: '',\n  Rightarrow: '',\n  Ropf: '',\n  RoundImplies: '',\n  Rrightarrow: '',\n  Rscr: '',\n  Rsh: '',\n  RuleDelayed: '',\n  SHCHcy: '',\n  SHcy: '',\n  SOFTcy: '',\n  Sacute: '',\n  Sc: '',\n  Scaron: '',\n  Scedil: '',\n  Scirc: '',\n  Scy: '',\n  Sfr: '',\n  ShortDownArrow: '',\n  ShortLeftArrow: '',\n  ShortRightArrow: '',\n  ShortUpArrow: '',\n  Sigma: '',\n  SmallCircle: '',\n  Sopf: '',\n  Sqrt: '',\n  Square: '',\n  SquareIntersection: '',\n  SquareSubset: '',\n  SquareSubsetEqual: '',\n  SquareSuperset: '',\n  SquareSupersetEqual: '',\n  SquareUnion: '',\n  Sscr: '',\n  Star: '',\n  Sub: '',\n  Subset: '',\n  SubsetEqual: '',\n  Succeeds: '',\n  SucceedsEqual: '',\n  SucceedsSlantEqual: '',\n  SucceedsTilde: '',\n  SuchThat: '',\n  Sum: '',\n  Sup: '',\n  Superset: '',\n  SupersetEqual: '',\n  Supset: '',\n  THORN: '',\n  TRADE: '',\n  TSHcy: '',\n  TScy: '',\n  Tab: '\\t',\n  Tau: '',\n  Tcaron: '',\n  Tcedil: '',\n  Tcy: '',\n  Tfr: '',\n  Therefore: '',\n  Theta: '',\n  ThickSpace: '',\n  ThinSpace: '',\n  Tilde: '',\n  TildeEqual: '',\n  TildeFullEqual: '',\n  TildeTilde: '',\n  Topf: '',\n  TripleDot: '',\n  Tscr: '',\n  Tstrok: '',\n  Uacute: '',\n  Uarr: '',\n  Uarrocir: '',\n  Ubrcy: '',\n  Ubreve: '',\n  Ucirc: '',\n  Ucy: '',\n  Udblac: '',\n  Ufr: '',\n  Ugrave: '',\n  Umacr: '',\n  UnderBar: '_',\n  UnderBrace: '',\n  UnderBracket: '',\n  UnderParenthesis: '',\n  Union: '',\n  UnionPlus: '',\n  Uogon: '',\n  Uopf: '',\n  UpArrow: '',\n  UpArrowBar: '',\n  UpArrowDownArrow: '',\n  UpDownArrow: '',\n  UpEquilibrium: '',\n  UpTee: '',\n  UpTeeArrow: '',\n  Uparrow: '',\n  Updownarrow: '',\n  UpperLeftArrow: '',\n  UpperRightArrow: '',\n  Upsi: '',\n  Upsilon: '',\n  Uring: '',\n  Uscr: '',\n  Utilde: '',\n  Uuml: '',\n  VDash: '',\n  Vbar: '',\n  Vcy: '',\n  Vdash: '',\n  Vdashl: '',\n  Vee: '',\n  Verbar: '',\n  Vert: '',\n  VerticalBar: '',\n  VerticalLine: '|',\n  VerticalSeparator: '',\n  VerticalTilde: '',\n  VeryThinSpace: '',\n  Vfr: '',\n  Vopf: '',\n  Vscr: '',\n  Vvdash: '',\n  Wcirc: '',\n  Wedge: '',\n  Wfr: '',\n  Wopf: '',\n  Wscr: '',\n  Xfr: '',\n  Xi: '',\n  Xopf: '',\n  Xscr: '',\n  YAcy: '',\n  YIcy: '',\n  YUcy: '',\n  Yacute: '',\n  Ycirc: '',\n  Ycy: '',\n  Yfr: '',\n  Yopf: '',\n  Yscr: '',\n  Yuml: '',\n  ZHcy: '',\n  Zacute: '',\n  Zcaron: '',\n  Zcy: '',\n  Zdot: '',\n  ZeroWidthSpace: '',\n  Zeta: '',\n  Zfr: '',\n  Zopf: '',\n  Zscr: '',\n  aacute: '',\n  abreve: '',\n  ac: '',\n  acE: '',\n  acd: '',\n  acirc: '',\n  acute: '',\n  acy: '',\n  aelig: '',\n  af: '',\n  afr: '',\n  agrave: '',\n  alefsym: '',\n  aleph: '',\n  alpha: '',\n  amacr: '',\n  amalg: '',\n  amp: '&',\n  and: '',\n  andand: '',\n  andd: '',\n  andslope: '',\n  andv: '',\n  ang: '',\n  ange: '',\n  angle: '',\n  angmsd: '',\n  angmsdaa: '',\n  angmsdab: '',\n  angmsdac: '',\n  angmsdad: '',\n  angmsdae: '',\n  angmsdaf: '',\n  angmsdag: '',\n  angmsdah: '',\n  angrt: '',\n  angrtvb: '',\n  angrtvbd: '',\n  angsph: '',\n  angst: '',\n  angzarr: '',\n  aogon: '',\n  aopf: '',\n  ap: '',\n  apE: '',\n  apacir: '',\n  ape: '',\n  apid: '',\n  apos: \"'\",\n  approx: '',\n  approxeq: '',\n  aring: '',\n  ascr: '',\n  ast: '*',\n  asymp: '',\n  asympeq: '',\n  atilde: '',\n  auml: '',\n  awconint: '',\n  awint: '',\n  bNot: '',\n  backcong: '',\n  backepsilon: '',\n  backprime: '',\n  backsim: '',\n  backsimeq: '',\n  barvee: '',\n  barwed: '',\n  barwedge: '',\n  bbrk: '',\n  bbrktbrk: '',\n  bcong: '',\n  bcy: '',\n  bdquo: '',\n  becaus: '',\n  because: '',\n  bemptyv: '',\n  bepsi: '',\n  bernou: '',\n  beta: '',\n  beth: '',\n  between: '',\n  bfr: '',\n  bigcap: '',\n  bigcirc: '',\n  bigcup: '',\n  bigodot: '',\n  bigoplus: '',\n  bigotimes: '',\n  bigsqcup: '',\n  bigstar: '',\n  bigtriangledown: '',\n  bigtriangleup: '',\n  biguplus: '',\n  bigvee: '',\n  bigwedge: '',\n  bkarow: '',\n  blacklozenge: '',\n  blacksquare: '',\n  blacktriangle: '',\n  blacktriangledown: '',\n  blacktriangleleft: '',\n  blacktriangleright: '',\n  blank: '',\n  blk12: '',\n  blk14: '',\n  blk34: '',\n  block: '',\n  bne: '=',\n  bnequiv: '',\n  bnot: '',\n  bopf: '',\n  bot: '',\n  bottom: '',\n  bowtie: '',\n  boxDL: '',\n  boxDR: '',\n  boxDl: '',\n  boxDr: '',\n  boxH: '',\n  boxHD: '',\n  boxHU: '',\n  boxHd: '',\n  boxHu: '',\n  boxUL: '',\n  boxUR: '',\n  boxUl: '',\n  boxUr: '',\n  boxV: '',\n  boxVH: '',\n  boxVL: '',\n  boxVR: '',\n  boxVh: '',\n  boxVl: '',\n  boxVr: '',\n  boxbox: '',\n  boxdL: '',\n  boxdR: '',\n  boxdl: '',\n  boxdr: '',\n  boxh: '',\n  boxhD: '',\n  boxhU: '',\n  boxhd: '',\n  boxhu: '',\n  boxminus: '',\n  boxplus: '',\n  boxtimes: '',\n  boxuL: '',\n  boxuR: '',\n  boxul: '',\n  boxur: '',\n  boxv: '',\n  boxvH: '',\n  boxvL: '',\n  boxvR: '',\n  boxvh: '',\n  boxvl: '',\n  boxvr: '',\n  bprime: '',\n  breve: '',\n  brvbar: '',\n  bscr: '',\n  bsemi: '',\n  bsim: '',\n  bsime: '',\n  bsol: '\\\\',\n  bsolb: '',\n  bsolhsub: '',\n  bull: '',\n  bullet: '',\n  bump: '',\n  bumpE: '',\n  bumpe: '',\n  bumpeq: '',\n  cacute: '',\n  cap: '',\n  capand: '',\n  capbrcup: '',\n  capcap: '',\n  capcup: '',\n  capdot: '',\n  caps: '',\n  caret: '',\n  caron: '',\n  ccaps: '',\n  ccaron: '',\n  ccedil: '',\n  ccirc: '',\n  ccups: '',\n  ccupssm: '',\n  cdot: '',\n  cedil: '',\n  cemptyv: '',\n  cent: '',\n  centerdot: '',\n  cfr: '',\n  chcy: '',\n  check: '',\n  checkmark: '',\n  chi: '',\n  cir: '',\n  cirE: '',\n  circ: '',\n  circeq: '',\n  circlearrowleft: '',\n  circlearrowright: '',\n  circledR: '',\n  circledS: '',\n  circledast: '',\n  circledcirc: '',\n  circleddash: '',\n  cire: '',\n  cirfnint: '',\n  cirmid: '',\n  cirscir: '',\n  clubs: '',\n  clubsuit: '',\n  colon: ':',\n  colone: '',\n  coloneq: '',\n  comma: ',',\n  commat: '@',\n  comp: '',\n  compfn: '',\n  complement: '',\n  complexes: '',\n  cong: '',\n  congdot: '',\n  conint: '',\n  copf: '',\n  coprod: '',\n  copy: '',\n  copysr: '',\n  crarr: '',\n  cross: '',\n  cscr: '',\n  csub: '',\n  csube: '',\n  csup: '',\n  csupe: '',\n  ctdot: '',\n  cudarrl: '',\n  cudarrr: '',\n  cuepr: '',\n  cuesc: '',\n  cularr: '',\n  cularrp: '',\n  cup: '',\n  cupbrcap: '',\n  cupcap: '',\n  cupcup: '',\n  cupdot: '',\n  cupor: '',\n  cups: '',\n  curarr: '',\n  curarrm: '',\n  curlyeqprec: '',\n  curlyeqsucc: '',\n  curlyvee: '',\n  curlywedge: '',\n  curren: '',\n  curvearrowleft: '',\n  curvearrowright: '',\n  cuvee: '',\n  cuwed: '',\n  cwconint: '',\n  cwint: '',\n  cylcty: '',\n  dArr: '',\n  dHar: '',\n  dagger: '',\n  daleth: '',\n  darr: '',\n  dash: '',\n  dashv: '',\n  dbkarow: '',\n  dblac: '',\n  dcaron: '',\n  dcy: '',\n  dd: '',\n  ddagger: '',\n  ddarr: '',\n  ddotseq: '',\n  deg: '',\n  delta: '',\n  demptyv: '',\n  dfisht: '',\n  dfr: '',\n  dharl: '',\n  dharr: '',\n  diam: '',\n  diamond: '',\n  diamondsuit: '',\n  diams: '',\n  die: '',\n  digamma: '',\n  disin: '',\n  div: '',\n  divide: '',\n  divideontimes: '',\n  divonx: '',\n  djcy: '',\n  dlcorn: '',\n  dlcrop: '',\n  dollar: '$',\n  dopf: '',\n  dot: '',\n  doteq: '',\n  doteqdot: '',\n  dotminus: '',\n  dotplus: '',\n  dotsquare: '',\n  doublebarwedge: '',\n  downarrow: '',\n  downdownarrows: '',\n  downharpoonleft: '',\n  downharpoonright: '',\n  drbkarow: '',\n  drcorn: '',\n  drcrop: '',\n  dscr: '',\n  dscy: '',\n  dsol: '',\n  dstrok: '',\n  dtdot: '',\n  dtri: '',\n  dtrif: '',\n  duarr: '',\n  duhar: '',\n  dwangle: '',\n  dzcy: '',\n  dzigrarr: '',\n  eDDot: '',\n  eDot: '',\n  eacute: '',\n  easter: '',\n  ecaron: '',\n  ecir: '',\n  ecirc: '',\n  ecolon: '',\n  ecy: '',\n  edot: '',\n  ee: '',\n  efDot: '',\n  efr: '',\n  eg: '',\n  egrave: '',\n  egs: '',\n  egsdot: '',\n  el: '',\n  elinters: '',\n  ell: '',\n  els: '',\n  elsdot: '',\n  emacr: '',\n  empty: '',\n  emptyset: '',\n  emptyv: '',\n  emsp13: '',\n  emsp14: '',\n  emsp: '',\n  eng: '',\n  ensp: '',\n  eogon: '',\n  eopf: '',\n  epar: '',\n  eparsl: '',\n  eplus: '',\n  epsi: '',\n  epsilon: '',\n  epsiv: '',\n  eqcirc: '',\n  eqcolon: '',\n  eqsim: '',\n  eqslantgtr: '',\n  eqslantless: '',\n  equals: '=',\n  equest: '',\n  equiv: '',\n  equivDD: '',\n  eqvparsl: '',\n  erDot: '',\n  erarr: '',\n  escr: '',\n  esdot: '',\n  esim: '',\n  eta: '',\n  eth: '',\n  euml: '',\n  euro: '',\n  excl: '!',\n  exist: '',\n  expectation: '',\n  exponentiale: '',\n  fallingdotseq: '',\n  fcy: '',\n  female: '',\n  ffilig: '',\n  fflig: '',\n  ffllig: '',\n  ffr: '',\n  filig: '',\n  fjlig: 'fj',\n  flat: '',\n  fllig: '',\n  fltns: '',\n  fnof: '',\n  fopf: '',\n  forall: '',\n  fork: '',\n  forkv: '',\n  fpartint: '',\n  frac12: '',\n  frac13: '',\n  frac14: '',\n  frac15: '',\n  frac16: '',\n  frac18: '',\n  frac23: '',\n  frac25: '',\n  frac34: '',\n  frac35: '',\n  frac38: '',\n  frac45: '',\n  frac56: '',\n  frac58: '',\n  frac78: '',\n  frasl: '',\n  frown: '',\n  fscr: '',\n  gE: '',\n  gEl: '',\n  gacute: '',\n  gamma: '',\n  gammad: '',\n  gap: '',\n  gbreve: '',\n  gcirc: '',\n  gcy: '',\n  gdot: '',\n  ge: '',\n  gel: '',\n  geq: '',\n  geqq: '',\n  geqslant: '',\n  ges: '',\n  gescc: '',\n  gesdot: '',\n  gesdoto: '',\n  gesdotol: '',\n  gesl: '',\n  gesles: '',\n  gfr: '',\n  gg: '',\n  ggg: '',\n  gimel: '',\n  gjcy: '',\n  gl: '',\n  glE: '',\n  gla: '',\n  glj: '',\n  gnE: '',\n  gnap: '',\n  gnapprox: '',\n  gne: '',\n  gneq: '',\n  gneqq: '',\n  gnsim: '',\n  gopf: '',\n  grave: '`',\n  gscr: '',\n  gsim: '',\n  gsime: '',\n  gsiml: '',\n  gt: '>',\n  gtcc: '',\n  gtcir: '',\n  gtdot: '',\n  gtlPar: '',\n  gtquest: '',\n  gtrapprox: '',\n  gtrarr: '',\n  gtrdot: '',\n  gtreqless: '',\n  gtreqqless: '',\n  gtrless: '',\n  gtrsim: '',\n  gvertneqq: '',\n  gvnE: '',\n  hArr: '',\n  hairsp: '',\n  half: '',\n  hamilt: '',\n  hardcy: '',\n  harr: '',\n  harrcir: '',\n  harrw: '',\n  hbar: '',\n  hcirc: '',\n  hearts: '',\n  heartsuit: '',\n  hellip: '',\n  hercon: '',\n  hfr: '',\n  hksearow: '',\n  hkswarow: '',\n  hoarr: '',\n  homtht: '',\n  hookleftarrow: '',\n  hookrightarrow: '',\n  hopf: '',\n  horbar: '',\n  hscr: '',\n  hslash: '',\n  hstrok: '',\n  hybull: '',\n  hyphen: '',\n  iacute: '',\n  ic: '',\n  icirc: '',\n  icy: '',\n  iecy: '',\n  iexcl: '',\n  iff: '',\n  ifr: '',\n  igrave: '',\n  ii: '',\n  iiiint: '',\n  iiint: '',\n  iinfin: '',\n  iiota: '',\n  ijlig: '',\n  imacr: '',\n  image: '',\n  imagline: '',\n  imagpart: '',\n  imath: '',\n  imof: '',\n  imped: '',\n  in: '',\n  incare: '',\n  infin: '',\n  infintie: '',\n  inodot: '',\n  int: '',\n  intcal: '',\n  integers: '',\n  intercal: '',\n  intlarhk: '',\n  intprod: '',\n  iocy: '',\n  iogon: '',\n  iopf: '',\n  iota: '',\n  iprod: '',\n  iquest: '',\n  iscr: '',\n  isin: '',\n  isinE: '',\n  isindot: '',\n  isins: '',\n  isinsv: '',\n  isinv: '',\n  it: '',\n  itilde: '',\n  iukcy: '',\n  iuml: '',\n  jcirc: '',\n  jcy: '',\n  jfr: '',\n  jmath: '',\n  jopf: '',\n  jscr: '',\n  jsercy: '',\n  jukcy: '',\n  kappa: '',\n  kappav: '',\n  kcedil: '',\n  kcy: '',\n  kfr: '',\n  kgreen: '',\n  khcy: '',\n  kjcy: '',\n  kopf: '',\n  kscr: '',\n  lAarr: '',\n  lArr: '',\n  lAtail: '',\n  lBarr: '',\n  lE: '',\n  lEg: '',\n  lHar: '',\n  lacute: '',\n  laemptyv: '',\n  lagran: '',\n  lambda: '',\n  lang: '',\n  langd: '',\n  langle: '',\n  lap: '',\n  laquo: '',\n  larr: '',\n  larrb: '',\n  larrbfs: '',\n  larrfs: '',\n  larrhk: '',\n  larrlp: '',\n  larrpl: '',\n  larrsim: '',\n  larrtl: '',\n  lat: '',\n  latail: '',\n  late: '',\n  lates: '',\n  lbarr: '',\n  lbbrk: '',\n  lbrace: '{',\n  lbrack: '[',\n  lbrke: '',\n  lbrksld: '',\n  lbrkslu: '',\n  lcaron: '',\n  lcedil: '',\n  lceil: '',\n  lcub: '{',\n  lcy: '',\n  ldca: '',\n  ldquo: '',\n  ldquor: '',\n  ldrdhar: '',\n  ldrushar: '',\n  ldsh: '',\n  le: '',\n  leftarrow: '',\n  leftarrowtail: '',\n  leftharpoondown: '',\n  leftharpoonup: '',\n  leftleftarrows: '',\n  leftrightarrow: '',\n  leftrightarrows: '',\n  leftrightharpoons: '',\n  leftrightsquigarrow: '',\n  leftthreetimes: '',\n  leg: '',\n  leq: '',\n  leqq: '',\n  leqslant: '',\n  les: '',\n  lescc: '',\n  lesdot: '',\n  lesdoto: '',\n  lesdotor: '',\n  lesg: '',\n  lesges: '',\n  lessapprox: '',\n  lessdot: '',\n  lesseqgtr: '',\n  lesseqqgtr: '',\n  lessgtr: '',\n  lesssim: '',\n  lfisht: '',\n  lfloor: '',\n  lfr: '',\n  lg: '',\n  lgE: '',\n  lhard: '',\n  lharu: '',\n  lharul: '',\n  lhblk: '',\n  ljcy: '',\n  ll: '',\n  llarr: '',\n  llcorner: '',\n  llhard: '',\n  lltri: '',\n  lmidot: '',\n  lmoust: '',\n  lmoustache: '',\n  lnE: '',\n  lnap: '',\n  lnapprox: '',\n  lne: '',\n  lneq: '',\n  lneqq: '',\n  lnsim: '',\n  loang: '',\n  loarr: '',\n  lobrk: '',\n  longleftarrow: '',\n  longleftrightarrow: '',\n  longmapsto: '',\n  longrightarrow: '',\n  looparrowleft: '',\n  looparrowright: '',\n  lopar: '',\n  lopf: '',\n  loplus: '',\n  lotimes: '',\n  lowast: '',\n  lowbar: '_',\n  loz: '',\n  lozenge: '',\n  lozf: '',\n  lpar: '(',\n  lparlt: '',\n  lrarr: '',\n  lrcorner: '',\n  lrhar: '',\n  lrhard: '',\n  lrm: '',\n  lrtri: '',\n  lsaquo: '',\n  lscr: '',\n  lsh: '',\n  lsim: '',\n  lsime: '',\n  lsimg: '',\n  lsqb: '[',\n  lsquo: '',\n  lsquor: '',\n  lstrok: '',\n  lt: '<',\n  ltcc: '',\n  ltcir: '',\n  ltdot: '',\n  lthree: '',\n  ltimes: '',\n  ltlarr: '',\n  ltquest: '',\n  ltrPar: '',\n  ltri: '',\n  ltrie: '',\n  ltrif: '',\n  lurdshar: '',\n  luruhar: '',\n  lvertneqq: '',\n  lvnE: '',\n  mDDot: '',\n  macr: '',\n  male: '',\n  malt: '',\n  maltese: '',\n  map: '',\n  mapsto: '',\n  mapstodown: '',\n  mapstoleft: '',\n  mapstoup: '',\n  marker: '',\n  mcomma: '',\n  mcy: '',\n  mdash: '',\n  measuredangle: '',\n  mfr: '',\n  mho: '',\n  micro: '',\n  mid: '',\n  midast: '*',\n  midcir: '',\n  middot: '',\n  minus: '',\n  minusb: '',\n  minusd: '',\n  minusdu: '',\n  mlcp: '',\n  mldr: '',\n  mnplus: '',\n  models: '',\n  mopf: '',\n  mp: '',\n  mscr: '',\n  mstpos: '',\n  mu: '',\n  multimap: '',\n  mumap: '',\n  nGg: '',\n  nGt: '',\n  nGtv: '',\n  nLeftarrow: '',\n  nLeftrightarrow: '',\n  nLl: '',\n  nLt: '',\n  nLtv: '',\n  nRightarrow: '',\n  nVDash: '',\n  nVdash: '',\n  nabla: '',\n  nacute: '',\n  nang: '',\n  nap: '',\n  napE: '',\n  napid: '',\n  napos: '',\n  napprox: '',\n  natur: '',\n  natural: '',\n  naturals: '',\n  nbsp: '',\n  nbump: '',\n  nbumpe: '',\n  ncap: '',\n  ncaron: '',\n  ncedil: '',\n  ncong: '',\n  ncongdot: '',\n  ncup: '',\n  ncy: '',\n  ndash: '',\n  ne: '',\n  neArr: '',\n  nearhk: '',\n  nearr: '',\n  nearrow: '',\n  nedot: '',\n  nequiv: '',\n  nesear: '',\n  nesim: '',\n  nexist: '',\n  nexists: '',\n  nfr: '',\n  ngE: '',\n  nge: '',\n  ngeq: '',\n  ngeqq: '',\n  ngeqslant: '',\n  nges: '',\n  ngsim: '',\n  ngt: '',\n  ngtr: '',\n  nhArr: '',\n  nharr: '',\n  nhpar: '',\n  ni: '',\n  nis: '',\n  nisd: '',\n  niv: '',\n  njcy: '',\n  nlArr: '',\n  nlE: '',\n  nlarr: '',\n  nldr: '',\n  nle: '',\n  nleftarrow: '',\n  nleftrightarrow: '',\n  nleq: '',\n  nleqq: '',\n  nleqslant: '',\n  nles: '',\n  nless: '',\n  nlsim: '',\n  nlt: '',\n  nltri: '',\n  nltrie: '',\n  nmid: '',\n  nopf: '',\n  not: '',\n  notin: '',\n  notinE: '',\n  notindot: '',\n  notinva: '',\n  notinvb: '',\n  notinvc: '',\n  notni: '',\n  notniva: '',\n  notnivb: '',\n  notnivc: '',\n  npar: '',\n  nparallel: '',\n  nparsl: '',\n  npart: '',\n  npolint: '',\n  npr: '',\n  nprcue: '',\n  npre: '',\n  nprec: '',\n  npreceq: '',\n  nrArr: '',\n  nrarr: '',\n  nrarrc: '',\n  nrarrw: '',\n  nrightarrow: '',\n  nrtri: '',\n  nrtrie: '',\n  nsc: '',\n  nsccue: '',\n  nsce: '',\n  nscr: '',\n  nshortmid: '',\n  nshortparallel: '',\n  nsim: '',\n  nsime: '',\n  nsimeq: '',\n  nsmid: '',\n  nspar: '',\n  nsqsube: '',\n  nsqsupe: '',\n  nsub: '',\n  nsubE: '',\n  nsube: '',\n  nsubset: '',\n  nsubseteq: '',\n  nsubseteqq: '',\n  nsucc: '',\n  nsucceq: '',\n  nsup: '',\n  nsupE: '',\n  nsupe: '',\n  nsupset: '',\n  nsupseteq: '',\n  nsupseteqq: '',\n  ntgl: '',\n  ntilde: '',\n  ntlg: '',\n  ntriangleleft: '',\n  ntrianglelefteq: '',\n  ntriangleright: '',\n  ntrianglerighteq: '',\n  nu: '',\n  num: '#',\n  numero: '',\n  numsp: '',\n  nvDash: '',\n  nvHarr: '',\n  nvap: '',\n  nvdash: '',\n  nvge: '',\n  nvgt: '>',\n  nvinfin: '',\n  nvlArr: '',\n  nvle: '',\n  nvlt: '<',\n  nvltrie: '',\n  nvrArr: '',\n  nvrtrie: '',\n  nvsim: '',\n  nwArr: '',\n  nwarhk: '',\n  nwarr: '',\n  nwarrow: '',\n  nwnear: '',\n  oS: '',\n  oacute: '',\n  oast: '',\n  ocir: '',\n  ocirc: '',\n  ocy: '',\n  odash: '',\n  odblac: '',\n  odiv: '',\n  odot: '',\n  odsold: '',\n  oelig: '',\n  ofcir: '',\n  ofr: '',\n  ogon: '',\n  ograve: '',\n  ogt: '',\n  ohbar: '',\n  ohm: '',\n  oint: '',\n  olarr: '',\n  olcir: '',\n  olcross: '',\n  oline: '',\n  olt: '',\n  omacr: '',\n  omega: '',\n  omicron: '',\n  omid: '',\n  ominus: '',\n  oopf: '',\n  opar: '',\n  operp: '',\n  oplus: '',\n  or: '',\n  orarr: '',\n  ord: '',\n  order: '',\n  orderof: '',\n  ordf: '',\n  ordm: '',\n  origof: '',\n  oror: '',\n  orslope: '',\n  orv: '',\n  oscr: '',\n  oslash: '',\n  osol: '',\n  otilde: '',\n  otimes: '',\n  otimesas: '',\n  ouml: '',\n  ovbar: '',\n  par: '',\n  para: '',\n  parallel: '',\n  parsim: '',\n  parsl: '',\n  part: '',\n  pcy: '',\n  percnt: '%',\n  period: '.',\n  permil: '',\n  perp: '',\n  pertenk: '',\n  pfr: '',\n  phi: '',\n  phiv: '',\n  phmmat: '',\n  phone: '',\n  pi: '',\n  pitchfork: '',\n  piv: '',\n  planck: '',\n  planckh: '',\n  plankv: '',\n  plus: '+',\n  plusacir: '',\n  plusb: '',\n  pluscir: '',\n  plusdo: '',\n  plusdu: '',\n  pluse: '',\n  plusmn: '',\n  plussim: '',\n  plustwo: '',\n  pm: '',\n  pointint: '',\n  popf: '',\n  pound: '',\n  pr: '',\n  prE: '',\n  prap: '',\n  prcue: '',\n  pre: '',\n  prec: '',\n  precapprox: '',\n  preccurlyeq: '',\n  preceq: '',\n  precnapprox: '',\n  precneqq: '',\n  precnsim: '',\n  precsim: '',\n  prime: '',\n  primes: '',\n  prnE: '',\n  prnap: '',\n  prnsim: '',\n  prod: '',\n  profalar: '',\n  profline: '',\n  profsurf: '',\n  prop: '',\n  propto: '',\n  prsim: '',\n  prurel: '',\n  pscr: '',\n  psi: '',\n  puncsp: '',\n  qfr: '',\n  qint: '',\n  qopf: '',\n  qprime: '',\n  qscr: '',\n  quaternions: '',\n  quatint: '',\n  quest: '?',\n  questeq: '',\n  quot: '\"',\n  rAarr: '',\n  rArr: '',\n  rAtail: '',\n  rBarr: '',\n  rHar: '',\n  race: '',\n  racute: '',\n  radic: '',\n  raemptyv: '',\n  rang: '',\n  rangd: '',\n  range: '',\n  rangle: '',\n  raquo: '',\n  rarr: '',\n  rarrap: '',\n  rarrb: '',\n  rarrbfs: '',\n  rarrc: '',\n  rarrfs: '',\n  rarrhk: '',\n  rarrlp: '',\n  rarrpl: '',\n  rarrsim: '',\n  rarrtl: '',\n  rarrw: '',\n  ratail: '',\n  ratio: '',\n  rationals: '',\n  rbarr: '',\n  rbbrk: '',\n  rbrace: '}',\n  rbrack: ']',\n  rbrke: '',\n  rbrksld: '',\n  rbrkslu: '',\n  rcaron: '',\n  rcedil: '',\n  rceil: '',\n  rcub: '}',\n  rcy: '',\n  rdca: '',\n  rdldhar: '',\n  rdquo: '',\n  rdquor: '',\n  rdsh: '',\n  real: '',\n  realine: '',\n  realpart: '',\n  reals: '',\n  rect: '',\n  reg: '',\n  rfisht: '',\n  rfloor: '',\n  rfr: '',\n  rhard: '',\n  rharu: '',\n  rharul: '',\n  rho: '',\n  rhov: '',\n  rightarrow: '',\n  rightarrowtail: '',\n  rightharpoondown: '',\n  rightharpoonup: '',\n  rightleftarrows: '',\n  rightleftharpoons: '',\n  rightrightarrows: '',\n  rightsquigarrow: '',\n  rightthreetimes: '',\n  ring: '',\n  risingdotseq: '',\n  rlarr: '',\n  rlhar: '',\n  rlm: '',\n  rmoust: '',\n  rmoustache: '',\n  rnmid: '',\n  roang: '',\n  roarr: '',\n  robrk: '',\n  ropar: '',\n  ropf: '',\n  roplus: '',\n  rotimes: '',\n  rpar: ')',\n  rpargt: '',\n  rppolint: '',\n  rrarr: '',\n  rsaquo: '',\n  rscr: '',\n  rsh: '',\n  rsqb: ']',\n  rsquo: '',\n  rsquor: '',\n  rthree: '',\n  rtimes: '',\n  rtri: '',\n  rtrie: '',\n  rtrif: '',\n  rtriltri: '',\n  ruluhar: '',\n  rx: '',\n  sacute: '',\n  sbquo: '',\n  sc: '',\n  scE: '',\n  scap: '',\n  scaron: '',\n  sccue: '',\n  sce: '',\n  scedil: '',\n  scirc: '',\n  scnE: '',\n  scnap: '',\n  scnsim: '',\n  scpolint: '',\n  scsim: '',\n  scy: '',\n  sdot: '',\n  sdotb: '',\n  sdote: '',\n  seArr: '',\n  searhk: '',\n  searr: '',\n  searrow: '',\n  sect: '',\n  semi: ';',\n  seswar: '',\n  setminus: '',\n  setmn: '',\n  sext: '',\n  sfr: '',\n  sfrown: '',\n  sharp: '',\n  shchcy: '',\n  shcy: '',\n  shortmid: '',\n  shortparallel: '',\n  shy: '',\n  sigma: '',\n  sigmaf: '',\n  sigmav: '',\n  sim: '',\n  simdot: '',\n  sime: '',\n  simeq: '',\n  simg: '',\n  simgE: '',\n  siml: '',\n  simlE: '',\n  simne: '',\n  simplus: '',\n  simrarr: '',\n  slarr: '',\n  smallsetminus: '',\n  smashp: '',\n  smeparsl: '',\n  smid: '',\n  smile: '',\n  smt: '',\n  smte: '',\n  smtes: '',\n  softcy: '',\n  sol: '/',\n  solb: '',\n  solbar: '',\n  sopf: '',\n  spades: '',\n  spadesuit: '',\n  spar: '',\n  sqcap: '',\n  sqcaps: '',\n  sqcup: '',\n  sqcups: '',\n  sqsub: '',\n  sqsube: '',\n  sqsubset: '',\n  sqsubseteq: '',\n  sqsup: '',\n  sqsupe: '',\n  sqsupset: '',\n  sqsupseteq: '',\n  squ: '',\n  square: '',\n  squarf: '',\n  squf: '',\n  srarr: '',\n  sscr: '',\n  ssetmn: '',\n  ssmile: '',\n  sstarf: '',\n  star: '',\n  starf: '',\n  straightepsilon: '',\n  straightphi: '',\n  strns: '',\n  sub: '',\n  subE: '',\n  subdot: '',\n  sube: '',\n  subedot: '',\n  submult: '',\n  subnE: '',\n  subne: '',\n  subplus: '',\n  subrarr: '',\n  subset: '',\n  subseteq: '',\n  subseteqq: '',\n  subsetneq: '',\n  subsetneqq: '',\n  subsim: '',\n  subsub: '',\n  subsup: '',\n  succ: '',\n  succapprox: '',\n  succcurlyeq: '',\n  succeq: '',\n  succnapprox: '',\n  succneqq: '',\n  succnsim: '',\n  succsim: '',\n  sum: '',\n  sung: '',\n  sup1: '',\n  sup2: '',\n  sup3: '',\n  sup: '',\n  supE: '',\n  supdot: '',\n  supdsub: '',\n  supe: '',\n  supedot: '',\n  suphsol: '',\n  suphsub: '',\n  suplarr: '',\n  supmult: '',\n  supnE: '',\n  supne: '',\n  supplus: '',\n  supset: '',\n  supseteq: '',\n  supseteqq: '',\n  supsetneq: '',\n  supsetneqq: '',\n  supsim: '',\n  supsub: '',\n  supsup: '',\n  swArr: '',\n  swarhk: '',\n  swarr: '',\n  swarrow: '',\n  swnwar: '',\n  szlig: '',\n  target: '',\n  tau: '',\n  tbrk: '',\n  tcaron: '',\n  tcedil: '',\n  tcy: '',\n  tdot: '',\n  telrec: '',\n  tfr: '',\n  there4: '',\n  therefore: '',\n  theta: '',\n  thetasym: '',\n  thetav: '',\n  thickapprox: '',\n  thicksim: '',\n  thinsp: '',\n  thkap: '',\n  thksim: '',\n  thorn: '',\n  tilde: '',\n  times: '',\n  timesb: '',\n  timesbar: '',\n  timesd: '',\n  tint: '',\n  toea: '',\n  top: '',\n  topbot: '',\n  topcir: '',\n  topf: '',\n  topfork: '',\n  tosa: '',\n  tprime: '',\n  trade: '',\n  triangle: '',\n  triangledown: '',\n  triangleleft: '',\n  trianglelefteq: '',\n  triangleq: '',\n  triangleright: '',\n  trianglerighteq: '',\n  tridot: '',\n  trie: '',\n  triminus: '',\n  triplus: '',\n  trisb: '',\n  tritime: '',\n  trpezium: '',\n  tscr: '',\n  tscy: '',\n  tshcy: '',\n  tstrok: '',\n  twixt: '',\n  twoheadleftarrow: '',\n  twoheadrightarrow: '',\n  uArr: '',\n  uHar: '',\n  uacute: '',\n  uarr: '',\n  ubrcy: '',\n  ubreve: '',\n  ucirc: '',\n  ucy: '',\n  udarr: '',\n  udblac: '',\n  udhar: '',\n  ufisht: '',\n  ufr: '',\n  ugrave: '',\n  uharl: '',\n  uharr: '',\n  uhblk: '',\n  ulcorn: '',\n  ulcorner: '',\n  ulcrop: '',\n  ultri: '',\n  umacr: '',\n  uml: '',\n  uogon: '',\n  uopf: '',\n  uparrow: '',\n  updownarrow: '',\n  upharpoonleft: '',\n  upharpoonright: '',\n  uplus: '',\n  upsi: '',\n  upsih: '',\n  upsilon: '',\n  upuparrows: '',\n  urcorn: '',\n  urcorner: '',\n  urcrop: '',\n  uring: '',\n  urtri: '',\n  uscr: '',\n  utdot: '',\n  utilde: '',\n  utri: '',\n  utrif: '',\n  uuarr: '',\n  uuml: '',\n  uwangle: '',\n  vArr: '',\n  vBar: '',\n  vBarv: '',\n  vDash: '',\n  vangrt: '',\n  varepsilon: '',\n  varkappa: '',\n  varnothing: '',\n  varphi: '',\n  varpi: '',\n  varpropto: '',\n  varr: '',\n  varrho: '',\n  varsigma: '',\n  varsubsetneq: '',\n  varsubsetneqq: '',\n  varsupsetneq: '',\n  varsupsetneqq: '',\n  vartheta: '',\n  vartriangleleft: '',\n  vartriangleright: '',\n  vcy: '',\n  vdash: '',\n  vee: '',\n  veebar: '',\n  veeeq: '',\n  vellip: '',\n  verbar: '|',\n  vert: '|',\n  vfr: '',\n  vltri: '',\n  vnsub: '',\n  vnsup: '',\n  vopf: '',\n  vprop: '',\n  vrtri: '',\n  vscr: '',\n  vsubnE: '',\n  vsubne: '',\n  vsupnE: '',\n  vsupne: '',\n  vzigzag: '',\n  wcirc: '',\n  wedbar: '',\n  wedge: '',\n  wedgeq: '',\n  weierp: '',\n  wfr: '',\n  wopf: '',\n  wp: '',\n  wr: '',\n  wreath: '',\n  wscr: '',\n  xcap: '',\n  xcirc: '',\n  xcup: '',\n  xdtri: '',\n  xfr: '',\n  xhArr: '',\n  xharr: '',\n  xi: '',\n  xlArr: '',\n  xlarr: '',\n  xmap: '',\n  xnis: '',\n  xodot: '',\n  xopf: '',\n  xoplus: '',\n  xotime: '',\n  xrArr: '',\n  xrarr: '',\n  xscr: '',\n  xsqcup: '',\n  xuplus: '',\n  xutri: '',\n  xvee: '',\n  xwedge: '',\n  yacute: '',\n  yacy: '',\n  ycirc: '',\n  ycy: '',\n  yen: '',\n  yfr: '',\n  yicy: '',\n  yopf: '',\n  yscr: '',\n  yucy: '',\n  yuml: '',\n  zacute: '',\n  zcaron: '',\n  zcy: '',\n  zdot: '',\n  zeetrf: '',\n  zeta: '',\n  zfr: '',\n  zhcy: '',\n  zigrarr: '',\n  zopf: '',\n  zscr: '',\n  zwj: '',\n  zwnj: ''\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this\n  /** @type {Construct} */\n\n  const closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  }\n  /** @type {Construct} */\n\n  const nonLazyLine = {\n    tokenize: tokenizeNonLazyLine,\n    partial: true\n  }\n  const tail = this.events[this.events.length - 1]\n  const initialPrefix =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeFenced')\n    effects.enter('codeFencedFence')\n    effects.enter('codeFencedFenceSequence')\n    marker = code\n    return sequenceOpen(code)\n  }\n  /** @type {State} */\n\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit('codeFencedFenceSequence')\n    return sizeOpen < 3\n      ? nok(code)\n      : factorySpace(effects, infoOpen, 'whitespace')(code)\n  }\n  /** @type {State} */\n\n  function infoOpen(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceInfo')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return info(code)\n  }\n  /** @type {State} */\n\n  function info(code) {\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceInfo')\n      return factorySpace(effects, infoAfter, 'whitespace')(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return info\n  }\n  /** @type {State} */\n\n  function infoAfter(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n  /** @type {State} */\n\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceMeta')\n      return openAfter(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return meta\n  }\n  /** @type {State} */\n\n  function openAfter(code) {\n    effects.exit('codeFencedFence')\n    return self.interrupt ? ok(code) : contentStart(code)\n  }\n  /** @type {State} */\n\n  function contentStart(code) {\n    if (code === null) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyLine,\n        effects.attempt(\n          closingFenceConstruct,\n          after,\n          initialPrefix\n            ? factorySpace(\n                effects,\n                contentStart,\n                'linePrefix',\n                initialPrefix + 1\n              )\n            : contentStart\n        ),\n        after\n      )(code)\n    }\n\n    effects.enter('codeFlowValue')\n    return contentContinue(code)\n  }\n  /** @type {State} */\n\n  function contentContinue(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return contentStart(code)\n    }\n\n    effects.consume(code)\n    return contentContinue\n  }\n  /** @type {State} */\n\n  function after(code) {\n    effects.exit('codeFenced')\n    return ok(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeNonLazyLine(effects, ok, nok) {\n    const self = this\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return lineStart\n    }\n    /** @type {State} */\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n    }\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n    return factorySpace(\n      effects,\n      closingSequenceStart,\n      'linePrefix',\n      this.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n    /** @type {State} */\n\n    function closingSequenceStart(code) {\n      effects.enter('codeFencedFence')\n      effects.enter('codeFencedFenceSequence')\n      return closingSequence(code)\n    }\n    /** @type {State} */\n\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      if (size < sizeOpen) return nok(code)\n      effects.exit('codeFencedFenceSequence')\n      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code)\n    }\n    /** @type {State} */\n\n    function closingSequenceEnd(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('codeFencedFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const codeIndented = {\n  name: 'codeIndented',\n  tokenize: tokenizeCodeIndented\n}\n/** @type {Construct} */\n\nconst indentedContent = {\n  tokenize: tokenizeIndentedContent,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeIndented(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeIndented')\n    return factorySpace(effects, afterStartPrefix, 'linePrefix', 4 + 1)(code)\n  }\n  /** @type {State} */\n\n  function afterStartPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n      ? afterPrefix(code)\n      : nok(code)\n  }\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    if (code === null) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(indentedContent, afterPrefix, after)(code)\n    }\n\n    effects.enter('codeFlowValue')\n    return content(code)\n  }\n  /** @type {State} */\n\n  function content(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return afterPrefix(code)\n    }\n\n    effects.consume(code)\n    return content\n  }\n  /** @type {State} */\n\n  function after(code) {\n    effects.exit('codeIndented')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeIndentedContent(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // If this is a lazy line, it cant be code.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return start\n    }\n\n    return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)(code)\n  }\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n      ? ok(code)\n      : markdownLineEnding(code)\n      ? start(code)\n      : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous\n}\n/** @type {Resolver} */\n\nfunction resolveCodeText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n\n  let index\n  /** @type {number|undefined} */\n\n  let enter // If we start and end with an EOL or a space.\n\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'codeTextData') {\n        // Then we have padding.\n        events[headEnterIndex][1].type = 'codeTextPadding'\n        events[tailExitIndex][1].type = 'codeTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n  index = headEnterIndex - 1\n  tailExitIndex++\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'codeTextData'\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n\n      enter = undefined\n    }\n  }\n\n  return events\n}\n/** @type {Previous} */\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 96 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeText(effects, ok, nok) {\n  const self = this\n  let sizeOpen = 0\n  /** @type {number} */\n\n  let size\n  /** @type {Token} */\n\n  let token\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeText')\n    effects.enter('codeTextSequence')\n    return openingSequence(code)\n  }\n  /** @type {State} */\n\n  function openingSequence(code) {\n    if (code === 96) {\n      effects.consume(code)\n      sizeOpen++\n      return openingSequence\n    }\n\n    effects.exit('codeTextSequence')\n    return gap(code)\n  }\n  /** @type {State} */\n\n  function gap(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code)\n    } // Closing fence?\n    // Could also be data.\n\n    if (code === 96) {\n      token = effects.enter('codeTextSequence')\n      size = 0\n      return closingSequence(code)\n    } // Tabs dont work, and virtual spaces dont make sense.\n\n    if (code === 32) {\n      effects.enter('space')\n      effects.consume(code)\n      effects.exit('space')\n      return gap\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return gap\n    } // Data.\n\n    effects.enter('codeTextData')\n    return data(code)\n  } // In code.\n\n  /** @type {State} */\n\n  function data(code) {\n    if (\n      code === null ||\n      code === 32 ||\n      code === 96 ||\n      markdownLineEnding(code)\n    ) {\n      effects.exit('codeTextData')\n      return gap(code)\n    }\n\n    effects.consume(code)\n    return data\n  } // Closing fence.\n\n  /** @type {State} */\n\n  function closingSequence(code) {\n    // More.\n    if (code === 96) {\n      effects.consume(code)\n      size++\n      return closingSequence\n    } // Done!\n\n    if (size === sizeOpen) {\n      effects.exit('codeTextSequence')\n      effects.exit('codeText')\n      return ok(code)\n    } // More or less accents: mark as data.\n\n    token.type = 'codeTextData'\n    return data(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factorySpace} from 'micromark-factory-space'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n}\n/** @type {Construct} */\n\nconst titleConstruct = {\n  tokenize: tokenizeTitle,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinition(effects, ok, nok) {\n  const self = this\n  /** @type {string} */\n\n  let identifier\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('definition')\n    return factoryLabel.call(\n      self,\n      effects,\n      labelAfter,\n      nok,\n      'definitionLabel',\n      'definitionLabelMarker',\n      'definitionLabelString'\n    )(code)\n  }\n  /** @type {State} */\n\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(\n      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n    )\n\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker') // Note: blank lines cant exist in content.\n\n      return factoryWhitespace(\n        effects,\n        factoryDestination(\n          effects,\n          effects.attempt(\n            titleConstruct,\n            factorySpace(effects, after, 'whitespace'),\n            factorySpace(effects, after, 'whitespace')\n          ),\n          nok,\n          'definitionDestination',\n          'definitionDestinationLiteral',\n          'definitionDestinationLiteralMarker',\n          'definitionDestinationRaw',\n          'definitionDestinationString'\n        )\n      )\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('definition')\n\n      if (!self.parser.defined.includes(identifier)) {\n        self.parser.defined.push(identifier)\n      }\n\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTitle(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, before)(code)\n      : nok(code)\n  }\n  /** @type {State} */\n\n  function before(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        factorySpace(effects, after, 'whitespace'),\n        nok,\n        'definitionTitle',\n        'definitionTitleMarker',\n        'definitionTitleString'\n      )(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */\nimport {\n  asciiControl,\n  markdownLineEndingOrSpace,\n  markdownLineEnding\n} from 'micromark-util-character'\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} literalType\n * @param {string} literalMarkerType\n * @param {string} rawType\n * @param {string} stringType\n * @param {number} [max=Infinity]\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nexport function factoryDestination(\n  effects,\n  ok,\n  nok,\n  type,\n  literalType,\n  literalMarkerType,\n  rawType,\n  stringType,\n  max\n) {\n  const limit = max || Number.POSITIVE_INFINITY\n  let balance = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (code === 60) {\n      effects.enter(type)\n      effects.enter(literalType)\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      return destinationEnclosedBefore\n    }\n\n    if (code === null || code === 41 || asciiControl(code)) {\n      return nok(code)\n    }\n\n    effects.enter(type)\n    effects.enter(rawType)\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return destinationRaw(code)\n  }\n  /** @type {State} */\n\n  function destinationEnclosedBefore(code) {\n    if (code === 62) {\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      effects.exit(literalType)\n      effects.exit(type)\n      return ok\n    }\n\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return destinationEnclosed(code)\n  }\n  /** @type {State} */\n\n  function destinationEnclosed(code) {\n    if (code === 62) {\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      return destinationEnclosedBefore(code)\n    }\n\n    if (code === null || code === 60 || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? destinationEnclosedEscape : destinationEnclosed\n  }\n  /** @type {State} */\n\n  function destinationEnclosedEscape(code) {\n    if (code === 60 || code === 62 || code === 92) {\n      effects.consume(code)\n      return destinationEnclosed\n    }\n\n    return destinationEnclosed(code)\n  }\n  /** @type {State} */\n\n  function destinationRaw(code) {\n    if (code === 40) {\n      if (++balance > limit) return nok(code)\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    if (code === 41) {\n      if (!balance--) {\n        effects.exit('chunkString')\n        effects.exit(stringType)\n        effects.exit(rawType)\n        effects.exit(type)\n        return ok(code)\n      }\n\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      if (balance) return nok(code)\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      effects.exit(rawType)\n      effects.exit(type)\n      return ok(code)\n    }\n\n    if (asciiControl(code)) return nok(code)\n    effects.consume(code)\n    return code === 92 ? destinationRawEscape : destinationRaw\n  }\n  /** @type {State} */\n\n  function destinationRawEscape(code) {\n    if (code === 40 || code === 41 || code === 92) {\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    return destinationRaw(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').State} State\n */\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n\n/**\n * @this {TokenizeContext}\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} markerType\n * @param {string} stringType\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nexport function factoryLabel(effects, ok, nok, type, markerType, stringType) {\n  const self = this\n  let size = 0\n  /** @type {boolean} */\n\n  let data\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    effects.enter(stringType)\n    return atBreak\n  }\n  /** @type {State} */\n\n  function atBreak(code) {\n    if (\n      code === null ||\n      code === 91 ||\n      (code === 93 && !data) ||\n      /* To do: remove in the future once weve switched from\n       * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n       * which doesnt need this */\n\n      /* Hidden footnotes hook */\n\n      /* c8 ignore next 3 */\n      (code === 94 &&\n        !size &&\n        '_hiddenFootnoteSupport' in self.parser.constructs) ||\n      size > 999\n    ) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      effects.exit(stringType)\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return atBreak\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return label(code)\n  }\n  /** @type {State} */\n\n  function label(code) {\n    if (\n      code === null ||\n      code === 91 ||\n      code === 93 ||\n      markdownLineEnding(code) ||\n      size++ > 999\n    ) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n\n    effects.consume(code)\n    data = data || !markdownSpace(code)\n    return code === 92 ? labelEscape : label\n  }\n  /** @type {State} */\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return label\n    }\n\n    return label(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} markerType\n * @param {string} stringType\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nexport function factoryTitle(effects, ok, nok, type, markerType, stringType) {\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    marker = code === 40 ? 41 : code\n    return atFirstTitleBreak\n  }\n  /** @type {State} */\n\n  function atFirstTitleBreak(code) {\n    if (code === marker) {\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    effects.enter(stringType)\n    return atTitleBreak(code)\n  }\n  /** @type {State} */\n\n  function atTitleBreak(code) {\n    if (code === marker) {\n      effects.exit(stringType)\n      return atFirstTitleBreak(marker)\n    }\n\n    if (code === null) {\n      return nok(code)\n    } // Note: blank lines cant exist in content.\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, atTitleBreak, 'linePrefix')\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return title(code)\n  }\n  /** @type {State} */\n\n  function title(code) {\n    if (code === marker || code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      return atTitleBreak(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? titleEscape : title\n  }\n  /** @type {State} */\n\n  function titleEscape(code) {\n    if (code === marker || code === 92) {\n      effects.consume(code)\n      return title\n    }\n\n    return title(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n */\nexport function factoryWhitespace(effects, ok) {\n  /** @type {boolean} */\n  let seen\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      seen = true\n      return start\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(\n        effects,\n        start,\n        seen ? 'linePrefix' : 'lineSuffix'\n      )(code)\n    }\n\n    return ok(code)\n  }\n}\n","/**\n * Normalize an identifier (such as used in definitions).\n *\n * @param {string} value\n * @returns {string}\n */\nexport function normalizeIdentifier(value) {\n  return (\n    value // Collapse Markdown whitespace.\n      .replace(/[\\t\\n\\r ]+/g, ' ') // Trim.\n      .replace(/^ | $/g, '') // Some characters are considered uppercase, but if their lowercase\n      // counterpart is uppercased will result in a different uppercase\n      // character.\n      // Hence, to get that form, we perform both lower- and uppercase.\n      // Upper case makes sure keys will not interact with default prototypal\n      // methods: no method is uppercase.\n      .toLowerCase()\n      .toUpperCase()\n  )\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const hardBreakEscape = {\n  name: 'hardBreakEscape',\n  tokenize: tokenizeHardBreakEscape\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHardBreakEscape(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('hardBreakEscape')\n    effects.enter('escapeMarker')\n    effects.consume(code)\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (markdownLineEnding(code)) {\n      effects.exit('escapeMarker')\n      effects.exit('hardBreakEscape')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\n\n/** @type {Construct} */\nexport const headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n}\n/** @type {Resolver} */\n\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2\n  let contentStart = 3\n  /** @type {Token} */\n\n  let content\n  /** @type {Token} */\n\n  let text // Prefix whitespace, part of the opening.\n\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2\n  } // Suffix whitespace, part of the closing.\n\n  if (\n    contentEnd - 2 > contentStart &&\n    events[contentEnd][1].type === 'whitespace'\n  ) {\n    contentEnd -= 2\n  }\n\n  if (\n    events[contentEnd][1].type === 'atxHeadingSequence' &&\n    (contentStart === contentEnd - 1 ||\n      (contentEnd - 4 > contentStart &&\n        events[contentEnd - 2][1].type === 'whitespace'))\n  ) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    }\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      // @ts-expect-error Constants are fine to assign.\n      contentType: 'text'\n    }\n    splice(events, contentStart, contentEnd - contentStart + 1, [\n      ['enter', content, context],\n      ['enter', text, context],\n      ['exit', text, context],\n      ['exit', content, context]\n    ])\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  const self = this\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('atxHeading')\n    effects.enter('atxHeadingSequence')\n    return fenceOpenInside(code)\n  }\n  /** @type {State} */\n\n  function fenceOpenInside(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code)\n      return fenceOpenInside\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingSequence')\n      return self.interrupt ? ok(code) : headingBreak(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function headingBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence')\n      return sequence(code)\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('atxHeading')\n      return ok(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headingBreak, 'whitespace')(code)\n    }\n\n    effects.enter('atxHeadingText')\n    return data(code)\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === 35) {\n      effects.consume(code)\n      return sequence\n    }\n\n    effects.exit('atxHeadingSequence')\n    return headingBreak(code)\n  }\n  /** @type {State} */\n\n  function data(code) {\n    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingText')\n      return headingBreak(code)\n    }\n\n    effects.consume(code)\n    return data\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {htmlBlockNames, htmlRawNames} from 'micromark-util-html-tag-name'\nimport {blankLine} from './blank-line.js'\n/** @type {Construct} */\n\nexport const htmlFlow = {\n  name: 'htmlFlow',\n  tokenize: tokenizeHtmlFlow,\n  resolveTo: resolveToHtmlFlow,\n  concrete: true\n}\n/** @type {Construct} */\n\nconst nextBlankConstruct = {\n  tokenize: tokenizeNextBlank,\n  partial: true\n}\n/** @type {Resolver} */\n\nfunction resolveToHtmlFlow(events) {\n  let index = events.length\n\n  while (index--) {\n    if (events[index][0] === 'enter' && events[index][1].type === 'htmlFlow') {\n      break\n    }\n  }\n\n  if (index > 1 && events[index - 2][1].type === 'linePrefix') {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start // Add the prefix start to the HTML line token.\n\n    events[index + 1][1].start = events[index - 2][1].start // Remove the line prefix.\n\n    events.splice(index - 2, 2)\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  const self = this\n  /** @type {number} */\n\n  let kind\n  /** @type {boolean} */\n\n  let startTag\n  /** @type {string} */\n\n  let buffer\n  /** @type {number} */\n\n  let index\n  /** @type {Code} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('htmlFlow')\n    effects.enter('htmlFlowData')\n    effects.consume(code)\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationStart\n    }\n\n    if (code === 47) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === 63) {\n      effects.consume(code)\n      kind = 3 // While were in an instruction instead of a declaration, were on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      buffer = String.fromCharCode(code)\n      startTag = true\n      return tagName\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function declarationStart(code) {\n    if (code === 45) {\n      effects.consume(code)\n      kind = 2\n      return commentOpenInside\n    }\n\n    if (code === 91) {\n      effects.consume(code)\n      kind = 5\n      buffer = 'CDATA['\n      index = 0\n      return cdataOpenInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      kind = 4\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function commentOpenInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function cdataOpenInside(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === buffer.length\n        ? self.interrupt\n          ? ok\n          : continuation\n        : cdataOpenInside\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function tagName(code) {\n    if (\n      code === null ||\n      code === 47 ||\n      code === 62 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      if (\n        code !== 47 &&\n        startTag &&\n        htmlRawNames.includes(buffer.toLowerCase())\n      ) {\n        kind = 1\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        kind = 6\n\n        if (code === 47) {\n          effects.consume(code)\n          return basicSelfClosing\n        }\n\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      kind = 7 // Do not support complete HTML when interrupting\n\n      return self.interrupt && !self.parser.lazy[self.now().line]\n        ? nok(code)\n        : startTag\n        ? completeAttributeNameBefore(code)\n        : completeClosingTagAfter(code)\n    }\n\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function basicSelfClosing(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return self.interrupt ? ok : continuation\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeClosingTagAfter\n    }\n\n    return completeEnd(code)\n  }\n  /** @type {State} */\n\n  function completeAttributeNameBefore(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return completeEnd\n    }\n\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameBefore\n    }\n\n    return completeEnd(code)\n  }\n  /** @type {State} */\n\n  function completeAttributeName(code) {\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    return completeAttributeNameAfter(code)\n  }\n  /** @type {State} */\n\n  function completeAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameAfter\n    }\n\n    return completeAttributeNameBefore(code)\n  }\n  /** @type {State} */\n\n  function completeAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      marker = code\n      return completeAttributeValueQuoted\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    marker = null\n    return completeAttributeValueUnquoted(code)\n  }\n  /** @type {State} */\n\n  function completeAttributeValueQuoted(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    if (code === marker) {\n      effects.consume(code)\n      return completeAttributeValueQuotedAfter\n    }\n\n    effects.consume(code)\n    return completeAttributeValueQuoted\n  }\n  /** @type {State} */\n\n  function completeAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return completeAttributeNameAfter(code)\n    }\n\n    effects.consume(code)\n    return completeAttributeValueUnquoted\n  }\n  /** @type {State} */\n\n  function completeAttributeValueQuotedAfter(code) {\n    if (code === 47 || code === 62 || markdownSpace(code)) {\n      return completeAttributeNameBefore(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function completeEnd(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function completeAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return code === null || markdownLineEnding(code)\n      ? continuation(code)\n      : nok(code)\n  }\n  /** @type {State} */\n\n  function continuation(code) {\n    if (code === 45 && kind === 2) {\n      effects.consume(code)\n      return continuationCommentInside\n    }\n\n    if (code === 60 && kind === 1) {\n      effects.consume(code)\n      return continuationRawTagOpen\n    }\n\n    if (code === 62 && kind === 4) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (code === 63 && kind === 3) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    if (code === 93 && kind === 5) {\n      effects.consume(code)\n      return continuationCharacterDataInside\n    }\n\n    if (markdownLineEnding(code) && (kind === 6 || kind === 7)) {\n      return effects.check(\n        nextBlankConstruct,\n        continuationClose,\n        continuationAtLineEnding\n      )(code)\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      return continuationAtLineEnding(code)\n    }\n\n    effects.consume(code)\n    return continuation\n  }\n  /** @type {State} */\n\n  function continuationAtLineEnding(code) {\n    effects.exit('htmlFlowData')\n    return htmlContinueStart(code)\n  }\n  /** @type {State} */\n\n  function htmlContinueStart(code) {\n    if (code === null) {\n      return done(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        {\n          tokenize: htmlLineEnd,\n          partial: true\n        },\n        htmlContinueStart,\n        done\n      )(code)\n    }\n\n    effects.enter('htmlFlowData')\n    return continuation(code)\n  }\n  /** @type {Tokenizer} */\n\n  function htmlLineEnd(effects, ok, nok) {\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return lineStart\n    }\n    /** @type {State} */\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n    }\n  }\n  /** @type {State} */\n\n  function continuationCommentInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n  /** @type {State} */\n\n  function continuationRawTagOpen(code) {\n    if (code === 47) {\n      effects.consume(code)\n      buffer = ''\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n  /** @type {State} */\n\n  function continuationRawEndTag(code) {\n    if (code === 62 && htmlRawNames.includes(buffer.toLowerCase())) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (asciiAlpha(code) && buffer.length < 8) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n  /** @type {State} */\n\n  function continuationCharacterDataInside(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n  /** @type {State} */\n\n  function continuationDeclarationInside(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return continuationClose\n    } // More dashes.\n\n    if (code === 45 && kind === 2) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n  /** @type {State} */\n\n  function continuationClose(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('htmlFlowData')\n      return done(code)\n    }\n\n    effects.consume(code)\n    return continuationClose\n  }\n  /** @type {State} */\n\n  function done(code) {\n    effects.exit('htmlFlow')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNextBlank(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.exit('htmlFlowData')\n    effects.enter('lineEndingBlank')\n    effects.consume(code)\n    effects.exit('lineEndingBlank')\n    return effects.attempt(blankLine, ok, nok)\n  }\n}\n","/**\n * List of lowercase HTML tag names which when parsing HTML (flow), result\n * in more relaxed rules (condition 6): because they are known blocks, the\n * HTML-like syntax doesnt have to be strictly parsed.\n * For tag names not in this list, a more strict algorithm (condition 7) is used\n * to detect whether the HTML-like syntax is seen as HTML (flow) or not.\n *\n * This is copied from:\n * <https://spec.commonmark.org/0.30/#html-blocks>.\n */\nexport const htmlBlockNames = [\n  'address',\n  'article',\n  'aside',\n  'base',\n  'basefont',\n  'blockquote',\n  'body',\n  'caption',\n  'center',\n  'col',\n  'colgroup',\n  'dd',\n  'details',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hr',\n  'html',\n  'iframe',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'menu',\n  'menuitem',\n  'nav',\n  'noframes',\n  'ol',\n  'optgroup',\n  'option',\n  'p',\n  'param',\n  'section',\n  'summary',\n  'table',\n  'tbody',\n  'td',\n  'tfoot',\n  'th',\n  'thead',\n  'title',\n  'tr',\n  'track',\n  'ul'\n]\n\n/**\n * List of lowercase HTML tag names which when parsing HTML (flow), result in\n * HTML that can include lines w/o exiting, until a closing tag also in this\n * list is found (condition 1).\n *\n * This module is copied from:\n * <https://spec.commonmark.org/0.30/#html-blocks>.\n *\n * Note that `textarea` was added in `CommonMark@0.30`.\n */\nexport const htmlRawNames = ['pre', 'script', 'style', 'textarea']\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const htmlText = {\n  name: 'htmlText',\n  tokenize: tokenizeHtmlText\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHtmlText(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code>|undefined} */\n\n  let marker\n  /** @type {string} */\n\n  let buffer\n  /** @type {number} */\n\n  let index\n  /** @type {State} */\n\n  let returnState\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('htmlText')\n    effects.enter('htmlTextData')\n    effects.consume(code)\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationOpen\n    }\n\n    if (code === 47) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === 63) {\n      effects.consume(code)\n      return instruction\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function declarationOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentOpen\n    }\n\n    if (code === 91) {\n      effects.consume(code)\n      buffer = 'CDATA['\n      index = 0\n      return cdataOpen\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return declaration\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function commentOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentStart\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function commentStart(code) {\n    if (code === null || code === 62) {\n      return nok(code)\n    }\n\n    if (code === 45) {\n      effects.consume(code)\n      return commentStartDash\n    }\n\n    return comment(code)\n  }\n  /** @type {State} */\n\n  function commentStartDash(code) {\n    if (code === null || code === 62) {\n      return nok(code)\n    }\n\n    return comment(code)\n  }\n  /** @type {State} */\n\n  function comment(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (code === 45) {\n      effects.consume(code)\n      return commentClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = comment\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return comment\n  }\n  /** @type {State} */\n\n  function commentClose(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return end\n    }\n\n    return comment(code)\n  }\n  /** @type {State} */\n\n  function cdataOpen(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === buffer.length ? cdata : cdataOpen\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function cdata(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      effects.consume(code)\n      return cdataClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = cdata\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return cdata\n  }\n  /** @type {State} */\n\n  function cdataClose(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n  /** @type {State} */\n\n  function cdataEnd(code) {\n    if (code === 62) {\n      return end(code)\n    }\n\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n  /** @type {State} */\n\n  function declaration(code) {\n    if (code === null || code === 62) {\n      return end(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = declaration\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return declaration\n  }\n  /** @type {State} */\n\n  function instruction(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (code === 63) {\n      effects.consume(code)\n      return instructionClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = instruction\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return instruction\n  }\n  /** @type {State} */\n\n  function instructionClose(code) {\n    return code === 62 ? end(code) : instruction(code)\n  }\n  /** @type {State} */\n\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function tagClose(code) {\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return tagCloseBetween(code)\n  }\n  /** @type {State} */\n\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagCloseBetween\n    }\n\n    return end(code)\n  }\n  /** @type {State} */\n\n  function tagOpen(code) {\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function tagOpenBetween(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return end\n    }\n\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenBetween\n    }\n\n    return end(code)\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeName(code) {\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    return tagOpenAttributeNameAfter(code)\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeNameAfter\n    }\n\n    return tagOpenBetween(code)\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      marker = code\n      return tagOpenAttributeValueQuoted\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    effects.consume(code)\n    marker = undefined\n    return tagOpenAttributeValueUnquoted\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return tagOpenAttributeValueQuotedAfter\n    }\n\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueQuoted\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (code === 62 || code === 47 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 60 ||\n      code === 61 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n\n    if (code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  } // We cant have blank lines in content, so no need to worry about empty\n  // tokens.\n\n  /** @type {State} */\n\n  function atLineEnding(code) {\n    effects.exit('htmlTextData')\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(\n      effects,\n      afterPrefix,\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n  }\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    effects.enter('htmlTextData')\n    return returnState(code)\n  }\n  /** @type {State} */\n\n  function end(code) {\n    if (code === 62) {\n      effects.consume(code)\n      effects.exit('htmlTextData')\n      effects.exit('htmlText')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n/** @type {Construct} */\n\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n}\n/** @type {Construct} */\n\nconst fullReferenceConstruct = {\n  tokenize: tokenizeFullReference\n}\n/** @type {Construct} */\n\nconst collapsedReferenceConstruct = {\n  tokenize: tokenizeCollapsedReference\n}\n/** @type {Resolver} */\n\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  /** @type {Token} */\n\n  let token\n\n  while (++index < events.length) {\n    token = events[index][1]\n\n    if (\n      token.type === 'labelImage' ||\n      token.type === 'labelLink' ||\n      token.type === 'labelEnd'\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)\n      token.type = 'data'\n      index++\n    }\n  }\n\n  return events\n}\n/** @type {Resolver} */\n\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n\n  let token\n  /** @type {number|undefined} */\n\n  let open\n  /** @type {number|undefined} */\n\n  let close\n  /** @type {Event[]} */\n\n  let media // Find an opening.\n\n  while (index--) {\n    token = events[index][1]\n\n    if (open) {\n      // If we see another link, or inactive link label, weve been here before.\n      if (\n        token.type === 'link' ||\n        (token.type === 'labelLink' && token._inactive)\n      ) {\n        break\n      } // Mark other link openings as inactive, as we cant have links in\n      // links.\n\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === 'labelImage' || token.type === 'labelLink') &&\n        !token._balanced\n      ) {\n        open = index\n\n        if (token.type !== 'labelLink') {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index\n    }\n  }\n\n  const group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  const label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n  const text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ] // Opening marker.\n\n  media = push(media, events.slice(open + 1, open + offset + 3)) // Text open.\n\n  media = push(media, [['enter', text, context]]) // Between.\n\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  ) // Text close, marker close, label close.\n\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ]) // Reference, resource, or so.\n\n  media = push(media, events.slice(close + 1)) // Media close.\n\n  media = push(media, [['exit', group, context]])\n  splice(events, open, events.length, media)\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n\n  let labelStart\n  /** @type {boolean} */\n\n  let defined // Find an opening.\n\n  while (index--) {\n    if (\n      (self.events[index][1].type === 'labelImage' ||\n        self.events[index][1].type === 'labelLink') &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart) {\n      return nok(code)\n    } // Its a balanced bracket, but contains a link.\n\n    if (labelStart._inactive) return balanced(code)\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({\n          start: labelStart.end,\n          end: self.now()\n        })\n      )\n    )\n    effects.enter('labelEnd')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelEnd')\n    return afterLabelEnd\n  }\n  /** @type {State} */\n\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === 40) {\n      return effects.attempt(\n        resourceConstruct,\n        ok,\n        defined ? ok : balanced\n      )(code)\n    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n\n    if (code === 91) {\n      return effects.attempt(\n        fullReferenceConstruct,\n        ok,\n        defined\n          ? effects.attempt(collapsedReferenceConstruct, ok, balanced)\n          : balanced\n      )(code)\n    } // Shortcut reference: `[asd]`?\n\n    return defined ? ok(code) : balanced(code)\n  }\n  /** @type {State} */\n\n  function balanced(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeResource(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('resource')\n    effects.enter('resourceMarker')\n    effects.consume(code)\n    effects.exit('resourceMarker')\n    return factoryWhitespace(effects, open)\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 41) {\n      return end(code)\n    }\n\n    return factoryDestination(\n      effects,\n      destinationAfter,\n      nok,\n      'resourceDestination',\n      'resourceDestinationLiteral',\n      'resourceDestinationLiteralMarker',\n      'resourceDestinationRaw',\n      'resourceDestinationString',\n      32\n    )(code)\n  }\n  /** @type {State} */\n\n  function destinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, between)(code)\n      : end(code)\n  }\n  /** @type {State} */\n\n  function between(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        factoryWhitespace(effects, end),\n        nok,\n        'resourceTitle',\n        'resourceTitleMarker',\n        'resourceTitleString'\n      )(code)\n    }\n\n    return end(code)\n  }\n  /** @type {State} */\n\n  function end(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker')\n      effects.consume(code)\n      effects.exit('resourceMarker')\n      effects.exit('resource')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeFullReference(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    return factoryLabel.call(\n      self,\n      effects,\n      afterLabel,\n      nok,\n      'reference',\n      'referenceMarker',\n      'referenceString'\n    )(code)\n  }\n  /** @type {State} */\n\n  function afterLabel(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('reference')\n    effects.enter('referenceMarker')\n    effects.consume(code)\n    effects.exit('referenceMarker')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker')\n      effects.consume(code)\n      effects.exit('referenceMarker')\n      effects.exit('reference')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {labelEnd} from './label-end.js'\n/** @type {Construct} */\n\nexport const labelStartImage = {\n  name: 'labelStartImage',\n  tokenize: tokenizeLabelStartImage,\n  resolveAll: labelEnd.resolveAll\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeLabelStartImage(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('labelImage')\n    effects.enter('labelImageMarker')\n    effects.consume(code)\n    effects.exit('labelImageMarker')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 91) {\n      effects.enter('labelMarker')\n      effects.consume(code)\n      effects.exit('labelMarker')\n      effects.exit('labelImage')\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    /* To do: remove in the future once weve switched from\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n     * which doesnt need this */\n\n    /* Hidden footnotes hook */\n\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {labelEnd} from './label-end.js'\n/** @type {Construct} */\n\nexport const labelStartLink = {\n  name: 'labelStartLink',\n  tokenize: tokenizeLabelStartLink,\n  resolveAll: labelEnd.resolveAll\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeLabelStartLink(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('labelLink')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelLink')\n    return after\n  }\n  /** @type {State} */\n\n  function after(code) {\n    /* To do: remove in the future once weve switched from\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n     * which doesnt need this */\n\n    /* Hidden footnotes hook. */\n\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const lineEnding = {\n  name: 'lineEnding',\n  tokenize: tokenizeLineEnding\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeLineEnding(effects, ok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, ok, 'linePrefix')\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * @typedef {Record<string, unknown> & {marker: Code, type: string, size: number}} ListContainerState\n * @typedef {TokenizeContext & {containerState: ListContainerState}} TokenizeContextWithState\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {asciiDigit, markdownSpace} from 'micromark-util-character'\nimport {blankLine} from './blank-line.js'\nimport {thematicBreak} from './thematic-break.js'\n/** @type {Construct} */\n\nexport const list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n}\n/** @type {Construct} */\n\nconst listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n}\n/** @type {Construct} */\n\nconst indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  let initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    const kind =\n      self.containerState.type ||\n      (code === 42 || code === 43 || code === 45\n        ? 'listUnordered'\n        : 'listOrdered')\n\n    if (\n      kind === 'listUnordered'\n        ? !self.containerState.marker || code === self.containerState.marker\n        : asciiDigit(code)\n    ) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind\n        effects.enter(kind, {\n          _container: true\n        })\n      }\n\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix')\n        return code === 42 || code === 45\n          ? effects.check(thematicBreak, nok, atMarker)(code)\n          : atMarker(code)\n      }\n\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix')\n        effects.enter('listItemValue')\n        return inside(code)\n      }\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code)\n      return inside\n    }\n\n    if (\n      (!self.interrupt || size < 2) &&\n      (self.containerState.marker\n        ? code === self.containerState.marker\n        : code === 41 || code === 46)\n    ) {\n      effects.exit('listItemValue')\n      return atMarker(code)\n    }\n\n    return nok(code)\n  }\n  /**\n   * @type {State}\n   **/\n\n  function atMarker(code) {\n    effects.enter('listItemMarker')\n    effects.consume(code)\n    effects.exit('listItemMarker')\n    self.containerState.marker = self.containerState.marker || code\n    return effects.check(\n      blankLine, // Cant be empty when interrupting.\n      self.interrupt ? nok : onBlank,\n      effects.attempt(\n        listItemPrefixWhitespaceConstruct,\n        endOfPrefix,\n        otherPrefix\n      )\n    )\n  }\n  /** @type {State} */\n\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true\n    initialSize++\n    return endOfPrefix(code)\n  }\n  /** @type {State} */\n\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace')\n      effects.consume(code)\n      effects.exit('listItemPrefixWhitespace')\n      return endOfPrefix\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function endOfPrefix(code) {\n    self.containerState.size =\n      initialSize +\n      self.sliceSerialize(effects.exit('listItemPrefix'), true).length\n    return ok(code)\n  }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this\n  self.containerState._closeFlow = undefined\n  return effects.check(blankLine, onBlank, notBlank)\n  /** @type {State} */\n\n  function onBlank(code) {\n    self.containerState.furtherBlankLines =\n      self.containerState.furtherBlankLines ||\n      self.containerState.initialBlankLine // We have a blank line.\n    // Still, try to consume at most the items size.\n\n    return factorySpace(\n      effects,\n      ok,\n      'listItemIndent',\n      self.containerState.size + 1\n    )(code)\n  }\n  /** @type {State} */\n\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = undefined\n      self.containerState.initialBlankLine = undefined\n      return notInCurrentItem(code)\n    }\n\n    self.containerState.furtherBlankLines = undefined\n    self.containerState.initialBlankLine = undefined\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)\n  }\n  /** @type {State} */\n\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true // As were closing flow, were no longer interrupting.\n\n    self.interrupt = undefined\n    return factorySpace(\n      effects,\n      effects.attempt(list, ok, nok),\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )(code)\n  }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemIndent',\n    self.containerState.size + 1\n  )\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'listItemIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === self.containerState.size\n      ? ok(code)\n      : nok(code)\n  }\n}\n/**\n * @type {Exiter}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type)\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemPrefixWhitespace',\n    self.parser.constructs.disable.null.includes('codeIndented')\n      ? undefined\n      : 4 + 1\n  )\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return !markdownSpace(code) &&\n      tail &&\n      tail[1].type === 'listItemPrefixWhitespace'\n      ? ok(code)\n      : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const thematicBreak = {\n  name: 'thematicBreak',\n  tokenize: tokenizeThematicBreak\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeThematicBreak(effects, ok, nok) {\n  let size = 0\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('thematicBreak')\n    marker = code\n    return atBreak(code)\n  }\n  /** @type {State} */\n\n  function atBreak(code) {\n    if (code === marker) {\n      effects.enter('thematicBreakSequence')\n      return sequence(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, atBreak, 'whitespace')(code)\n    }\n\n    if (size < 3 || (code !== null && !markdownLineEnding(code))) {\n      return nok(code)\n    }\n\n    effects.exit('thematicBreak')\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      size++\n      return sequence\n    }\n\n    effects.exit('thematicBreakSequence')\n    return atBreak(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n}\n/** @type {Resolver} */\n\nfunction resolveToSetextUnderline(events, context) {\n  let index = events.length\n  /** @type {number|undefined} */\n\n  let content\n  /** @type {number|undefined} */\n\n  let text\n  /** @type {number|undefined} */\n\n  let definition // Find the opening of the content.\n  // Itll always exist: we dont tokenize if it isnt there.\n\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index\n        break\n      }\n\n      if (events[index][1].type === 'paragraph') {\n        text = index\n      }\n    } // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed well add it later)\n        events.splice(index, 1)\n      }\n\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index\n      }\n    }\n  }\n\n  const heading = {\n    type: 'setextHeading',\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  } // Change the paragraph to setext heading text.\n\n  events[text][1].type = 'setextHeadingText' // If we have definitions in the content, well keep on having content,\n  // but we need move it.\n\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = Object.assign({}, events[definition][1].end)\n  } else {\n    events[content][1] = heading\n  } // Add the heading exit at the end.\n\n  events.push(['exit', heading, context])\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  /** @type {boolean} */\n\n  let paragraph // Find an opening.\n\n  while (index--) {\n    // Skip enter/exit of line ending, line prefix, and content.\n    // We can now either have a definition or a paragraph.\n    if (\n      self.events[index][1].type !== 'lineEnding' &&\n      self.events[index][1].type !== 'linePrefix' &&\n      self.events[index][1].type !== 'content'\n    ) {\n      paragraph = self.events[index][1].type === 'paragraph'\n      break\n    }\n  }\n\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine')\n      effects.enter('setextHeadingLineSequence')\n      marker = code\n      return closingSequence(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function closingSequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return closingSequence\n    }\n\n    effects.exit('setextHeadingLineSequence')\n    return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code)\n  }\n  /** @type {State} */\n\n  function closingSequenceEnd(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('setextHeadingLine')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Value} Value\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * @callback Preprocessor\n * @param {Value} value\n * @param {Encoding} [encoding]\n * @param {boolean} [end=false]\n * @returns {Array<Chunk>}\n */\nconst search = /[\\0\\t\\n\\r]/g\n/**\n * @returns {Preprocessor}\n */\n\nexport function preprocess() {\n  let column = 1\n  let buffer = ''\n  /** @type {boolean|undefined} */\n\n  let start = true\n  /** @type {boolean|undefined} */\n\n  let atCarriageReturn\n  return preprocessor\n  /** @type {Preprocessor} */\n\n  function preprocessor(value, encoding, end) {\n    /** @type {Array<Chunk>} */\n    const chunks = []\n    /** @type {RegExpMatchArray|null} */\n\n    let match\n    /** @type {number} */\n\n    let next\n    /** @type {number} */\n\n    let startPosition\n    /** @type {number} */\n\n    let endPosition\n    /** @type {Code} */\n\n    let code // @ts-expect-error `Buffer` does allow an encoding.\n\n    value = buffer + value.toString(encoding)\n    startPosition = 0\n    buffer = ''\n\n    if (start) {\n      if (value.charCodeAt(0) === 65279) {\n        startPosition++\n      }\n\n      start = undefined\n    }\n\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition\n      match = search.exec(value)\n      endPosition =\n        match && match.index !== undefined ? match.index : value.length\n      code = value.charCodeAt(endPosition)\n\n      if (!match) {\n        buffer = value.slice(startPosition)\n        break\n      }\n\n      if (code === 10 && startPosition === endPosition && atCarriageReturn) {\n        chunks.push(-3)\n        atCarriageReturn = undefined\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(-5)\n          atCarriageReturn = undefined\n        }\n\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition))\n          column += endPosition - startPosition\n        }\n\n        switch (code) {\n          case 0: {\n            chunks.push(65533)\n            column++\n            break\n          }\n\n          case 9: {\n            next = Math.ceil(column / 4) * 4\n            chunks.push(-2)\n\n            while (column++ < next) chunks.push(-1)\n\n            break\n          }\n\n          case 10: {\n            chunks.push(-4)\n            column = 1\n            break\n          }\n\n          default: {\n            atCarriageReturn = true\n            column = 1\n          }\n        }\n      }\n\n      startPosition = endPosition + 1\n    }\n\n    if (end) {\n      if (atCarriageReturn) chunks.push(-5)\n      if (buffer) chunks.push(buffer)\n      chunks.push(null)\n    }\n\n    return chunks\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n */\nimport {subtokenize} from 'micromark-util-subtokenize'\n/**\n * @param {Array<Event>} events\n * @returns {Array<Event>}\n */\n\nexport function postprocess(events) {\n  while (!subtokenize(events)) {\n    // Empty\n  }\n\n  return events\n}\n","/**\n * Turn the number (in string form as either hexa- or plain decimal) coming from\n * a numeric character reference into a character.\n *\n * @param {string} value\n *   Value to decode.\n * @param {number} base\n *   Numeric base.\n * @returns {string}\n */\nexport function decodeNumericCharacterReference(value, base) {\n  const code = Number.parseInt(value, base)\n\n  if (\n    // C0 except for HT, LF, FF, CR, space\n    code < 9 ||\n    code === 11 ||\n    (code > 13 && code < 32) || // Control character (DEL) of the basic block and C1 controls.\n    (code > 126 && code < 160) || // Lone high surrogates and low surrogates.\n    (code > 55295 && code < 57344) || // Noncharacters.\n    (code > 64975 && code < 65008) ||\n    (code & 65535) === 65535 ||\n    (code & 65535) === 65534 || // Out of range\n    code > 1114111\n  ) {\n    return '\\uFFFD'\n  }\n\n  return String.fromCharCode(code)\n}\n","import {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nconst characterEscapeOrReference =\n  /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi\n/**\n * Utility to decode markdown strings (which occur in places such as fenced\n * code info strings, destinations, labels, and titles).\n * The string content type allows character escapes and -references.\n * This decodes those.\n *\n * @param {string} value\n * @returns {string}\n */\n\nexport function decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode)\n}\n/**\n * @param {string} $0\n * @param {string} $1\n * @param {string} $2\n * @returns {string}\n */\n\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1\n  } // Reference.\n\n  const head = $2.charCodeAt(0)\n\n  if (head === 35) {\n    const head = $2.charCodeAt(1)\n    const hex = head === 120 || head === 88\n    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10)\n  }\n\n  return decodeNamedCharacterReference($2) || $0\n}\n","/**\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('mdast-util-to-hast').Options} Options\n * @typedef {import('unified').Processor<any, any, any, any>} Processor\n *\n * @typedef {import('mdast-util-to-hast')} DoNotTouchAsThisImportIncludesRawInTree\n */\n\nimport {toHast} from 'mdast-util-to-hast'\n\n// Note: the `<MdastRoot, HastRoot>` overload doesnt seem to work :'(\n\n/**\n * Plugin that turns markdown into HTML to support rehype.\n *\n * *   If a destination processor is given, that processor runs with a new HTML\n *     (hast) tree (bridge-mode).\n *     As the given processor runs with a hast tree, and rehype plugins support\n *     hast, that means rehype plugins can be used with the given processor.\n *     The hast tree is discarded in the end.\n *     Its highly unlikely that you want to do this.\n * *   The common case is to not pass a destination processor, in which case the\n *     current processor continues running with a new HTML (hast) tree\n *     (mutate-mode).\n *     As the current processor continues with a hast tree, and rehype plugins\n *     support hast, that means rehype plugins can be used after\n *     `remark-rehype`.\n *     Its likely that this is what you want to do.\n *\n * @param destination\n *   Optional unified processor.\n * @param options\n *   Options passed to `mdast-util-to-hast`.\n */\nconst remarkRehype =\n  /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */\n  (\n    function (destination, options) {\n      return destination && 'run' in destination\n        ? bridge(destination, options)\n        : mutate(destination || options)\n    }\n  )\n\nexport default remarkRehype\n\n/**\n * Bridge-mode.\n * Runs the destination with the new hast tree.\n *\n * @type {import('unified').Plugin<[Processor, Options?], MdastRoot>}\n */\nfunction bridge(destination, options) {\n  return (node, file, next) => {\n    destination.run(toHast(node, options), file, (error) => {\n      next(error)\n    })\n  }\n}\n\n/**\n * Mutate-mode.\n * Further plugins run on the hast tree.\n *\n * @type {import('unified').Plugin<[Options?]|void[], MdastRoot, HastRoot>}\n */\nfunction mutate(options) {\n  // @ts-expect-error: assume a corresponding node is returned by `toHast`.\n  return (node) => toHast(node, options)\n}\n","/**\n * @typedef {import('hast').Content} HastContent\n * @typedef {import('hast').Root} HastRoot\n *\n * @typedef {import('mdast').Content} MdastContent\n * @typedef {import('mdast').Root} MdastRoot\n *\n * @typedef {import('./state.js').Options} Options\n */\n\n/**\n * @typedef {HastRoot | HastContent} HastNodes\n * @typedef {MdastRoot | MdastContent} MdastNodes\n */\n\nimport {footer} from './footer.js'\nimport {createState} from './state.js'\n\n/**\n * Transform mdast to hast.\n *\n * ##### Notes\n *\n * ###### HTML\n *\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\n * as semistandard `raw` nodes.\n * Most utilities ignore `raw` nodes but two notable ones dont:\n *\n * *   `hast-util-to-html` also has an option `allowDangerousHtml` which will\n *     output the raw HTML.\n *     This is typically discouraged as noted by the option name but is useful\n *     if you completely trust authors\n * *   `hast-util-raw` can handle the raw embedded HTML strings by parsing them\n *     into standard hast nodes (`element`, `text`, etc).\n *     This is a heavy task as it needs a full HTML parser, but it is the only\n *     way to support untrusted content\n *\n * ###### Footnotes\n *\n * Many options supported here relate to footnotes.\n * Footnotes are not specified by CommonMark, which we follow by default.\n * They are supported by GitHub, so footnotes can be enabled in markdown with\n * `mdast-util-gfm`.\n *\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\n * that explains footnotes, which is hidden for sighted users but shown to\n * assistive technology.\n * When your page is not in English, you must define translated values.\n *\n * Back references use ARIA attributes, but the section label itself uses a\n * heading that is hidden with an `sr-only` class.\n * To show it to sighted users, define different attributes in\n * `footnoteLabelProperties`.\n *\n * ###### Clobbering\n *\n * Footnotes introduces a problem, as it links footnote calls to footnote\n * definitions on the page through `id` attributes generated from user content,\n * which results in DOM clobbering.\n *\n * DOM clobbering is this:\n *\n * ```html\n * <p id=x></p>\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n * ```\n *\n * Elements by their ID are made available by browsers on the `window` object,\n * which is a security risk.\n * Using a prefix solves this problem.\n *\n * More information on how to handle clobbering and the prefix is explained in\n * Example: headings (DOM clobbering) in `rehype-sanitize`.\n *\n * ###### Unknown nodes\n *\n * Unknown nodes are nodes with a type that isnt in `handlers` or `passThrough`.\n * The default behavior for unknown nodes is:\n *\n * *   when the node has a `value` (and doesnt have `data.hName`,\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\n *     node\n * *   otherwise, create a `<div>` element (which could be changed with\n *     `data.hName`), with its children mapped from mdast to hast as well\n *\n * This behavior can be changed by passing an `unknownHandler`.\n *\n * @param {MdastNodes} tree\n *   mdast tree.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {HastNodes | null | undefined}\n *   hast tree.\n */\n// To do: next major: always return a single `root`.\nexport function toHast(tree, options) {\n  const state = createState(tree, options)\n  const node = state.one(tree, null)\n  const foot = footer(state)\n\n  if (foot) {\n    // @ts-expect-error If theres a footer, there were definitions, meaning block\n    // content.\n    // So assume `node` is a parent node.\n    node.children.push({type: 'text', value: '\\n'}, foot)\n  }\n\n  // To do: next major: always return root?\n  return Array.isArray(node) ? {type: 'root', children: node} : node\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('./state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Generate a hast footer for called footnote definitions.\n *\n * @param {State} state\n *   Info passed around.\n * @returns {Element | undefined}\n *   `section` element or `undefined`.\n */\nexport function footer(state) {\n  /** @type {Array<ElementContent>} */\n  const listItems = []\n  let index = -1\n\n  while (++index < state.footnoteOrder.length) {\n    const def = state.footnoteById[state.footnoteOrder[index]]\n\n    if (!def) {\n      continue\n    }\n\n    const content = state.all(def)\n    const id = String(def.identifier).toUpperCase()\n    const safeId = normalizeUri(id.toLowerCase())\n    let referenceIndex = 0\n    /** @type {Array<ElementContent>} */\n    const backReferences = []\n\n    while (++referenceIndex <= state.footnoteCounts[id]) {\n      /** @type {Element} */\n      const backReference = {\n        type: 'element',\n        tagName: 'a',\n        properties: {\n          href:\n            '#' +\n            state.clobberPrefix +\n            'fnref-' +\n            safeId +\n            (referenceIndex > 1 ? '-' + referenceIndex : ''),\n          dataFootnoteBackref: true,\n          className: ['data-footnote-backref'],\n          ariaLabel: state.footnoteBackLabel\n        },\n        children: [{type: 'text', value: ''}]\n      }\n\n      if (referenceIndex > 1) {\n        backReference.children.push({\n          type: 'element',\n          tagName: 'sup',\n          children: [{type: 'text', value: String(referenceIndex)}]\n        })\n      }\n\n      if (backReferences.length > 0) {\n        backReferences.push({type: 'text', value: ' '})\n      }\n\n      backReferences.push(backReference)\n    }\n\n    const tail = content[content.length - 1]\n\n    if (tail && tail.type === 'element' && tail.tagName === 'p') {\n      const tailTail = tail.children[tail.children.length - 1]\n      if (tailTail && tailTail.type === 'text') {\n        tailTail.value += ' '\n      } else {\n        tail.children.push({type: 'text', value: ' '})\n      }\n\n      tail.children.push(...backReferences)\n    } else {\n      content.push(...backReferences)\n    }\n\n    /** @type {Element} */\n    const listItem = {\n      type: 'element',\n      tagName: 'li',\n      properties: {id: state.clobberPrefix + 'fn-' + safeId},\n      children: state.wrap(content, true)\n    }\n\n    state.patch(def, listItem)\n\n    listItems.push(listItem)\n  }\n\n  if (listItems.length === 0) {\n    return\n  }\n\n  return {\n    type: 'element',\n    tagName: 'section',\n    properties: {dataFootnotes: true, className: ['footnotes']},\n    children: [\n      {\n        type: 'element',\n        tagName: state.footnoteLabelTagName,\n        properties: {\n          // To do: use structured clone.\n          ...JSON.parse(JSON.stringify(state.footnoteLabelProperties)),\n          id: 'footnote-label'\n        },\n        children: [{type: 'text', value: state.footnoteLabel}]\n      },\n      {type: 'text', value: '\\n'},\n      {\n        type: 'element',\n        tagName: 'ol',\n        properties: {},\n        children: state.wrap(listItems, true)\n      },\n      {type: 'text', value: '\\n'}\n    ]\n  }\n}\n","import {asciiAlphanumeric} from 'micromark-util-character'\nimport {encode} from 'micromark-util-encode'\n\n/**\n * Make a value safe for injection as a URL.\n *\n * This encodes unsafe characters with percent-encoding and skips already\n * encoded sequences (see `normalizeUri` below).\n * Further unsafe characters are encoded as character references (see\n * `micromark-util-encode`).\n *\n * Then, a regex of allowed protocols can be given, in which case the URL is\n * sanitized.\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`,\n * or `/^https?$/i` for `img[src]`.\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\n * as a dangerous example, `javascript:`), the value is ignored.\n *\n * @param {string|undefined} url\n * @param {RegExp} [protocol]\n * @returns {string}\n */\nexport function sanitizeUri(url, protocol) {\n  const value = encode(normalizeUri(url || ''))\n\n  if (!protocol) {\n    return value\n  }\n\n  const colon = value.indexOf(':')\n  const questionMark = value.indexOf('?')\n  const numberSign = value.indexOf('#')\n  const slash = value.indexOf('/')\n\n  if (\n    // If there is no protocol, its relative.\n    colon < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign) || // It is a protocol, it should be allowed.\n    protocol.test(value.slice(0, colon))\n  ) {\n    return value\n  }\n\n  return ''\n}\n/**\n * Normalize a URL (such as used in definitions).\n *\n * Encode unsafe characters with percent-encoding, skipping already encoded\n * sequences.\n *\n * @param {string} value\n * @returns {string}\n */\n\nexport function normalizeUri(value) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n  let start = 0\n  let skip = 0\n\n  while (++index < value.length) {\n    const code = value.charCodeAt(index)\n    /** @type {string} */\n\n    let replace = '' // A correct percent encoded value.\n\n    if (\n      code === 37 &&\n      asciiAlphanumeric(value.charCodeAt(index + 1)) &&\n      asciiAlphanumeric(value.charCodeAt(index + 2))\n    ) {\n      skip = 2\n    } // ASCII.\n    else if (code < 128) {\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n        replace = String.fromCharCode(code)\n      }\n    } // Astral.\n    else if (code > 55295 && code < 57344) {\n      const next = value.charCodeAt(index + 1) // A correct surrogate pair.\n\n      if (code < 56320 && next > 56319 && next < 57344) {\n        replace = String.fromCharCode(code, next)\n        skip = 1\n      } // Lone surrogate.\n      else {\n        replace = '\\uFFFD'\n      }\n    } // Unicode.\n    else {\n      replace = String.fromCharCode(code)\n    }\n\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace))\n      start = index + skip + 1\n      replace = ''\n    }\n\n    if (skip) {\n      index += skip\n      skip = 0\n    }\n  }\n\n  return result.join('') + value.slice(start)\n}\n","const characterReferences = {'\"': 'quot', '&': 'amp', '<': 'lt', '>': 'gt'}\n\n/**\n * Encode only the dangerous HTML characters.\n *\n * This ensures that certain characters which have special meaning in HTML are\n * dealt with.\n * Technically, we can skip `>` and `\"` in many cases, but CM includes them.\n *\n * @param {string} value\n * @returns {string}\n */\nexport function encode(value) {\n  return value.replace(/[\"&<>]/g, replace)\n\n  /**\n   * @param {string} value\n   * @returns {string}\n   */\n  function replace(value) {\n    // @ts-expect-error Hush, its fine.\n    return '&' + characterReferences[value] + ';'\n  }\n}\n","/**\n * @typedef {import('hast').Content} HastContent\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Content} MdastContent\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Parent} MdastParent\n * @typedef {import('mdast').Root} MdastRoot\n */\n\n/**\n * @typedef {HastRoot | HastContent} HastNodes\n * @typedef {MdastRoot | MdastContent} MdastNodes\n * @typedef {Extract<MdastNodes, MdastParent>} MdastParents\n *\n * @typedef EmbeddedHastFields\n *   hast fields.\n * @property {string | null | undefined} [hName]\n *   Generate a specific element with this tag name instead.\n * @property {HastProperties | null | undefined} [hProperties]\n *   Generate an element with these properties instead.\n * @property {Array<HastElementContent> | null | undefined} [hChildren]\n *   Generate an element with this content instead.\n *\n * @typedef {Record<string, unknown> & EmbeddedHastFields} MdastData\n *   mdast data with embedded hast fields.\n *\n * @typedef {MdastNodes & {data?: MdastData | null | undefined}} MdastNodeWithData\n *   mdast node with embedded hast data.\n *\n * @typedef PointLike\n *   Point-like value.\n * @property {number | null | undefined} [line]\n *   Line.\n * @property {number | null | undefined} [column]\n *   Column.\n * @property {number | null | undefined} [offset]\n *   Offset.\n *\n * @typedef PositionLike\n *   Position-like value.\n * @property {PointLike | null | undefined} [start]\n *   Point-like value.\n * @property {PointLike | null | undefined} [end]\n *   Point-like value.\n *\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | null | undefined} parent\n *   Parent of `node`.\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n *   hast node.\n *\n * @callback HFunctionProps\n *   Signature of `state` for when props are passed.\n * @param {MdastNodes | PositionLike | null | undefined} node\n *   mdast node or unist position.\n * @param {string} tagName\n *   HTML tag name.\n * @param {HastProperties} props\n *   Properties.\n * @param {Array<HastElementContent> | null | undefined} [children]\n *   hast content.\n * @returns {HastElement}\n *   Compiled element.\n *\n * @callback HFunctionNoProps\n *   Signature of `state` for when no props are passed.\n * @param {MdastNodes | PositionLike | null | undefined} node\n *   mdast node or unist position.\n * @param {string} tagName\n *   HTML tag name.\n * @param {Array<HastElementContent> | null | undefined} [children]\n *   hast content.\n * @returns {HastElement}\n *   Compiled element.\n *\n * @typedef HFields\n *   Info on `state`.\n * @property {boolean} dangerous\n *   Whether HTML is allowed.\n * @property {string} clobberPrefix\n *   Prefix to use to prevent DOM clobbering.\n * @property {string} footnoteLabel\n *   Label to use to introduce the footnote section.\n * @property {string} footnoteLabelTagName\n *   HTML used for the footnote label.\n * @property {HastProperties} footnoteLabelProperties\n *   Properties on the HTML tag used for the footnote label.\n * @property {string} footnoteBackLabel\n *   Label to use from backreferences back to their footnote call.\n * @property {(identifier: string) => MdastDefinition | null} definition\n *   Definition cache.\n * @property {Record<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Record<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {Handler} unknownHandler\n *   Handler for any none not in `passThrough` or otherwise handled.\n * @property {(from: MdastNodes, node: HastNodes) => void} patch\n *   Copy a nodes positional info.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => Type | HastElement} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {(node: MdastNodes, parent: MdastParents | null | undefined) => HastElementContent | Array<HastElementContent> | null | undefined} one\n *   Transform an mdast node to hast.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastContent>(nodes: Array<Type>, loose?: boolean | null | undefined) => Array<Type | HastText>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n * @property {(left: MdastNodeWithData | PositionLike | null | undefined, right: HastElementContent) => HastElementContent} augment\n *   Like `state` but lower-level and usable on non-elements.\n *   Deprecated: use `patch` and `applyData`.\n * @property {Array<string>} passThrough\n *   List of node types to pass through untouched (except for their children).\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree.\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` attribute on footnotes to prevent it from\n *   *clobbering*.\n * @property {string | null | undefined} [footnoteBackLabel='Back to content']\n *   Label to use from backreferences back to their footnote call (affects\n *   screen readers).\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Label to use for the footnotes section (affects screen readers).\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (note that `id: 'footnote-label'`\n *   is always added as footnote calls use it with `aria-describedby` to\n *   provide an accessible label).\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   Tag name to use for the footnote label.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes.\n * @property {Array<string> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes.\n *\n * @typedef {Record<string, Handler>} Handlers\n *   Handle nodes.\n *\n * @typedef {HFunctionProps & HFunctionNoProps & HFields} State\n *   Info passed around.\n */\n\nimport {visit} from 'unist-util-visit'\nimport {position, pointStart, pointEnd} from 'unist-util-position'\nimport {generated} from 'unist-util-generated'\nimport {definitions} from 'mdast-util-definitions'\nimport {handlers} from './handlers/index.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create `state` from an mdast tree.\n *\n * @param {MdastNodes} tree\n *   mdast node to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {State}\n *   `state` function.\n */\nexport function createState(tree, options) {\n  const settings = options || {}\n  const dangerous = settings.allowDangerousHtml || false\n  /** @type {Record<string, MdastFootnoteDefinition>} */\n  const footnoteById = {}\n\n  // To do: next major: add `options` to state, remove:\n  // `dangerous`, `clobberPrefix`, `footnoteLabel`, `footnoteLabelTagName`,\n  // `footnoteLabelProperties`, `footnoteBackLabel`, `passThrough`,\n  // `unknownHandler`.\n\n  // To do: next major: move to `state.options.allowDangerousHtml`.\n  state.dangerous = dangerous\n  // To do: next major: move to `state.options`.\n  state.clobberPrefix =\n    settings.clobberPrefix === undefined || settings.clobberPrefix === null\n      ? 'user-content-'\n      : settings.clobberPrefix\n  // To do: next major: move to `state.options`.\n  state.footnoteLabel = settings.footnoteLabel || 'Footnotes'\n  // To do: next major: move to `state.options`.\n  state.footnoteLabelTagName = settings.footnoteLabelTagName || 'h2'\n  // To do: next major: move to `state.options`.\n  state.footnoteLabelProperties = settings.footnoteLabelProperties || {\n    className: ['sr-only']\n  }\n  // To do: next major: move to `state.options`.\n  state.footnoteBackLabel = settings.footnoteBackLabel || 'Back to content'\n  // To do: next major: move to `state.options`.\n  state.unknownHandler = settings.unknownHandler\n  // To do: next major: move to `state.options`.\n  state.passThrough = settings.passThrough\n\n  state.handlers = {...handlers, ...settings.handlers}\n\n  // To do: next major: replace utility with `definitionById` object, so we\n  // only walk once (as we need footnotes too).\n  state.definition = definitions(tree)\n  state.footnoteById = footnoteById\n  /** @type {Array<string>} */\n  state.footnoteOrder = []\n  /** @type {Record<string, number>} */\n  state.footnoteCounts = {}\n\n  state.patch = patch\n  state.applyData = applyData\n  state.one = oneBound\n  state.all = allBound\n  state.wrap = wrap\n  // To do: next major: remove `augment`.\n  state.augment = augment\n\n  visit(tree, 'footnoteDefinition', (definition) => {\n    const id = String(definition.identifier).toUpperCase()\n\n    // Mimick CM behavior of link definitions.\n    // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8290999/index.js#L26>.\n    if (!own.call(footnoteById, id)) {\n      footnoteById[id] = definition\n    }\n  })\n\n  // @ts-expect-error Hush, its fine!\n  return state\n\n  /**\n   * Finalise the created `right`, a hast node, from `left`, an mdast node.\n   *\n   * @param {MdastNodeWithData | PositionLike | null | undefined} left\n   * @param {HastElementContent} right\n   * @returns {HastElementContent}\n   */\n  /* c8 ignore start */\n  // To do: next major: remove.\n  function augment(left, right) {\n    // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n    if (left && 'data' in left && left.data) {\n      /** @type {MdastData} */\n      const data = left.data\n\n      if (data.hName) {\n        if (right.type !== 'element') {\n          right = {\n            type: 'element',\n            tagName: '',\n            properties: {},\n            children: []\n          }\n        }\n\n        right.tagName = data.hName\n      }\n\n      if (right.type === 'element' && data.hProperties) {\n        right.properties = {...right.properties, ...data.hProperties}\n      }\n\n      if ('children' in right && right.children && data.hChildren) {\n        right.children = data.hChildren\n      }\n    }\n\n    if (left) {\n      const ctx = 'type' in left ? left : {position: left}\n\n      if (!generated(ctx)) {\n        // @ts-expect-error: fine.\n        right.position = {start: pointStart(ctx), end: pointEnd(ctx)}\n      }\n    }\n\n    return right\n  }\n  /* c8 ignore stop */\n\n  /**\n   * Create an element for `node`.\n   *\n   * @type {HFunctionProps}\n   */\n  /* c8 ignore start */\n  // To do: next major: remove.\n  function state(node, tagName, props, children) {\n    if (Array.isArray(props)) {\n      children = props\n      props = {}\n    }\n\n    // @ts-expect-error augmenting an element yields an element.\n    return augment(node, {\n      type: 'element',\n      tagName,\n      properties: props || {},\n      children: children || []\n    })\n  }\n  /* c8 ignore stop */\n\n  /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | null | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n   *   Resulting hast node.\n   */\n  function oneBound(node, parent) {\n    // @ts-expect-error: thats a state :)\n    return one(state, node, parent)\n  }\n\n  /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */\n  function allBound(parent) {\n    // @ts-expect-error: thats a state :)\n    return all(state, parent)\n  }\n}\n\n/**\n * Copy a nodes positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {void}\n *   Nothing.\n */\nfunction patch(from, to) {\n  if (from.position) to.position = position(from)\n}\n\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {Type | HastElement}\n *   Nothing.\n */\nfunction applyData(from, to) {\n  /** @type {Type | HastElement} */\n  let result = to\n\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n  if (from && from.data) {\n    const hName = from.data.hName\n    const hChildren = from.data.hChildren\n    const hProperties = from.data.hProperties\n\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName\n      }\n      // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent is likely to keep the content around (otherwise: pass\n      // `hChildren`).\n      else {\n        result = {\n          type: 'element',\n          tagName: hName,\n          properties: {},\n          children: []\n        }\n\n        // To do: next major: take the children from the `root`, or inject the\n        // raw/text/comment or so into the element?\n        // if ('children' in node) {\n        //   // @ts-expect-error: assume `children` are allowed in elements.\n        //   result.children = node.children\n        // } else {\n        //   // @ts-expect-error: assume `node` is allowed in elements.\n        //   result.children.push(node)\n        // }\n      }\n    }\n\n    if (result.type === 'element' && hProperties) {\n      result.properties = {...result.properties, ...hProperties}\n    }\n\n    if (\n      'children' in result &&\n      result.children &&\n      hChildren !== null &&\n      hChildren !== undefined\n    ) {\n      // @ts-expect-error: assume valid children are defined.\n      result.children = hChildren\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform an mdast node into a hast node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   mdast node.\n * @param {MdastParents | null | undefined} [parent]\n *   Parent of `node`.\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n *   Resulting hast node.\n */\n// To do: next major: do not expose, keep bound.\nexport function one(state, node, parent) {\n  const type = node && node.type\n\n  // Fail on non-nodes.\n  if (!type) {\n    throw new Error('Expected node, got `' + node + '`')\n  }\n\n  if (own.call(state.handlers, type)) {\n    return state.handlers[type](state, node, parent)\n  }\n\n  if (state.passThrough && state.passThrough.includes(type)) {\n    // To do: next major: deep clone.\n    // @ts-expect-error: types of passed through nodes are expected to be added manually.\n    return 'children' in node ? {...node, children: all(state, node)} : node\n  }\n\n  if (state.unknownHandler) {\n    return state.unknownHandler(state, node, parent)\n  }\n\n  return defaultUnknownHandler(state, node)\n}\n\n/**\n * Transform the children of an mdast node into hast nodes.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} parent\n *   mdast node to compile\n * @returns {Array<HastElementContent>}\n *   Resulting hast nodes.\n */\n// To do: next major: do not expose, keep bound.\nexport function all(state, parent) {\n  /** @type {Array<HastElementContent>} */\n  const values = []\n\n  if ('children' in parent) {\n    const nodes = parent.children\n    let index = -1\n    while (++index < nodes.length) {\n      const result = one(state, nodes[index], parent)\n\n      // To do: see if we van clean this? Can we merge texts?\n      if (result) {\n        if (index && nodes[index - 1].type === 'break') {\n          if (!Array.isArray(result) && result.type === 'text') {\n            result.value = result.value.replace(/^\\s+/, '')\n          }\n\n          if (!Array.isArray(result) && result.type === 'element') {\n            const head = result.children[0]\n\n            if (head && head.type === 'text') {\n              head.value = head.value.replace(/^\\s+/, '')\n            }\n          }\n        }\n\n        if (Array.isArray(result)) {\n          values.push(...result)\n        } else {\n          values.push(result)\n        }\n      }\n    }\n  }\n\n  return values\n}\n\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastText | HastElement}\n *   Resulting hast node.\n */\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {}\n  /** @type {HastText | HastElement} */\n  const result =\n    'value' in node &&\n    !(own.call(data, 'hProperties') || own.call(data, 'hChildren'))\n      ? {type: 'text', value: node.value}\n      : {\n          type: 'element',\n          tagName: 'div',\n          properties: {},\n          children: all(state, node)\n        }\n\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * Wrap `nodes` with line endings between each node.\n *\n * @template {HastContent} Type\n *   Node type.\n * @param {Array<Type>} nodes\n *   List of nodes to wrap.\n * @param {boolean | null | undefined} [loose=false]\n *   Whether to add line endings at start and end.\n * @returns {Array<Type | HastText>}\n *   Wrapped nodes.\n */\nexport function wrap(nodes, loose) {\n  /** @type {Array<Type | HastText>} */\n  const result = []\n  let index = -1\n\n  if (loose) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  while (++index < nodes.length) {\n    if (index) result.push({type: 'text', value: '\\n'})\n    result.push(nodes[index])\n  }\n\n  if (loose && nodes.length > 0) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  return result\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Check if `Child` can be a child of `Ancestor`.\n *\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\n * `never`.\n *\n * @template {Node} Ancestor\n *   Node type.\n * @template {Node} Child\n *   Node type.\n * @typedef {(\n *   Ancestor extends Parent\n *     ? Child extends Ancestor['children'][number]\n *       ? Ancestor\n *       : never\n *     : never\n * )} ParentsOf\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends Node ? number | null : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * Build a typed `Visitor` function from a node and all possible parents.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Visited\n *   Node type.\n * @template {Parent} Ancestor\n *   Parent type.\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\n */\n\n/**\n * Build a typed `Visitor` function from a list of descendants and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\n *     Extract<Descendant, Parent>\n *   >\n * )} BuildVisitorFromDescendants\n */\n\n/**\n * Build a typed `Visitor` function from a tree and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} [Tree=Node]\n *   Node type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visit =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array<Parent>} parents\n       */\n      function overload(node, parents) {\n        const parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this nodes children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The nodes position in its parent.\n * @param parent\n *   The nodes parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if youre going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n","/**\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Get the starting point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointStart = point('start')\n\n/**\n * Get the ending point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointEnd = point('end')\n\n/**\n * Get the positional info of `node`.\n *\n * @param {NodeLike | Node | null | undefined} [node]\n *   Node.\n * @returns {Position}\n *   Position.\n */\nexport function position(node) {\n  return {start: pointStart(node), end: pointEnd(node)}\n}\n\n/**\n * Get the positional info of `node`.\n *\n * @param {'start' | 'end'} type\n *   Side.\n * @returns\n *   Getter.\n */\nfunction point(type) {\n  return point\n\n  /**\n   * Get the point info of `node` at a bound side.\n   *\n   * @param {NodeLike | Node | null | undefined} [node]\n   * @returns {Point}\n   */\n  function point(node) {\n    const point = (node && node.position && node.position[type]) || {}\n\n    // To do: next major: dont return points when invalid.\n    return {\n      // @ts-expect-error: in practice, null is allowed.\n      line: point.line || null,\n      // @ts-expect-error: in practice, null is allowed.\n      column: point.column || null,\n      // @ts-expect-error: in practice, null is allowed.\n      offset: point.offset > -1 ? point.offset : null\n    }\n  }\n}\n","/**\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef NodeLike\n * @property {PositionLike | null | undefined} [position]\n */\n\n/**\n * Check if `node` is generated.\n *\n * @param {NodeLike | null | undefined} [node]\n *   Node to check.\n * @returns {boolean}\n *   Whether `node` is generated (does not have positional info).\n */\nexport function generated(node) {\n  return (\n    !node ||\n    !node.position ||\n    !node.position.start ||\n    !node.position.start.line ||\n    !node.position.start.column ||\n    !node.position.end ||\n    !node.position.end.line ||\n    !node.position.end.column\n  )\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Definition} Definition\n */\n\n/**\n * @typedef {Root | Content} Node\n *\n * @callback GetDefinition\n *   Get a definition by identifier.\n * @param {string | null | undefined} [identifier]\n *   Identifier of definition.\n * @returns {Definition | null}\n *   Definition corresponding to `identifier` or `null`.\n */\n\nimport {visit} from 'unist-util-visit'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Find definitions in `tree`.\n *\n * Uses CommonMark precedence, which means that earlier definitions are\n * preferred over duplicate later definitions.\n *\n * @param {Node} tree\n *   Tree to check.\n * @returns {GetDefinition}\n *   Getter.\n */\nexport function definitions(tree) {\n  /** @type {Record<string, Definition>} */\n  const cache = Object.create(null)\n\n  if (!tree || !tree.type) {\n    throw new Error('mdast-util-definitions expected node')\n  }\n\n  visit(tree, 'definition', (definition) => {\n    const id = clean(definition.identifier)\n    if (id && !own.call(cache, id)) {\n      cache[id] = definition\n    }\n  })\n\n  return definition\n\n  /** @type {GetDefinition} */\n  function definition(identifier) {\n    const id = clean(identifier)\n    // To do: next major: return `undefined` when not found.\n    return id && own.call(cache, id) ? cache[id] : null\n  }\n}\n\n/**\n * @param {string | null | undefined} [value]\n * @returns {string}\n */\nfunction clean(value) {\n  return String(value || '').toUpperCase()\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {strikethrough} from './delete.js'\nimport {emphasis} from './emphasis.js'\nimport {footnoteReference} from './footnote-reference.js'\nimport {footnote} from './footnote.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {imageReference} from './image-reference.js'\nimport {image} from './image.js'\nimport {inlineCode} from './inline-code.js'\nimport {linkReference} from './link-reference.js'\nimport {link} from './link.js'\nimport {listItem} from './list-item.js'\nimport {list} from './list.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {table} from './table.js'\nimport {tableRow} from './table-row.js'\nimport {tableCell} from './table-cell.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default handlers for nodes.\n */\nexport const handlers = {\n  blockquote,\n  break: hardBreak,\n  code,\n  delete: strikethrough,\n  emphasis,\n  footnoteReference,\n  footnote,\n  heading,\n  html,\n  imageReference,\n  image,\n  inlineCode,\n  linkReference,\n  link,\n  listItem,\n  list,\n  paragraph,\n  root,\n  strong,\n  table,\n  tableCell,\n  tableRow,\n  text,\n  thematicBreak,\n  toml: ignore,\n  yaml: ignore,\n  definition: ignore,\n  footnoteDefinition: ignore\n}\n\n// Return nothing for nodes that are ignored.\nfunction ignore() {\n  // To do: next major: return `undefined`.\n  return null\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `blockquote` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Blockquote} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function blockquote(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'blockquote',\n    properties: {},\n    children: state.wrap(state.all(node), true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `break` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Break} node\n *   mdast node.\n * @returns {Array<Element | Text>}\n *   hast element content.\n */\nexport function hardBreak(state, node) {\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'br', properties: {}, children: []}\n  state.patch(node, result)\n  return [state.applyData(node, result), {type: 'text', value: '\\n'}]\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../state.js').State} State\n\n */\n\n/**\n * Turn an mdast `code` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Code} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function code(state, node) {\n  const value = node.value ? node.value + '\\n' : ''\n  // To do: next major, use `node.lang` w/o regex, the splittings been going\n  // on for years in remark now.\n  const lang = node.lang ? node.lang.match(/^[^ \\t]+(?=[ \\t]|$)/) : null\n  /** @type {Properties} */\n  const properties = {}\n\n  if (lang) {\n    properties.className = ['language-' + lang]\n  }\n\n  // Create `<code>`.\n  /** @type {Element} */\n  let result = {\n    type: 'element',\n    tagName: 'code',\n    properties,\n    children: [{type: 'text', value}]\n  }\n\n  if (node.meta) {\n    result.data = {meta: node.meta}\n  }\n\n  state.patch(node, result)\n  result = state.applyData(node, result)\n\n  // Create `<pre>`.\n  result = {type: 'element', tagName: 'pre', properties: {}, children: [result]}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Delete} Delete\n * @typedef {import('../state.js').State} State\n\n */\n\n/**\n * Turn an mdast `delete` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Delete} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strikethrough(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'del',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `emphasis` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Emphasis} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function emphasis(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'em',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('hast').Element} Element\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `footnoteReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {FootnoteReference} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function footnoteReference(state, node) {\n  const id = String(node.identifier).toUpperCase()\n  const safeId = normalizeUri(id.toLowerCase())\n  const index = state.footnoteOrder.indexOf(id)\n  /** @type {number} */\n  let counter\n\n  if (index === -1) {\n    state.footnoteOrder.push(id)\n    state.footnoteCounts[id] = 1\n    counter = state.footnoteOrder.length\n  } else {\n    state.footnoteCounts[id]++\n    counter = index + 1\n  }\n\n  const reuseCounter = state.footnoteCounts[id]\n\n  /** @type {Element} */\n  const link = {\n    type: 'element',\n    tagName: 'a',\n    properties: {\n      href: '#' + state.clobberPrefix + 'fn-' + safeId,\n      id:\n        state.clobberPrefix +\n        'fnref-' +\n        safeId +\n        (reuseCounter > 1 ? '-' + reuseCounter : ''),\n      dataFootnoteRef: true,\n      ariaDescribedBy: ['footnote-label']\n    },\n    children: [{type: 'text', value: String(counter)}]\n  }\n  state.patch(node, link)\n\n  /** @type {Element} */\n  const sup = {\n    type: 'element',\n    tagName: 'sup',\n    properties: {},\n    children: [link]\n  }\n  state.patch(node, sup)\n  return state.applyData(node, sup)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Footnote} Footnote\n * @typedef {import('../state.js').State} State\n */\n\nimport {footnoteReference} from './footnote-reference.js'\n\n// To do: when both:\n// * <https://github.com/micromark/micromark-extension-footnote>\n// * <https://github.com/syntax-tree/mdast-util-footnote>\n// are archived, remove this (also from mdast).\n// These inline notes are not used in GFM.\n\n/**\n * Turn an mdast `footnote` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Footnote} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function footnote(state, node) {\n  const footnoteById = state.footnoteById\n  let no = 1\n\n  while (no in footnoteById) no++\n\n  const identifier = String(no)\n\n  footnoteById[identifier] = {\n    type: 'footnoteDefinition',\n    identifier,\n    children: [{type: 'paragraph', children: node.children}],\n    position: node.position\n  }\n\n  return footnoteReference(state, {\n    type: 'footnoteReference',\n    identifier,\n    position: node.position\n  })\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `heading` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Heading} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function heading(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'h' + node.depth,\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').HTML} Html\n * @typedef {import('../state.js').State} State\n * @typedef {import('../../index.js').Raw} Raw\n */\n\n/**\n * Turn an mdast `html` node into hast (`raw` node in dangerous mode, otherwise\n * nothing).\n *\n * @param {State} state\n *   Info passed around.\n * @param {Html} node\n *   mdast node.\n * @returns {Raw | Element | null}\n *   hast node.\n */\nexport function html(state, node) {\n  if (state.dangerous) {\n    /** @type {Raw} */\n    const result = {type: 'raw', value: node.value}\n    state.patch(node, result)\n    return state.applyData(node, result)\n  }\n\n  // To do: next major: return `undefined`.\n  return null\n}\n","/**\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `imageReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ImageReference} node\n *   mdast node.\n * @returns {ElementContent | Array<ElementContent>}\n *   hast node.\n */\nexport function imageReference(state, node) {\n  const def = state.definition(node.identifier)\n\n  if (!def) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(def.url || ''), alt: node.alt}\n\n  if (def.title !== null && def.title !== undefined) {\n    properties.title = def.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Reference} Reference\n * @typedef {import('mdast').Root} Root\n *\n * @typedef {import('./state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Reference>} References\n */\n\n// To do: next major: always return array.\n\n/**\n * Return the content of a reference without definition as plain text.\n *\n * @param {State} state\n *   Info passed around.\n * @param {References} node\n *   Reference node (image, link).\n * @returns {ElementContent | Array<ElementContent>}\n *   hast content.\n */\nexport function revert(state, node) {\n  const subtype = node.referenceType\n  let suffix = ']'\n\n  if (subtype === 'collapsed') {\n    suffix += '[]'\n  } else if (subtype === 'full') {\n    suffix += '[' + (node.label || node.identifier) + ']'\n  }\n\n  if (node.type === 'imageReference') {\n    return {type: 'text', value: '![' + node.alt + suffix}\n  }\n\n  const contents = state.all(node)\n  const head = contents[0]\n\n  if (head && head.type === 'text') {\n    head.value = '[' + head.value\n  } else {\n    contents.unshift({type: 'text', value: '['})\n  }\n\n  const tail = contents[contents.length - 1]\n\n  if (tail && tail.type === 'text') {\n    tail.value += suffix\n  } else {\n    contents.push({type: 'text', value: suffix})\n  }\n\n  return contents\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `image` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Image} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function image(state, node) {\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(node.url)}\n\n  if (node.alt !== null && node.alt !== undefined) {\n    properties.alt = node.alt\n  }\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `inlineCode` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {InlineCode} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function inlineCode(state, node) {\n  /** @type {Text} */\n  const text = {type: 'text', value: node.value.replace(/\\r?\\n|\\r/g, ' ')}\n  state.patch(node, text)\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'code',\n    properties: {},\n    children: [text]\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `linkReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {LinkReference} node\n *   mdast node.\n * @returns {ElementContent | Array<ElementContent>}\n *   hast node.\n */\nexport function linkReference(state, node) {\n  const def = state.definition(node.identifier)\n\n  if (!def) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(def.url || '')}\n\n  if (def.title !== null && def.title !== undefined) {\n    properties.title = def.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `link` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Link} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function link(state, node) {\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(node.url)}\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */\n\n/**\n * Turn an mdast `listItem` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ListItem} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function listItem(state, node, parent) {\n  const results = state.all(node)\n  const loose = parent ? listLoose(parent) : listItemLoose(node)\n  /** @type {Properties} */\n  const properties = {}\n  /** @type {Array<ElementContent>} */\n  const children = []\n\n  if (typeof node.checked === 'boolean') {\n    const head = results[0]\n    /** @type {Element} */\n    let paragraph\n\n    if (head && head.type === 'element' && head.tagName === 'p') {\n      paragraph = head\n    } else {\n      paragraph = {type: 'element', tagName: 'p', properties: {}, children: []}\n      results.unshift(paragraph)\n    }\n\n    if (paragraph.children.length > 0) {\n      paragraph.children.unshift({type: 'text', value: ' '})\n    }\n\n    paragraph.children.unshift({\n      type: 'element',\n      tagName: 'input',\n      properties: {type: 'checkbox', checked: node.checked, disabled: true},\n      children: []\n    })\n\n    // According to github-markdown-css, this class hides bullet.\n    // See: <https://github.com/sindresorhus/github-markdown-css>.\n    properties.className = ['task-list-item']\n  }\n\n  let index = -1\n\n  while (++index < results.length) {\n    const child = results[index]\n\n    // Add eols before nodes, except if this is a loose, first paragraph.\n    if (\n      loose ||\n      index !== 0 ||\n      child.type !== 'element' ||\n      child.tagName !== 'p'\n    ) {\n      children.push({type: 'text', value: '\\n'})\n    }\n\n    if (child.type === 'element' && child.tagName === 'p' && !loose) {\n      children.push(...child.children)\n    } else {\n      children.push(child)\n    }\n  }\n\n  const tail = results[results.length - 1]\n\n  // Add a final eol.\n  if (tail && (loose || tail.type !== 'element' || tail.tagName !== 'p')) {\n    children.push({type: 'text', value: '\\n'})\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'li', properties, children}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * @param {Parents} node\n * @return {Boolean}\n */\nfunction listLoose(node) {\n  let loose = false\n  if (node.type === 'list') {\n    loose = node.spread || false\n    const children = node.children\n    let index = -1\n\n    while (!loose && ++index < children.length) {\n      loose = listItemLoose(children[index])\n    }\n  }\n\n  return loose\n}\n\n/**\n * @param {ListItem} node\n * @return {Boolean}\n */\nfunction listItemLoose(node) {\n  const spread = node.spread\n\n  return spread === undefined || spread === null\n    ? node.children.length > 1\n    : spread\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').List} List\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `list` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {List} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function list(state, node) {\n  /** @type {Properties} */\n  const properties = {}\n  const results = state.all(node)\n  let index = -1\n\n  if (typeof node.start === 'number' && node.start !== 1) {\n    properties.start = node.start\n  }\n\n  // Like GitHub, add a class for custom styling.\n  while (++index < results.length) {\n    const child = results[index]\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'li' &&\n      child.properties &&\n      Array.isArray(child.properties.className) &&\n      child.properties.className.includes('task-list-item')\n    ) {\n      properties.className = ['contains-task-list']\n      break\n    }\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: node.ordered ? 'ol' : 'ul',\n    properties,\n    children: state.wrap(results, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `paragraph` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Paragraph} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function paragraph(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'p',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `root` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastRoot} node\n *   mdast node.\n * @returns {HastRoot | HastElement}\n *   hast node.\n */\nexport function root(state, node) {\n  /** @type {HastRoot} */\n  const result = {type: 'root', children: state.wrap(state.all(node))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `strong` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Strong} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strong(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'strong',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Table} Table\n * @typedef {import('../state.js').State} State\n */\n\nimport {pointStart, pointEnd} from 'unist-util-position'\n\n/**\n * Turn an mdast `table` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Table} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function table(state, node) {\n  const rows = state.all(node)\n  const firstRow = rows.shift()\n  /** @type {Array<Element>} */\n  const tableContent = []\n\n  if (firstRow) {\n    /** @type {Element} */\n    const head = {\n      type: 'element',\n      tagName: 'thead',\n      properties: {},\n      children: state.wrap([firstRow], true)\n    }\n    state.patch(node.children[0], head)\n    tableContent.push(head)\n  }\n\n  if (rows.length > 0) {\n    /** @type {Element} */\n    const body = {\n      type: 'element',\n      tagName: 'tbody',\n      properties: {},\n      children: state.wrap(rows, true)\n    }\n\n    const start = pointStart(node.children[1])\n    const end = pointEnd(node.children[node.children.length - 1])\n    if (start.line && end.line) body.position = {start, end}\n    tableContent.push(body)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'table',\n    properties: {},\n    children: state.wrap(tableContent, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */\n\n/**\n * Turn an mdast `tableRow` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableRow} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function tableRow(state, node, parent) {\n  const siblings = parent ? parent.children : undefined\n  // Generate a body row when without parent.\n  const rowIndex = siblings ? siblings.indexOf(node) : 1\n  const tagName = rowIndex === 0 ? 'th' : 'td'\n  const align = parent && parent.type === 'table' ? parent.align : undefined\n  const length = align ? align.length : node.children.length\n  let cellIndex = -1\n  /** @type {Array<ElementContent>} */\n  const cells = []\n\n  while (++cellIndex < length) {\n    // Note: can also be undefined.\n    const cell = node.children[cellIndex]\n    /** @type {Properties} */\n    const properties = {}\n    const alignValue = align ? align[cellIndex] : undefined\n\n    if (alignValue) {\n      properties.align = alignValue\n    }\n\n    /** @type {Element} */\n    let result = {type: 'element', tagName, properties, children: []}\n\n    if (cell) {\n      result.children = state.all(cell)\n      state.patch(cell, result)\n      result = state.applyData(node, result)\n    }\n\n    cells.push(result)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'tr',\n    properties: {},\n    children: state.wrap(cells, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `tableCell` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableCell} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function tableCell(state, node) {\n  // Note: this function is normally not called: see `table-row` for how rows\n  // and their cells are compiled.\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'td', // Assume body cell.\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Text} HastText\n * @typedef {import('mdast').Text} MdastText\n * @typedef {import('../state.js').State} State\n */\n\nimport {trimLines} from 'trim-lines'\n\n/**\n * Turn an mdast `text` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastText} node\n *   mdast node.\n * @returns {HastText | HastElement}\n *   hast node.\n */\nexport function text(state, node) {\n  /** @type {HastText} */\n  const result = {type: 'text', value: trimLines(String(node.value))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","const tab = 9 /* `\\t` */\nconst space = 32 /* ` ` */\n\n/**\n * Remove initial and final spaces and tabs at the line breaks in `value`.\n * Does not trim initial and final spaces and tabs of the value itself.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Trimmed value.\n */\nexport function trimLines(value) {\n  const source = String(value)\n  const search = /\\r?\\n|\\r/g\n  let match = search.exec(source)\n  let last = 0\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (match) {\n    lines.push(\n      trimLine(source.slice(last, match.index), last > 0, true),\n      match[0]\n    )\n\n    last = match.index + match[0].length\n    match = search.exec(source)\n  }\n\n  lines.push(trimLine(source.slice(last), last > 0, false))\n\n  return lines.join('')\n}\n\n/**\n * @param {string} value\n *   Line to trim.\n * @param {boolean} start\n *   Whether to trim the start of the line.\n * @param {boolean} end\n *   Whether to trim the end of the line.\n * @returns {string}\n *   Trimmed line.\n */\nfunction trimLine(value, start, end) {\n  let startIndex = 0\n  let endIndex = value.length\n\n  if (start) {\n    let code = value.codePointAt(startIndex)\n\n    while (code === tab || code === space) {\n      startIndex++\n      code = value.codePointAt(startIndex)\n    }\n  }\n\n  if (end) {\n    let code = value.codePointAt(endIndex - 1)\n\n    while (code === tab || code === space) {\n      endIndex--\n      code = value.codePointAt(endIndex - 1)\n    }\n  }\n\n  return endIndex > startIndex ? value.slice(startIndex, endIndex) : ''\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `thematicBreak` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ThematicBreak} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function thematicBreak(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'hr',\n    properties: {},\n    children: []\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n  var ReactIs = require('react-is');\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = require('./factoryWithThrowingShims')();\n}\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bigint: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n","/**\n * @typedef {import('./lib/util/info.js').Info} Info\n * @typedef {import('./lib/util/schema.js').Schema} Schema\n */\n\nimport {merge} from './lib/util/merge.js'\nimport {xlink} from './lib/xlink.js'\nimport {xml} from './lib/xml.js'\nimport {xmlns} from './lib/xmlns.js'\nimport {aria} from './lib/aria.js'\nimport {html as htmlBase} from './lib/html.js'\nimport {svg as svgBase} from './lib/svg.js'\n\nexport {find} from './lib/find.js'\nexport {hastToReact} from './lib/hast-to-react.js'\nexport {normalize} from './lib/normalize.js'\nexport const html = merge([xml, xlink, xmlns, aria, htmlBase], 'html')\nexport const svg = merge([xml, xlink, xmlns, aria, svgBase], 'svg')\n","/**\n * @typedef {import('./schema.js').Properties} Properties\n * @typedef {import('./schema.js').Normal} Normal\n */\n\nimport {Schema} from './schema.js'\n\n/**\n * @param {Schema[]} definitions\n * @param {string} [space]\n * @returns {Schema}\n */\nexport function merge(definitions, space) {\n  /** @type {Properties} */\n  const property = {}\n  /** @type {Normal} */\n  const normal = {}\n  let index = -1\n\n  while (++index < definitions.length) {\n    Object.assign(property, definitions[index].property)\n    Object.assign(normal, definitions[index].normal)\n  }\n\n  return new Schema(property, normal, space)\n}\n","/**\n * @typedef {import('./info.js').Info} Info\n * @typedef {Record<string, Info>} Properties\n * @typedef {Record<string, string>} Normal\n */\n\nexport class Schema {\n  /**\n   * @constructor\n   * @param {Properties} property\n   * @param {Normal} normal\n   * @param {string} [space]\n   */\n  constructor(property, normal, space) {\n    this.property = property\n    this.normal = normal\n    if (space) {\n      this.space = space\n    }\n  }\n}\n\n/** @type {Properties} */\nSchema.prototype.property = {}\n/** @type {Normal} */\nSchema.prototype.normal = {}\n/** @type {string|null} */\nSchema.prototype.space = null\n","import {create} from './util/create.js'\n\nexport const xlink = create({\n  space: 'xlink',\n  transform(_, prop) {\n    return 'xlink:' + prop.slice(5).toLowerCase()\n  },\n  properties: {\n    xLinkActuate: null,\n    xLinkArcRole: null,\n    xLinkHref: null,\n    xLinkRole: null,\n    xLinkShow: null,\n    xLinkTitle: null,\n    xLinkType: null\n  }\n})\n","/**\n * @typedef {import('./schema.js').Properties} Properties\n * @typedef {import('./schema.js').Normal} Normal\n *\n * @typedef {Record<string, string>} Attributes\n *\n * @typedef {Object} Definition\n * @property {Record<string, number|null>} properties\n * @property {(attributes: Attributes, property: string) => string} transform\n * @property {string} [space]\n * @property {Attributes} [attributes]\n * @property {Array<string>} [mustUseProperty]\n */\n\nimport {normalize} from '../normalize.js'\nimport {Schema} from './schema.js'\nimport {DefinedInfo} from './defined-info.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {Definition} definition\n * @returns {Schema}\n */\nexport function create(definition) {\n  /** @type {Properties} */\n  const property = {}\n  /** @type {Normal} */\n  const normal = {}\n  /** @type {string} */\n  let prop\n\n  for (prop in definition.properties) {\n    if (own.call(definition.properties, prop)) {\n      const value = definition.properties[prop]\n      const info = new DefinedInfo(\n        prop,\n        definition.transform(definition.attributes || {}, prop),\n        value,\n        definition.space\n      )\n\n      if (\n        definition.mustUseProperty &&\n        definition.mustUseProperty.includes(prop)\n      ) {\n        info.mustUseProperty = true\n      }\n\n      property[prop] = info\n\n      normal[normalize(prop)] = prop\n      normal[normalize(info.attribute)] = prop\n    }\n  }\n\n  return new Schema(property, normal, definition.space)\n}\n","/**\n * @param {string} value\n * @returns {string}\n */\nexport function normalize(value) {\n  return value.toLowerCase()\n}\n","import {Info} from './info.js'\nimport * as types from './types.js'\n\n/** @type {Array<keyof types>} */\n// @ts-expect-error: hush.\nconst checks = Object.keys(types)\n\nexport class DefinedInfo extends Info {\n  /**\n   * @constructor\n   * @param {string} property\n   * @param {string} attribute\n   * @param {number|null} [mask]\n   * @param {string} [space]\n   */\n  constructor(property, attribute, mask, space) {\n    let index = -1\n\n    super(property, attribute)\n\n    mark(this, 'space', space)\n\n    if (typeof mask === 'number') {\n      while (++index < checks.length) {\n        const check = checks[index]\n        mark(this, checks[index], (mask & types[check]) === types[check])\n      }\n    }\n  }\n}\n\nDefinedInfo.prototype.defined = true\n\n/**\n * @param {DefinedInfo} values\n * @param {string} key\n * @param {unknown} value\n */\nfunction mark(values, key, value) {\n  if (value) {\n    // @ts-expect-error: assume `value` matches the expected value of `key`.\n    values[key] = value\n  }\n}\n","export class Info {\n  /**\n   * @constructor\n   * @param {string} property\n   * @param {string} attribute\n   */\n  constructor(property, attribute) {\n    /** @type {string} */\n    this.property = property\n    /** @type {string} */\n    this.attribute = attribute\n  }\n}\n\n/** @type {string|null} */\nInfo.prototype.space = null\nInfo.prototype.boolean = false\nInfo.prototype.booleanish = false\nInfo.prototype.overloadedBoolean = false\nInfo.prototype.number = false\nInfo.prototype.commaSeparated = false\nInfo.prototype.spaceSeparated = false\nInfo.prototype.commaOrSpaceSeparated = false\nInfo.prototype.mustUseProperty = false\nInfo.prototype.defined = false\n","let powers = 0\n\nexport const boolean = increment()\nexport const booleanish = increment()\nexport const overloadedBoolean = increment()\nexport const number = increment()\nexport const spaceSeparated = increment()\nexport const commaSeparated = increment()\nexport const commaOrSpaceSeparated = increment()\n\nfunction increment() {\n  return 2 ** ++powers\n}\n","import {create} from './util/create.js'\n\nexport const xml = create({\n  space: 'xml',\n  transform(_, prop) {\n    return 'xml:' + prop.slice(3).toLowerCase()\n  },\n  properties: {xmlLang: null, xmlBase: null, xmlSpace: null}\n})\n","import {create} from './util/create.js'\nimport {caseInsensitiveTransform} from './util/case-insensitive-transform.js'\n\nexport const xmlns = create({\n  space: 'xmlns',\n  attributes: {xmlnsxlink: 'xmlns:xlink'},\n  transform: caseInsensitiveTransform,\n  properties: {xmlns: null, xmlnsXLink: null}\n})\n","import {caseSensitiveTransform} from './case-sensitive-transform.js'\n\n/**\n * @param {Record<string, string>} attributes\n * @param {string} property\n * @returns {string}\n */\nexport function caseInsensitiveTransform(attributes, property) {\n  return caseSensitiveTransform(attributes, property.toLowerCase())\n}\n","/**\n * @param {Record<string, string>} attributes\n * @param {string} attribute\n * @returns {string}\n */\nexport function caseSensitiveTransform(attributes, attribute) {\n  return attribute in attributes ? attributes[attribute] : attribute\n}\n","import {booleanish, number, spaceSeparated} from './util/types.js'\nimport {create} from './util/create.js'\n\nexport const aria = create({\n  transform(_, prop) {\n    return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase()\n  },\n  properties: {\n    ariaActiveDescendant: null,\n    ariaAtomic: booleanish,\n    ariaAutoComplete: null,\n    ariaBusy: booleanish,\n    ariaChecked: booleanish,\n    ariaColCount: number,\n    ariaColIndex: number,\n    ariaColSpan: number,\n    ariaControls: spaceSeparated,\n    ariaCurrent: null,\n    ariaDescribedBy: spaceSeparated,\n    ariaDetails: null,\n    ariaDisabled: booleanish,\n    ariaDropEffect: spaceSeparated,\n    ariaErrorMessage: null,\n    ariaExpanded: booleanish,\n    ariaFlowTo: spaceSeparated,\n    ariaGrabbed: booleanish,\n    ariaHasPopup: null,\n    ariaHidden: booleanish,\n    ariaInvalid: null,\n    ariaKeyShortcuts: null,\n    ariaLabel: null,\n    ariaLabelledBy: spaceSeparated,\n    ariaLevel: number,\n    ariaLive: null,\n    ariaModal: booleanish,\n    ariaMultiLine: booleanish,\n    ariaMultiSelectable: booleanish,\n    ariaOrientation: null,\n    ariaOwns: spaceSeparated,\n    ariaPlaceholder: null,\n    ariaPosInSet: number,\n    ariaPressed: booleanish,\n    ariaReadOnly: booleanish,\n    ariaRelevant: null,\n    ariaRequired: booleanish,\n    ariaRoleDescription: spaceSeparated,\n    ariaRowCount: number,\n    ariaRowIndex: number,\n    ariaRowSpan: number,\n    ariaSelected: booleanish,\n    ariaSetSize: number,\n    ariaSort: null,\n    ariaValueMax: number,\n    ariaValueMin: number,\n    ariaValueNow: number,\n    ariaValueText: null,\n    role: null\n  }\n})\n","import {\n  boolean,\n  overloadedBoolean,\n  booleanish,\n  number,\n  spaceSeparated,\n  commaSeparated\n} from './util/types.js'\nimport {create} from './util/create.js'\nimport {caseInsensitiveTransform} from './util/case-insensitive-transform.js'\n\nexport const html = create({\n  space: 'html',\n  attributes: {\n    acceptcharset: 'accept-charset',\n    classname: 'class',\n    htmlfor: 'for',\n    httpequiv: 'http-equiv'\n  },\n  transform: caseInsensitiveTransform,\n  mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],\n  properties: {\n    // Standard Properties.\n    abbr: null,\n    accept: commaSeparated,\n    acceptCharset: spaceSeparated,\n    accessKey: spaceSeparated,\n    action: null,\n    allow: null,\n    allowFullScreen: boolean,\n    allowPaymentRequest: boolean,\n    allowUserMedia: boolean,\n    alt: null,\n    as: null,\n    async: boolean,\n    autoCapitalize: null,\n    autoComplete: spaceSeparated,\n    autoFocus: boolean,\n    autoPlay: boolean,\n    capture: boolean,\n    charSet: null,\n    checked: boolean,\n    cite: null,\n    className: spaceSeparated,\n    cols: number,\n    colSpan: null,\n    content: null,\n    contentEditable: booleanish,\n    controls: boolean,\n    controlsList: spaceSeparated,\n    coords: number | commaSeparated,\n    crossOrigin: null,\n    data: null,\n    dateTime: null,\n    decoding: null,\n    default: boolean,\n    defer: boolean,\n    dir: null,\n    dirName: null,\n    disabled: boolean,\n    download: overloadedBoolean,\n    draggable: booleanish,\n    encType: null,\n    enterKeyHint: null,\n    form: null,\n    formAction: null,\n    formEncType: null,\n    formMethod: null,\n    formNoValidate: boolean,\n    formTarget: null,\n    headers: spaceSeparated,\n    height: number,\n    hidden: boolean,\n    high: number,\n    href: null,\n    hrefLang: null,\n    htmlFor: spaceSeparated,\n    httpEquiv: spaceSeparated,\n    id: null,\n    imageSizes: null,\n    imageSrcSet: null,\n    inputMode: null,\n    integrity: null,\n    is: null,\n    isMap: boolean,\n    itemId: null,\n    itemProp: spaceSeparated,\n    itemRef: spaceSeparated,\n    itemScope: boolean,\n    itemType: spaceSeparated,\n    kind: null,\n    label: null,\n    lang: null,\n    language: null,\n    list: null,\n    loading: null,\n    loop: boolean,\n    low: number,\n    manifest: null,\n    max: null,\n    maxLength: number,\n    media: null,\n    method: null,\n    min: null,\n    minLength: number,\n    multiple: boolean,\n    muted: boolean,\n    name: null,\n    nonce: null,\n    noModule: boolean,\n    noValidate: boolean,\n    onAbort: null,\n    onAfterPrint: null,\n    onAuxClick: null,\n    onBeforeMatch: null,\n    onBeforePrint: null,\n    onBeforeUnload: null,\n    onBlur: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onContextLost: null,\n    onContextMenu: null,\n    onContextRestored: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFormData: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLanguageChange: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadEnd: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMessageError: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRejectionHandled: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onScrollEnd: null,\n    onSecurityPolicyViolation: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onSlotChange: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnhandledRejection: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onWheel: null,\n    open: boolean,\n    optimum: number,\n    pattern: null,\n    ping: spaceSeparated,\n    placeholder: null,\n    playsInline: boolean,\n    poster: null,\n    preload: null,\n    readOnly: boolean,\n    referrerPolicy: null,\n    rel: spaceSeparated,\n    required: boolean,\n    reversed: boolean,\n    rows: number,\n    rowSpan: number,\n    sandbox: spaceSeparated,\n    scope: null,\n    scoped: boolean,\n    seamless: boolean,\n    selected: boolean,\n    shape: null,\n    size: number,\n    sizes: null,\n    slot: null,\n    span: number,\n    spellCheck: booleanish,\n    src: null,\n    srcDoc: null,\n    srcLang: null,\n    srcSet: null,\n    start: number,\n    step: null,\n    style: null,\n    tabIndex: number,\n    target: null,\n    title: null,\n    translate: null,\n    type: null,\n    typeMustMatch: boolean,\n    useMap: null,\n    value: booleanish,\n    width: number,\n    wrap: null,\n\n    // Legacy.\n    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis\n    align: null, // Several. Use CSS `text-align` instead,\n    aLink: null, // `<body>`. Use CSS `a:active {color}` instead\n    archive: spaceSeparated, // `<object>`. List of URIs to archives\n    axis: null, // `<td>` and `<th>`. Use `scope` on `<th>`\n    background: null, // `<body>`. Use CSS `background-image` instead\n    bgColor: null, // `<body>` and table elements. Use CSS `background-color` instead\n    border: number, // `<table>`. Use CSS `border-width` instead,\n    borderColor: null, // `<table>`. Use CSS `border-color` instead,\n    bottomMargin: number, // `<body>`\n    cellPadding: null, // `<table>`\n    cellSpacing: null, // `<table>`\n    char: null, // Several table elements. When `align=char`, sets the character to align on\n    charOff: null, // Several table elements. When `char`, offsets the alignment\n    classId: null, // `<object>`\n    clear: null, // `<br>`. Use CSS `clear` instead\n    code: null, // `<object>`\n    codeBase: null, // `<object>`\n    codeType: null, // `<object>`\n    color: null, // `<font>` and `<hr>`. Use CSS instead\n    compact: boolean, // Lists. Use CSS to reduce space between items instead\n    declare: boolean, // `<object>`\n    event: null, // `<script>`\n    face: null, // `<font>`. Use CSS instead\n    frame: null, // `<table>`\n    frameBorder: null, // `<iframe>`. Use CSS `border` instead\n    hSpace: number, // `<img>` and `<object>`\n    leftMargin: number, // `<body>`\n    link: null, // `<body>`. Use CSS `a:link {color: *}` instead\n    longDesc: null, // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`\n    lowSrc: null, // `<img>`. Use a `<picture>`\n    marginHeight: number, // `<body>`\n    marginWidth: number, // `<body>`\n    noResize: boolean, // `<frame>`\n    noHref: boolean, // `<area>`. Use no href instead of an explicit `nohref`\n    noShade: boolean, // `<hr>`. Use background-color and height instead of borders\n    noWrap: boolean, // `<td>` and `<th>`\n    object: null, // `<applet>`\n    profile: null, // `<head>`\n    prompt: null, // `<isindex>`\n    rev: null, // `<link>`\n    rightMargin: number, // `<body>`\n    rules: null, // `<table>`\n    scheme: null, // `<meta>`\n    scrolling: booleanish, // `<frame>`. Use overflow in the child context\n    standby: null, // `<object>`\n    summary: null, // `<table>`\n    text: null, // `<body>`. Use CSS `color` instead\n    topMargin: number, // `<body>`\n    valueType: null, // `<param>`\n    version: null, // `<html>`. Use a doctype.\n    vAlign: null, // Several. Use CSS `vertical-align` instead\n    vLink: null, // `<body>`. Use CSS `a:visited {color}` instead\n    vSpace: number, // `<img>` and `<object>`\n\n    // Non-standard Properties.\n    allowTransparency: null,\n    autoCorrect: null,\n    autoSave: null,\n    disablePictureInPicture: boolean,\n    disableRemotePlayback: boolean,\n    prefix: null,\n    property: null,\n    results: number,\n    security: null,\n    unselectable: null\n  }\n})\n","import {\n  boolean,\n  number,\n  spaceSeparated,\n  commaSeparated,\n  commaOrSpaceSeparated\n} from './util/types.js'\nimport {create} from './util/create.js'\nimport {caseSensitiveTransform} from './util/case-sensitive-transform.js'\n\nexport const svg = create({\n  space: 'svg',\n  attributes: {\n    accentHeight: 'accent-height',\n    alignmentBaseline: 'alignment-baseline',\n    arabicForm: 'arabic-form',\n    baselineShift: 'baseline-shift',\n    capHeight: 'cap-height',\n    className: 'class',\n    clipPath: 'clip-path',\n    clipRule: 'clip-rule',\n    colorInterpolation: 'color-interpolation',\n    colorInterpolationFilters: 'color-interpolation-filters',\n    colorProfile: 'color-profile',\n    colorRendering: 'color-rendering',\n    crossOrigin: 'crossorigin',\n    dataType: 'datatype',\n    dominantBaseline: 'dominant-baseline',\n    enableBackground: 'enable-background',\n    fillOpacity: 'fill-opacity',\n    fillRule: 'fill-rule',\n    floodColor: 'flood-color',\n    floodOpacity: 'flood-opacity',\n    fontFamily: 'font-family',\n    fontSize: 'font-size',\n    fontSizeAdjust: 'font-size-adjust',\n    fontStretch: 'font-stretch',\n    fontStyle: 'font-style',\n    fontVariant: 'font-variant',\n    fontWeight: 'font-weight',\n    glyphName: 'glyph-name',\n    glyphOrientationHorizontal: 'glyph-orientation-horizontal',\n    glyphOrientationVertical: 'glyph-orientation-vertical',\n    hrefLang: 'hreflang',\n    horizAdvX: 'horiz-adv-x',\n    horizOriginX: 'horiz-origin-x',\n    horizOriginY: 'horiz-origin-y',\n    imageRendering: 'image-rendering',\n    letterSpacing: 'letter-spacing',\n    lightingColor: 'lighting-color',\n    markerEnd: 'marker-end',\n    markerMid: 'marker-mid',\n    markerStart: 'marker-start',\n    navDown: 'nav-down',\n    navDownLeft: 'nav-down-left',\n    navDownRight: 'nav-down-right',\n    navLeft: 'nav-left',\n    navNext: 'nav-next',\n    navPrev: 'nav-prev',\n    navRight: 'nav-right',\n    navUp: 'nav-up',\n    navUpLeft: 'nav-up-left',\n    navUpRight: 'nav-up-right',\n    onAbort: 'onabort',\n    onActivate: 'onactivate',\n    onAfterPrint: 'onafterprint',\n    onBeforePrint: 'onbeforeprint',\n    onBegin: 'onbegin',\n    onCancel: 'oncancel',\n    onCanPlay: 'oncanplay',\n    onCanPlayThrough: 'oncanplaythrough',\n    onChange: 'onchange',\n    onClick: 'onclick',\n    onClose: 'onclose',\n    onCopy: 'oncopy',\n    onCueChange: 'oncuechange',\n    onCut: 'oncut',\n    onDblClick: 'ondblclick',\n    onDrag: 'ondrag',\n    onDragEnd: 'ondragend',\n    onDragEnter: 'ondragenter',\n    onDragExit: 'ondragexit',\n    onDragLeave: 'ondragleave',\n    onDragOver: 'ondragover',\n    onDragStart: 'ondragstart',\n    onDrop: 'ondrop',\n    onDurationChange: 'ondurationchange',\n    onEmptied: 'onemptied',\n    onEnd: 'onend',\n    onEnded: 'onended',\n    onError: 'onerror',\n    onFocus: 'onfocus',\n    onFocusIn: 'onfocusin',\n    onFocusOut: 'onfocusout',\n    onHashChange: 'onhashchange',\n    onInput: 'oninput',\n    onInvalid: 'oninvalid',\n    onKeyDown: 'onkeydown',\n    onKeyPress: 'onkeypress',\n    onKeyUp: 'onkeyup',\n    onLoad: 'onload',\n    onLoadedData: 'onloadeddata',\n    onLoadedMetadata: 'onloadedmetadata',\n    onLoadStart: 'onloadstart',\n    onMessage: 'onmessage',\n    onMouseDown: 'onmousedown',\n    onMouseEnter: 'onmouseenter',\n    onMouseLeave: 'onmouseleave',\n    onMouseMove: 'onmousemove',\n    onMouseOut: 'onmouseout',\n    onMouseOver: 'onmouseover',\n    onMouseUp: 'onmouseup',\n    onMouseWheel: 'onmousewheel',\n    onOffline: 'onoffline',\n    onOnline: 'ononline',\n    onPageHide: 'onpagehide',\n    onPageShow: 'onpageshow',\n    onPaste: 'onpaste',\n    onPause: 'onpause',\n    onPlay: 'onplay',\n    onPlaying: 'onplaying',\n    onPopState: 'onpopstate',\n    onProgress: 'onprogress',\n    onRateChange: 'onratechange',\n    onRepeat: 'onrepeat',\n    onReset: 'onreset',\n    onResize: 'onresize',\n    onScroll: 'onscroll',\n    onSeeked: 'onseeked',\n    onSeeking: 'onseeking',\n    onSelect: 'onselect',\n    onShow: 'onshow',\n    onStalled: 'onstalled',\n    onStorage: 'onstorage',\n    onSubmit: 'onsubmit',\n    onSuspend: 'onsuspend',\n    onTimeUpdate: 'ontimeupdate',\n    onToggle: 'ontoggle',\n    onUnload: 'onunload',\n    onVolumeChange: 'onvolumechange',\n    onWaiting: 'onwaiting',\n    onZoom: 'onzoom',\n    overlinePosition: 'overline-position',\n    overlineThickness: 'overline-thickness',\n    paintOrder: 'paint-order',\n    panose1: 'panose-1',\n    pointerEvents: 'pointer-events',\n    referrerPolicy: 'referrerpolicy',\n    renderingIntent: 'rendering-intent',\n    shapeRendering: 'shape-rendering',\n    stopColor: 'stop-color',\n    stopOpacity: 'stop-opacity',\n    strikethroughPosition: 'strikethrough-position',\n    strikethroughThickness: 'strikethrough-thickness',\n    strokeDashArray: 'stroke-dasharray',\n    strokeDashOffset: 'stroke-dashoffset',\n    strokeLineCap: 'stroke-linecap',\n    strokeLineJoin: 'stroke-linejoin',\n    strokeMiterLimit: 'stroke-miterlimit',\n    strokeOpacity: 'stroke-opacity',\n    strokeWidth: 'stroke-width',\n    tabIndex: 'tabindex',\n    textAnchor: 'text-anchor',\n    textDecoration: 'text-decoration',\n    textRendering: 'text-rendering',\n    typeOf: 'typeof',\n    underlinePosition: 'underline-position',\n    underlineThickness: 'underline-thickness',\n    unicodeBidi: 'unicode-bidi',\n    unicodeRange: 'unicode-range',\n    unitsPerEm: 'units-per-em',\n    vAlphabetic: 'v-alphabetic',\n    vHanging: 'v-hanging',\n    vIdeographic: 'v-ideographic',\n    vMathematical: 'v-mathematical',\n    vectorEffect: 'vector-effect',\n    vertAdvY: 'vert-adv-y',\n    vertOriginX: 'vert-origin-x',\n    vertOriginY: 'vert-origin-y',\n    wordSpacing: 'word-spacing',\n    writingMode: 'writing-mode',\n    xHeight: 'x-height',\n    // These were camelcased in Tiny. Now lowercased in SVG 2\n    playbackOrder: 'playbackorder',\n    timelineBegin: 'timelinebegin'\n  },\n  transform: caseSensitiveTransform,\n  properties: {\n    about: commaOrSpaceSeparated,\n    accentHeight: number,\n    accumulate: null,\n    additive: null,\n    alignmentBaseline: null,\n    alphabetic: number,\n    amplitude: number,\n    arabicForm: null,\n    ascent: number,\n    attributeName: null,\n    attributeType: null,\n    azimuth: number,\n    bandwidth: null,\n    baselineShift: null,\n    baseFrequency: null,\n    baseProfile: null,\n    bbox: null,\n    begin: null,\n    bias: number,\n    by: null,\n    calcMode: null,\n    capHeight: number,\n    className: spaceSeparated,\n    clip: null,\n    clipPath: null,\n    clipPathUnits: null,\n    clipRule: null,\n    color: null,\n    colorInterpolation: null,\n    colorInterpolationFilters: null,\n    colorProfile: null,\n    colorRendering: null,\n    content: null,\n    contentScriptType: null,\n    contentStyleType: null,\n    crossOrigin: null,\n    cursor: null,\n    cx: null,\n    cy: null,\n    d: null,\n    dataType: null,\n    defaultAction: null,\n    descent: number,\n    diffuseConstant: number,\n    direction: null,\n    display: null,\n    dur: null,\n    divisor: number,\n    dominantBaseline: null,\n    download: boolean,\n    dx: null,\n    dy: null,\n    edgeMode: null,\n    editable: null,\n    elevation: number,\n    enableBackground: null,\n    end: null,\n    event: null,\n    exponent: number,\n    externalResourcesRequired: null,\n    fill: null,\n    fillOpacity: number,\n    fillRule: null,\n    filter: null,\n    filterRes: null,\n    filterUnits: null,\n    floodColor: null,\n    floodOpacity: null,\n    focusable: null,\n    focusHighlight: null,\n    fontFamily: null,\n    fontSize: null,\n    fontSizeAdjust: null,\n    fontStretch: null,\n    fontStyle: null,\n    fontVariant: null,\n    fontWeight: null,\n    format: null,\n    fr: null,\n    from: null,\n    fx: null,\n    fy: null,\n    g1: commaSeparated,\n    g2: commaSeparated,\n    glyphName: commaSeparated,\n    glyphOrientationHorizontal: null,\n    glyphOrientationVertical: null,\n    glyphRef: null,\n    gradientTransform: null,\n    gradientUnits: null,\n    handler: null,\n    hanging: number,\n    hatchContentUnits: null,\n    hatchUnits: null,\n    height: null,\n    href: null,\n    hrefLang: null,\n    horizAdvX: number,\n    horizOriginX: number,\n    horizOriginY: number,\n    id: null,\n    ideographic: number,\n    imageRendering: null,\n    initialVisibility: null,\n    in: null,\n    in2: null,\n    intercept: number,\n    k: number,\n    k1: number,\n    k2: number,\n    k3: number,\n    k4: number,\n    kernelMatrix: commaOrSpaceSeparated,\n    kernelUnitLength: null,\n    keyPoints: null, // SEMI_COLON_SEPARATED\n    keySplines: null, // SEMI_COLON_SEPARATED\n    keyTimes: null, // SEMI_COLON_SEPARATED\n    kerning: null,\n    lang: null,\n    lengthAdjust: null,\n    letterSpacing: null,\n    lightingColor: null,\n    limitingConeAngle: number,\n    local: null,\n    markerEnd: null,\n    markerMid: null,\n    markerStart: null,\n    markerHeight: null,\n    markerUnits: null,\n    markerWidth: null,\n    mask: null,\n    maskContentUnits: null,\n    maskUnits: null,\n    mathematical: null,\n    max: null,\n    media: null,\n    mediaCharacterEncoding: null,\n    mediaContentEncodings: null,\n    mediaSize: number,\n    mediaTime: null,\n    method: null,\n    min: null,\n    mode: null,\n    name: null,\n    navDown: null,\n    navDownLeft: null,\n    navDownRight: null,\n    navLeft: null,\n    navNext: null,\n    navPrev: null,\n    navRight: null,\n    navUp: null,\n    navUpLeft: null,\n    navUpRight: null,\n    numOctaves: null,\n    observer: null,\n    offset: null,\n    onAbort: null,\n    onActivate: null,\n    onAfterPrint: null,\n    onBeforePrint: null,\n    onBegin: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnd: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFocusIn: null,\n    onFocusOut: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onMouseWheel: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRepeat: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onShow: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onZoom: null,\n    opacity: null,\n    operator: null,\n    order: null,\n    orient: null,\n    orientation: null,\n    origin: null,\n    overflow: null,\n    overlay: null,\n    overlinePosition: number,\n    overlineThickness: number,\n    paintOrder: null,\n    panose1: null,\n    path: null,\n    pathLength: number,\n    patternContentUnits: null,\n    patternTransform: null,\n    patternUnits: null,\n    phase: null,\n    ping: spaceSeparated,\n    pitch: null,\n    playbackOrder: null,\n    pointerEvents: null,\n    points: null,\n    pointsAtX: number,\n    pointsAtY: number,\n    pointsAtZ: number,\n    preserveAlpha: null,\n    preserveAspectRatio: null,\n    primitiveUnits: null,\n    propagate: null,\n    property: commaOrSpaceSeparated,\n    r: null,\n    radius: null,\n    referrerPolicy: null,\n    refX: null,\n    refY: null,\n    rel: commaOrSpaceSeparated,\n    rev: commaOrSpaceSeparated,\n    renderingIntent: null,\n    repeatCount: null,\n    repeatDur: null,\n    requiredExtensions: commaOrSpaceSeparated,\n    requiredFeatures: commaOrSpaceSeparated,\n    requiredFonts: commaOrSpaceSeparated,\n    requiredFormats: commaOrSpaceSeparated,\n    resource: null,\n    restart: null,\n    result: null,\n    rotate: null,\n    rx: null,\n    ry: null,\n    scale: null,\n    seed: null,\n    shapeRendering: null,\n    side: null,\n    slope: null,\n    snapshotTime: null,\n    specularConstant: number,\n    specularExponent: number,\n    spreadMethod: null,\n    spacing: null,\n    startOffset: null,\n    stdDeviation: null,\n    stemh: null,\n    stemv: null,\n    stitchTiles: null,\n    stopColor: null,\n    stopOpacity: null,\n    strikethroughPosition: number,\n    strikethroughThickness: number,\n    string: null,\n    stroke: null,\n    strokeDashArray: commaOrSpaceSeparated,\n    strokeDashOffset: null,\n    strokeLineCap: null,\n    strokeLineJoin: null,\n    strokeMiterLimit: number,\n    strokeOpacity: number,\n    strokeWidth: null,\n    style: null,\n    surfaceScale: number,\n    syncBehavior: null,\n    syncBehaviorDefault: null,\n    syncMaster: null,\n    syncTolerance: null,\n    syncToleranceDefault: null,\n    systemLanguage: commaOrSpaceSeparated,\n    tabIndex: number,\n    tableValues: null,\n    target: null,\n    targetX: number,\n    targetY: number,\n    textAnchor: null,\n    textDecoration: null,\n    textRendering: null,\n    textLength: null,\n    timelineBegin: null,\n    title: null,\n    transformBehavior: null,\n    type: null,\n    typeOf: commaOrSpaceSeparated,\n    to: null,\n    transform: null,\n    u1: null,\n    u2: null,\n    underlinePosition: number,\n    underlineThickness: number,\n    unicode: null,\n    unicodeBidi: null,\n    unicodeRange: null,\n    unitsPerEm: number,\n    values: null,\n    vAlphabetic: number,\n    vMathematical: number,\n    vectorEffect: null,\n    vHanging: number,\n    vIdeographic: number,\n    version: null,\n    vertAdvY: number,\n    vertOriginX: number,\n    vertOriginY: number,\n    viewBox: null,\n    viewTarget: null,\n    visibility: null,\n    width: null,\n    widths: null,\n    wordSpacing: null,\n    writingMode: null,\n    x: null,\n    x1: null,\n    x2: null,\n    xChannelSelector: null,\n    xHeight: number,\n    y: null,\n    y1: null,\n    y2: null,\n    yChannelSelector: null,\n    z: null,\n    zoomAndPan: null\n  }\n})\n","/**\n * @typedef {import('./util/schema.js').Schema} Schema\n */\n\nimport {normalize} from './normalize.js'\nimport {DefinedInfo} from './util/defined-info.js'\nimport {Info} from './util/info.js'\n\nconst valid = /^data[-\\w.:]+$/i\nconst dash = /-[a-z]/g\nconst cap = /[A-Z]/g\n\n/**\n * @param {Schema} schema\n * @param {string} value\n * @returns {Info}\n */\nexport function find(schema, value) {\n  const normal = normalize(value)\n  let prop = value\n  let Type = Info\n\n  if (normal in schema.normal) {\n    return schema.property[schema.normal[normal]]\n  }\n\n  if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid.test(value)) {\n    // Attribute or property.\n    if (value.charAt(4) === '-') {\n      // Turn it into a property.\n      const rest = value.slice(5).replace(dash, camelcase)\n      prop = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1)\n    } else {\n      // Turn it into an attribute.\n      const rest = value.slice(4)\n\n      if (!dash.test(rest)) {\n        let dashes = rest.replace(cap, kebab)\n\n        if (dashes.charAt(0) !== '-') {\n          dashes = '-' + dashes\n        }\n\n        value = 'data' + dashes\n      }\n    }\n\n    Type = DefinedInfo\n  }\n\n  return new Type(prop, value)\n}\n\n/**\n * @param {string} $0\n * @returns {string}\n */\nfunction kebab($0) {\n  return '-' + $0.toLowerCase()\n}\n\n/**\n * @param {string} $0\n * @returns {string}\n */\nfunction camelcase($0) {\n  return $0.charAt(1).toUpperCase()\n}\n","/**\n * `hast` is close to `React`, but differs in a couple of cases.\n *\n * To get a React property from a hast property, check if it is in\n * `hastToReact`, if it is, then use the corresponding value,\n * otherwise, use the hast property.\n *\n * @type {Record<string, string>}\n */\nexport const hastToReact = {\n  classId: 'classID',\n  dataType: 'datatype',\n  itemId: 'itemID',\n  strokeDashArray: 'strokeDasharray',\n  strokeDashOffset: 'strokeDashoffset',\n  strokeLineCap: 'strokeLinecap',\n  strokeLineJoin: 'strokeLinejoin',\n  strokeMiterLimit: 'strokeMiterlimit',\n  typeOf: 'typeof',\n  xLinkActuate: 'xlinkActuate',\n  xLinkArcRole: 'xlinkArcrole',\n  xLinkHref: 'xlinkHref',\n  xLinkRole: 'xlinkRole',\n  xLinkShow: 'xlinkShow',\n  xLinkTitle: 'xlinkTitle',\n  xLinkType: 'xlinkType',\n  xmlnsXLink: 'xmlnsXlink'\n}\n","import {visit} from 'unist-util-visit'\n\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n *\n * @callback AllowElement\n * @param {Element} element\n * @param {number} index\n * @param {Element|Root} parent\n * @returns {boolean|undefined}\n *\n * @typedef Options\n * @property {Array<string>} [allowedElements]\n * @property {Array<string>} [disallowedElements=[]]\n * @property {AllowElement} [allowElement]\n * @property {boolean} [unwrapDisallowed=false]\n */\n\n/**\n * @type {import('unified').Plugin<[Options], Root>}\n */\nexport default function rehypeFilter(options) {\n  if (options.allowedElements && options.disallowedElements) {\n    throw new TypeError(\n      'Only one of `allowedElements` and `disallowedElements` should be defined'\n    )\n  }\n\n  if (\n    options.allowedElements ||\n    options.disallowedElements ||\n    options.allowElement\n  ) {\n    return (tree) => {\n      visit(tree, 'element', (node, index, parent_) => {\n        const parent = /** @type {Element|Root} */ (parent_)\n        /** @type {boolean|undefined} */\n        let remove\n\n        if (options.allowedElements) {\n          remove = !options.allowedElements.includes(node.tagName)\n        } else if (options.disallowedElements) {\n          remove = options.disallowedElements.includes(node.tagName)\n        }\n\n        if (!remove && options.allowElement && typeof index === 'number') {\n          remove = !options.allowElement(node, index, parent)\n        }\n\n        if (remove && typeof index === 'number') {\n          if (options.unwrapDisallowed && node.children) {\n            parent.children.splice(index, 1, ...node.children)\n          } else {\n            parent.children.splice(index, 1)\n          }\n\n          return index\n        }\n\n        return undefined\n      })\n    }\n  }\n}\n","/**\n * @template T\n * @typedef {import('react').ComponentType<T>} ComponentType<T>\n */\n\n/**\n * @template T\n * @typedef {import('react').ComponentPropsWithoutRef<T>} ComponentPropsWithoutRef<T>\n */\n\n/**\n * @typedef {import('react').ReactNode} ReactNode\n * @typedef {import('unist').Position} Position\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('./complex-types.js').ReactMarkdownProps} ReactMarkdownProps\n *\n * @typedef Raw\n * @property {'raw'} type\n * @property {string} value\n *\n * @typedef Context\n * @property {Options} options\n * @property {Schema} schema\n * @property {number} listDepth\n *\n * @callback TransformLink\n * @param {string} href\n * @param {Array<ElementContent>} children\n * @param {string?} title\n * @returns {string}\n *\n * @callback TransformImage\n * @param {string} src\n * @param {string} alt\n * @param {string?} title\n * @returns {string}\n *\n * @typedef {import('react').HTMLAttributeAnchorTarget} TransformLinkTargetType\n *\n * @callback TransformLinkTarget\n * @param {string} href\n * @param {Array<ElementContent>} children\n * @param {string?} title\n * @returns {TransformLinkTargetType|undefined}\n *\n * @typedef {keyof JSX.IntrinsicElements} ReactMarkdownNames\n *\n * To do: is `data-sourcepos` typeable?\n *\n * @typedef {ComponentPropsWithoutRef<'code'> & ReactMarkdownProps & {inline?: boolean}} CodeProps\n * @typedef {ComponentPropsWithoutRef<'h1'> & ReactMarkdownProps & {level: number}} HeadingProps\n * @typedef {ComponentPropsWithoutRef<'li'> & ReactMarkdownProps & {checked: boolean|null, index: number, ordered: boolean}} LiProps\n * @typedef {ComponentPropsWithoutRef<'ol'> & ReactMarkdownProps & {depth: number, ordered: true}} OrderedListProps\n * @typedef {ComponentPropsWithoutRef<'td'> & ReactMarkdownProps & {style?: Record<string, unknown>, isHeader: false}} TableDataCellProps\n * @typedef {ComponentPropsWithoutRef<'th'> & ReactMarkdownProps & {style?: Record<string, unknown>, isHeader: true}} TableHeaderCellProps\n * @typedef {ComponentPropsWithoutRef<'tr'> & ReactMarkdownProps & {isHeader: boolean}} TableRowProps\n * @typedef {ComponentPropsWithoutRef<'ul'> & ReactMarkdownProps & {depth: number, ordered: false}} UnorderedListProps\n *\n * @typedef {ComponentType<CodeProps>} CodeComponent\n * @typedef {ComponentType<HeadingProps>} HeadingComponent\n * @typedef {ComponentType<LiProps>} LiComponent\n * @typedef {ComponentType<OrderedListProps>} OrderedListComponent\n * @typedef {ComponentType<TableDataCellProps>} TableDataCellComponent\n * @typedef {ComponentType<TableHeaderCellProps>} TableHeaderCellComponent\n * @typedef {ComponentType<TableRowProps>} TableRowComponent\n * @typedef {ComponentType<UnorderedListProps>} UnorderedListComponent\n *\n * @typedef SpecialComponents\n * @property {CodeComponent|ReactMarkdownNames} code\n * @property {HeadingComponent|ReactMarkdownNames} h1\n * @property {HeadingComponent|ReactMarkdownNames} h2\n * @property {HeadingComponent|ReactMarkdownNames} h3\n * @property {HeadingComponent|ReactMarkdownNames} h4\n * @property {HeadingComponent|ReactMarkdownNames} h5\n * @property {HeadingComponent|ReactMarkdownNames} h6\n * @property {LiComponent|ReactMarkdownNames} li\n * @property {OrderedListComponent|ReactMarkdownNames} ol\n * @property {TableDataCellComponent|ReactMarkdownNames} td\n * @property {TableHeaderCellComponent|ReactMarkdownNames} th\n * @property {TableRowComponent|ReactMarkdownNames} tr\n * @property {UnorderedListComponent|ReactMarkdownNames} ul\n *\n * @typedef {Partial<Omit<import('./complex-types.js').NormalComponents, keyof SpecialComponents> & SpecialComponents>} Components\n *\n * @typedef Options\n * @property {boolean} [sourcePos=false]\n * @property {boolean} [rawSourcePos=false]\n * @property {boolean} [skipHtml=false]\n * @property {boolean} [includeElementIndex=false]\n * @property {null|false|TransformLink} [transformLinkUri]\n * @property {TransformImage} [transformImageUri]\n * @property {TransformLinkTargetType|TransformLinkTarget} [linkTarget]\n * @property {Components} [components]\n */\n\nimport React from 'react'\nimport ReactIs from 'react-is'\nimport {whitespace} from 'hast-util-whitespace'\nimport {svg, find, hastToReact} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {stringify as commas} from 'comma-separated-tokens'\nimport style from 'style-to-object'\nimport {uriTransformer} from './uri-transformer.js'\n\nconst own = {}.hasOwnProperty\n\n// The table-related elements that must not contain whitespace text according\n// to React.\nconst tableElements = new Set(['table', 'thead', 'tbody', 'tfoot', 'tr'])\n\n/**\n * @param {Context} context\n * @param {Element|Root} node\n */\nexport function childrenToReact(context, node) {\n  /** @type {Array<ReactNode>} */\n  const children = []\n  let childIndex = -1\n  /** @type {Comment|Doctype|Element|Raw|Text} */\n  let child\n\n  while (++childIndex < node.children.length) {\n    child = node.children[childIndex]\n\n    if (child.type === 'element') {\n      children.push(toReact(context, child, childIndex, node))\n    } else if (child.type === 'text') {\n      // Currently, a warning is triggered by react for *any* white space in\n      // tables.\n      // So we drop it.\n      // See: <https://github.com/facebook/react/pull/7081>.\n      // See: <https://github.com/facebook/react/pull/7515>.\n      // See: <https://github.com/remarkjs/remark-react/issues/64>.\n      // See: <https://github.com/remarkjs/react-markdown/issues/576>.\n      if (\n        node.type !== 'element' ||\n        !tableElements.has(node.tagName) ||\n        !whitespace(child)\n      ) {\n        children.push(child.value)\n      }\n    } else if (child.type === 'raw' && !context.options.skipHtml) {\n      // Default behavior is to show (encoded) HTML.\n      children.push(child.value)\n    }\n  }\n\n  return children\n}\n\n/**\n * @param {Context} context\n * @param {Element} node\n * @param {number} index\n * @param {Element|Root} parent\n */\nfunction toReact(context, node, index, parent) {\n  const options = context.options\n  const transform =\n    options.transformLinkUri === undefined\n      ? uriTransformer\n      : options.transformLinkUri\n  const parentSchema = context.schema\n  /** @type {ReactMarkdownNames} */\n  // @ts-expect-error assume a known HTML/SVG element.\n  const name = node.tagName\n  /** @type {Record<string, unknown>} */\n  const properties = {}\n  let schema = parentSchema\n  /** @type {string} */\n  let property\n\n  if (parentSchema.space === 'html' && name === 'svg') {\n    schema = svg\n    context.schema = schema\n  }\n\n  if (node.properties) {\n    for (property in node.properties) {\n      if (own.call(node.properties, property)) {\n        addProperty(properties, property, node.properties[property], context)\n      }\n    }\n  }\n\n  if (name === 'ol' || name === 'ul') {\n    context.listDepth++\n  }\n\n  const children = childrenToReact(context, node)\n\n  if (name === 'ol' || name === 'ul') {\n    context.listDepth--\n  }\n\n  // Restore parent schema.\n  context.schema = parentSchema\n\n  // Nodes created by plugins do not have positional info, in which case we use\n  // an object that matches the position interface.\n  const position = node.position || {\n    start: {line: null, column: null, offset: null},\n    end: {line: null, column: null, offset: null}\n  }\n  const component =\n    options.components && own.call(options.components, name)\n      ? options.components[name]\n      : name\n  const basic = typeof component === 'string' || component === React.Fragment\n\n  if (!ReactIs.isValidElementType(component)) {\n    throw new TypeError(\n      `Component for name \\`${name}\\` not defined or is not renderable`\n    )\n  }\n\n  properties.key = [\n    name,\n    position.start.line,\n    position.start.column,\n    index\n  ].join('-')\n\n  if (name === 'a' && options.linkTarget) {\n    properties.target =\n      typeof options.linkTarget === 'function'\n        ? options.linkTarget(\n            String(properties.href || ''),\n            node.children,\n            typeof properties.title === 'string' ? properties.title : null\n          )\n        : options.linkTarget\n  }\n\n  if (name === 'a' && transform) {\n    properties.href = transform(\n      String(properties.href || ''),\n      node.children,\n      typeof properties.title === 'string' ? properties.title : null\n    )\n  }\n\n  if (\n    !basic &&\n    name === 'code' &&\n    parent.type === 'element' &&\n    parent.tagName !== 'pre'\n  ) {\n    properties.inline = true\n  }\n\n  if (\n    !basic &&\n    (name === 'h1' ||\n      name === 'h2' ||\n      name === 'h3' ||\n      name === 'h4' ||\n      name === 'h5' ||\n      name === 'h6')\n  ) {\n    properties.level = Number.parseInt(name.charAt(1), 10)\n  }\n\n  if (name === 'img' && options.transformImageUri) {\n    properties.src = options.transformImageUri(\n      String(properties.src || ''),\n      String(properties.alt || ''),\n      typeof properties.title === 'string' ? properties.title : null\n    )\n  }\n\n  if (!basic && name === 'li' && parent.type === 'element') {\n    const input = getInputElement(node)\n    properties.checked =\n      input && input.properties ? Boolean(input.properties.checked) : null\n    properties.index = getElementsBeforeCount(parent, node)\n    properties.ordered = parent.tagName === 'ol'\n  }\n\n  if (!basic && (name === 'ol' || name === 'ul')) {\n    properties.ordered = name === 'ol'\n    properties.depth = context.listDepth\n  }\n\n  if (name === 'td' || name === 'th') {\n    if (properties.align) {\n      if (!properties.style) properties.style = {}\n      // @ts-expect-error assume `style` is an object\n      properties.style.textAlign = properties.align\n      delete properties.align\n    }\n\n    if (!basic) {\n      properties.isHeader = name === 'th'\n    }\n  }\n\n  if (!basic && name === 'tr' && parent.type === 'element') {\n    properties.isHeader = Boolean(parent.tagName === 'thead')\n  }\n\n  // If `sourcePos` is given, pass source information (line/column info from markdown source).\n  if (options.sourcePos) {\n    properties['data-sourcepos'] = flattenPosition(position)\n  }\n\n  if (!basic && options.rawSourcePos) {\n    properties.sourcePosition = node.position\n  }\n\n  // If `includeElementIndex` is given, pass node index info to components.\n  if (!basic && options.includeElementIndex) {\n    properties.index = getElementsBeforeCount(parent, node)\n    properties.siblingCount = getElementsBeforeCount(parent)\n  }\n\n  if (!basic) {\n    properties.node = node\n  }\n\n  // Ensure no React warnings are emitted for void elements w/ children.\n  return children.length > 0\n    ? React.createElement(component, properties, children)\n    : React.createElement(component, properties)\n}\n\n/**\n * @param {Element|Root} node\n * @returns {Element?}\n */\nfunction getInputElement(node) {\n  let index = -1\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if (child.type === 'element' && child.tagName === 'input') {\n      return child\n    }\n  }\n\n  return null\n}\n\n/**\n * @param {Element|Root} parent\n * @param {Element} [node]\n * @returns {number}\n */\nfunction getElementsBeforeCount(parent, node) {\n  let index = -1\n  let count = 0\n\n  while (++index < parent.children.length) {\n    if (parent.children[index] === node) break\n    if (parent.children[index].type === 'element') count++\n  }\n\n  return count\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string} prop\n * @param {unknown} value\n * @param {Context} ctx\n */\nfunction addProperty(props, prop, value, ctx) {\n  const info = find(ctx.schema, prop)\n  let result = value\n\n  // Ignore nullish and `NaN` values.\n  // eslint-disable-next-line no-self-compare\n  if (result === null || result === undefined || result !== result) {\n    return\n  }\n\n  // Accept `array`.\n  // Most props are space-separated.\n  if (Array.isArray(result)) {\n    result = info.commaSeparated ? commas(result) : spaces(result)\n  }\n\n  if (info.property === 'style' && typeof result === 'string') {\n    result = parseStyle(result)\n  }\n\n  if (info.space && info.property) {\n    props[\n      own.call(hastToReact, info.property)\n        ? hastToReact[info.property]\n        : info.property\n    ] = result\n  } else if (info.attribute) {\n    props[info.attribute] = result\n  }\n}\n\n/**\n * @param {string} value\n * @returns {Record<string, string>}\n */\nfunction parseStyle(value) {\n  /** @type {Record<string, string>} */\n  const result = {}\n\n  try {\n    style(value, iterator)\n  } catch {\n    // Silent.\n  }\n\n  return result\n\n  /**\n   * @param {string} name\n   * @param {string} v\n   */\n  function iterator(name, v) {\n    const k = name.slice(0, 4) === '-ms-' ? `ms-${name.slice(4)}` : name\n    result[k.replace(/-([a-z])/g, styleReplacer)] = v\n  }\n}\n\n/**\n * @param {unknown} _\n * @param {string} $1\n */\nfunction styleReplacer(_, $1) {\n  return $1.toUpperCase()\n}\n\n/**\n * @param {Position|{start: {line: null, column: null, offset: null}, end: {line: null, column: null, offset: null}}} pos\n * @returns {string}\n */\nfunction flattenPosition(pos) {\n  return [\n    pos.start.line,\n    ':',\n    pos.start.column,\n    '-',\n    pos.end.line,\n    ':',\n    pos.end.column\n  ]\n    .map(String)\n    .join('')\n}\n","/**\n * Check if the given value is *inter-element whitespace*.\n *\n * @param {unknown} thing\n *   Thing to check (typically `Node` or `string`).\n * @returns {boolean}\n *   Whether the `value` is inter-element whitespace (`boolean`): consisting of\n *   zero or more of space, tab (`\\t`), line feed (`\\n`), carriage return\n *   (`\\r`), or form feed (`\\f`).\n *   If a node is passed it must be a `Text` node, whose `value` field is\n *   checked.\n */\nexport function whitespace(thing) {\n  /** @type {string} */\n  const value =\n    // @ts-expect-error looks like a node.\n    thing && typeof thing === 'object' && thing.type === 'text'\n      ? // @ts-expect-error looks like a text.\n        thing.value || ''\n      : thing\n\n  // HTML whitespace expression.\n  // See <https://infra.spec.whatwg.org/#ascii-whitespace>.\n  return typeof value === 'string' && value.replace(/[ \\t\\n\\f\\r]/g, '') === ''\n}\n","/**\n * Parse space-separated tokens to an array of strings.\n *\n * @param {string} value\n *   Space-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nexport function parse(value) {\n  const input = String(value || '').trim()\n  return input ? input.split(/[ \\t\\n\\r\\f]+/g) : []\n}\n\n/**\n * Serialize an array of strings as space separated-tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @returns {string}\n *   Space-separated tokens.\n */\nexport function stringify(values) {\n  return values.join(' ').trim()\n}\n","/**\n * @typedef Options\n *   Configuration for `stringify`.\n * @property {boolean} [padLeft=true]\n *   Whether to pad a space before a token.\n * @property {boolean} [padRight=false]\n *   Whether to pad a space after a token.\n */\n\n/**\n * @typedef {Options} StringifyOptions\n *   Please use `StringifyOptions` instead.\n */\n\n/**\n * Parse comma-separated tokens to an array.\n *\n * @param {string} value\n *   Comma-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nexport function parse(value) {\n  /** @type {Array<string>} */\n  const tokens = []\n  const input = String(value || '')\n  let index = input.indexOf(',')\n  let start = 0\n  /** @type {boolean} */\n  let end = false\n\n  while (!end) {\n    if (index === -1) {\n      index = input.length\n      end = true\n    }\n\n    const token = input.slice(start, index).trim()\n\n    if (token || !end) {\n      tokens.push(token)\n    }\n\n    start = index + 1\n    index = input.indexOf(',', start)\n  }\n\n  return tokens\n}\n\n/**\n * Serialize an array of strings or numbers to comma-separated tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @param {Options} [options]\n *   Configuration for `stringify` (optional).\n * @returns {string}\n *   Comma-separated tokens.\n */\nexport function stringify(values, options) {\n  const settings = options || {}\n\n  // Ensure the last empty entry is seen.\n  const input = values[values.length - 1] === '' ? [...values, ''] : values\n\n  return input\n    .join(\n      (settings.padRight ? ' ' : '') +\n        ',' +\n        (settings.padLeft === false ? '' : ' ')\n    )\n    .trim()\n}\n","import StyleToObject from './index.js';\n\nexport default StyleToObject;\n","var parse = require('inline-style-parser');\n\n/**\n * Parses inline style to object.\n *\n * @example\n * // returns { 'line-height': '42' }\n * StyleToObject('line-height: 42;');\n *\n * @param  {String}      style      - The inline style.\n * @param  {Function}    [iterator] - The iterator function.\n * @return {null|Object}\n */\nfunction StyleToObject(style, iterator) {\n  var output = null;\n  if (!style || typeof style !== 'string') {\n    return output;\n  }\n\n  var declaration;\n  var declarations = parse(style);\n  var hasIterator = typeof iterator === 'function';\n  var property;\n  var value;\n\n  for (var i = 0, len = declarations.length; i < len; i++) {\n    declaration = declarations[i];\n    property = declaration.property;\n    value = declaration.value;\n\n    if (hasIterator) {\n      iterator(property, value, declaration);\n    } else if (value) {\n      output || (output = {});\n      output[property] = value;\n    }\n  }\n\n  return output;\n}\n\nmodule.exports = StyleToObject;\nmodule.exports.default = StyleToObject; // ESM support\n","// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nvar COMMENT_REGEX = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nvar NEWLINE_REGEX = /\\n/g;\nvar WHITESPACE_REGEX = /^\\s*/;\n\n// declaration\nvar PROPERTY_REGEX = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/;\nvar COLON_REGEX = /^:\\s*/;\nvar VALUE_REGEX = /^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};])+)/;\nvar SEMICOLON_REGEX = /^[;\\s]*/;\n\n// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\nvar TRIM_REGEX = /^\\s+|\\s+$/g;\n\n// strings\nvar NEWLINE = '\\n';\nvar FORWARD_SLASH = '/';\nvar ASTERISK = '*';\nvar EMPTY_STRING = '';\n\n// types\nvar TYPE_COMMENT = 'comment';\nvar TYPE_DECLARATION = 'declaration';\n\n/**\n * @param {String} style\n * @param {Object} [options]\n * @return {Object[]}\n * @throws {TypeError}\n * @throws {Error}\n */\nmodule.exports = function(style, options) {\n  if (typeof style !== 'string') {\n    throw new TypeError('First argument must be a string');\n  }\n\n  if (!style) return [];\n\n  options = options || {};\n\n  /**\n   * Positional.\n   */\n  var lineno = 1;\n  var column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   *\n   * @param {String} str\n   */\n  function updatePosition(str) {\n    var lines = str.match(NEWLINE_REGEX);\n    if (lines) lineno += lines.length;\n    var i = str.lastIndexOf(NEWLINE);\n    column = ~i ? str.length - i : column + str.length;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   *\n   * @return {Function}\n   */\n  function position() {\n    var start = { line: lineno, column: column };\n    return function(node) {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node.\n   *\n   * @constructor\n   * @property {Object} start\n   * @property {Object} end\n   * @property {undefined|String} source\n   */\n  function Position(start) {\n    this.start = start;\n    this.end = { line: lineno, column: column };\n    this.source = options.source;\n  }\n\n  /**\n   * Non-enumerable source string.\n   */\n  Position.prototype.content = style;\n\n  var errorsList = [];\n\n  /**\n   * Error `msg`.\n   *\n   * @param {String} msg\n   * @throws {Error}\n   */\n  function error(msg) {\n    var err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = style;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Match `re` and return captures.\n   *\n   * @param {RegExp} re\n   * @return {undefined|Array}\n   */\n  function match(re) {\n    var m = re.exec(style);\n    if (!m) return;\n    var str = m[0];\n    updatePosition(str);\n    style = style.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n  function whitespace() {\n    match(WHITESPACE_REGEX);\n  }\n\n  /**\n   * Parse comments.\n   *\n   * @param {Object[]} [rules]\n   * @return {Object[]}\n   */\n  function comments(rules) {\n    var c;\n    rules = rules || [];\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function comment() {\n    var pos = position();\n    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;\n\n    var i = 2;\n    while (\n      EMPTY_STRING != style.charAt(i) &&\n      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if (EMPTY_STRING === style.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    var str = style.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    style = style.slice(i);\n    column += 2;\n\n    return pos({\n      type: TYPE_COMMENT,\n      comment: str\n    });\n  }\n\n  /**\n   * Parse declaration.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function declaration() {\n    var pos = position();\n\n    // prop\n    var prop = match(PROPERTY_REGEX);\n    if (!prop) return;\n    comment();\n\n    // :\n    if (!match(COLON_REGEX)) return error(\"property missing ':'\");\n\n    // val\n    var val = match(VALUE_REGEX);\n\n    var ret = pos({\n      type: TYPE_DECLARATION,\n      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),\n      value: val\n        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))\n        : EMPTY_STRING\n    });\n\n    // ;\n    match(SEMICOLON_REGEX);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   *\n   * @return {Object[]}\n   */\n  function declarations() {\n    var decls = [];\n\n    comments(decls);\n\n    // declarations\n    var decl;\n    while ((decl = declaration())) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n    }\n\n    return decls;\n  }\n\n  whitespace();\n  return declarations();\n};\n\n/**\n * Trim `str`.\n *\n * @param {String} str\n * @return {String}\n */\nfunction trim(str) {\n  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;\n}\n","const protocols = ['http', 'https', 'mailto', 'tel']\n\n/**\n * @param {string} uri\n * @returns {string}\n */\nexport function uriTransformer(uri) {\n  const url = (uri || '').trim()\n  const first = url.charAt(0)\n\n  if (first === '#' || first === '/') {\n    return url\n  }\n\n  const colon = url.indexOf(':')\n  if (colon === -1) {\n    return url\n  }\n\n  let index = -1\n\n  while (++index < protocols.length) {\n    const protocol = protocols[index]\n\n    if (\n      colon === protocol.length &&\n      url.slice(0, protocol.length).toLowerCase() === protocol\n    ) {\n      return url\n    }\n  }\n\n  index = url.indexOf('?')\n  if (index !== -1 && colon > index) {\n    return url\n  }\n\n  index = url.indexOf('#')\n  if (index !== -1 && colon > index) {\n    return url\n  }\n\n  // eslint-disable-next-line no-script-url\n  return 'javascript:void(0)'\n}\n","@use \"../../shared.scss\" as *;\n@use \"../../themed.scss\" as *;\n\n.posts_content {\n  @include text_spacing();\n\n  a {\n    @include interactive_secondary();\n    line-height: 1.5rem;\n  }\n}\n\n.posts_content_code {\n  @include card();\n  @include text_spacing();\n}\n"],"names":["$parcel$interopDefault","a","__esModule","default","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","self","window","global","register","module","exports","value","$5b827356140ac14a$export$2e2bcd8739ae039","$eiFRM","$hvI8U","$g4uyC","$hTxeE","$ee91V","$la7Ay","$cqg0o","$5gZKO","$b6AxM","id","useParams","content","data","title","date","theme","useAppSelector","state","jsxs","children","jsx","Card","primary","secondary","Date","toDateString","ReactMarkdown","className","posts_content","components","code","inline","props","match","exec","SyntaxHighlighter","posts_content_code","String","replace","language","style","Theme","DARKMODE","styleDark","styleLight","$bb34b91bb72ef434$export$83ef7ab426386201","$3TwHq","$8EANy","$27vyP","$73kRC","$kJTlh","$4RND8","$aY292","$1p9m5","$hM85M","$bb34b91bb72ef434$var$own","hasOwnProperty","$bb34b91bb72ef434$var$deprecated","plugins","to","renderers","astPlugins","allowDangerousHtml","escapeHtml","source","allowNode","allowedTypes","disallowedTypes","includeNodeIndex","options","key","call","deprecation","console","warn","processor","unified","use","remarkPlugins","remarkRehypeOptions","rehypePlugins","file","VFile","undefined","hastNode","runSync","parse","type","TypeError","result","createElement","Fragment","childrenToReact","schema","html","listDepth","propTypes","string","allowElement","func","allowedElements","arrayOf","disallowedElements","unwrapDisallowed","bool","oneOfType","object","any","sourcePos","rawSourcePos","skipHtml","includeElementIndex","transformLinkUri","linkTarget","transformImageUri","$64ce9a830b94da6b$export$93dff69eb10dc7ce","$1Tv42","$c9gcl","$acHbX","$cz21B","$jfDid","$guBlg","$64ce9a830b94da6b$var$order","constructor","prop","isUrl","path","messages","history","cwd","proc","stored","map","index","length","includes","urlToPath","$64ce9a830b94da6b$var$assertNonEmpty","push","dirname","$64ce9a830b94da6b$var$assertPath","basename","join","$64ce9a830b94da6b$var$assertPart","extname","charCodeAt","Error","stem","toString","encoding","message","reason","place","origin","VFileMessage","name","fatal","info","fail","part","sep","obj","isBuffer","$8d82e3e29a1417e2$export$752e5c445fe834ef","$gHjNW","parts","position","start","line","column","end","indexOf","slice","stringifyPosition","stack","ruleId","actual","expected","url","note","prototype","$c2800647e46698b3$export$c304dd45fe166145","$c2800647e46698b3$var$position","$c2800647e46698b3$var$point","point","$c2800647e46698b3$var$index","pos","$76dc8763f1906fc2$export$bb654e07daaf8c3a","ext","seenNonSlash","$76dc8763f1906fc2$var$assertPath","firstNonSlashEnd","extIndex","unmatchedSlash","startPart","startDot","preDotState","segments","joined","$76dc8763f1906fc2$var$normalize","absolute","$76dc8763f1906fc2$var$normalizeString","allowAboveRoot","lastSlashIndex","lastSegmentLength","lastSlash","dots","lastIndexOf","JSON","stringify","$925a52fec1b90daa$export$97a5aaf482767187","$c01c6a0463602ee5$export$9b2b676c902de799","URL","error","protocol","$c01c6a0463602ee5$var$getPathFromURLPosix","hostname","pathname","third","decodeURIComponent","$e03de5c8a9f67c93$export$8304a22d431f958","fileUrlOrPath","href","$18b4b78c0087b74e$export$7cc1b2fe10c52bb","$dEvVi","$eWaCG","$4ld8y","$gpg7e","$18b4b78c0087b74e$var$base","frozen","transformers","trough","attachers","namespace","freezeIndex","arguments","$18b4b78c0087b74e$var$assertUnfrozen","$18b4b78c0087b74e$var$own","Parser","Compiler","freeze","attacher","transformer","Number","POSITIVE_INFINITY","settings","addPlugin","Array","isArray","addList","addPreset","assign","thing","add","plugin","entry","doc","$18b4b78c0087b74e$var$vfile","$18b4b78c0087b74e$var$assertParser","$18b4b78c0087b74e$var$newable","node","$18b4b78c0087b74e$var$assertCompiler","$18b4b78c0087b74e$var$assertNode","compile","run","callback","Promise","executor","resolve","reject","tree","complete","bail","$18b4b78c0087b74e$var$assertDone","process","done","processSync","destination","$18b4b78c0087b74e$var$keys","asyncName","$18b4b78c0087b74e$var$looksLikeAVFile","$9f07c614b2a686d3$export$dd911e13ecb11e05","$adfeb8f4e98e800c$var$hasOwn","$adfeb8f4e98e800c$var$toStr","$adfeb8f4e98e800c$var$defineProperty","$adfeb8f4e98e800c$var$gOPD","getOwnPropertyDescriptor","$adfeb8f4e98e800c$var$isArray","arr","$adfeb8f4e98e800c$var$isPlainObject","hasOwnConstructor","hasIsPrototypeOf","$adfeb8f4e98e800c$var$setProperty","target","newValue","writable","$adfeb8f4e98e800c$var$getProperty","extend","src","copy","copyIsArray","clone","i","deep","$329350557b958064$export$2e2bcd8739ae039","getPrototypeOf","Symbol","toStringTag","iterator","$bf1b7b5cf378e900$export$91b56f5ca106aa43","fns","pipeline","values","middlewareIndex","pop","next","output","fn","$bf1b7b5cf378e900$export$4997ffc0176396a6","middleware","called","parameters","fnExpectsCallback","apply","then","middelware","$5228ff543a462260$export$2e2bcd8739ae039","$dMaXS","$a07843732b3ecc17$export$2e2bcd8739ae039","$1YdnK","fromMarkdown","extensions","mdastExtensions","$16f5c6747a84503c$export$d744d789c09bfde6","$2lcqI","$cTtHt","$lw7ce","$3gGaD","$gZtaX","$8OH7a","$3ac70","$3HEPL","$16f5c6747a84503c$var$own","$16f5c6747a84503c$var$compiler","config","transforms","canContainEols","enter","autolink","opener","link","autolinkProtocol","onenterdata","autolinkEmail","atxHeading","heading","blockQuote","characterEscape","characterReference","codeFenced","codeFlow","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","codeText","codeTextData","codeFlowValue","definition","identifier","label","definitionDestinationString","definitionLabelString","definitionTitleString","emphasis","hardBreakEscape","hardBreak","hardBreakTrailing","htmlFlow","htmlFlowData","htmlText","htmlTextData","image","alt","listItem","token","spread","_spread","checked","listItemValue","ancestor","parseInt","sliceSerialize","listOrdered","list","listUnordered","paragraph","reference","referenceString","resourceDestinationString","resourceTitleString","setextHeading","strong","thematicBreak","exit","closer","atxHeadingSequence","depth","onexitdata","characterEscapeValue","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","decodeNumericCharacterReference","decodeNamedCharacterReference","tail","$16f5c6747a84503c$var$point","resume","codeFencedFence","lang","meta","normalizeIdentifier","toLowerCase","onexithardbreak","referenceType","getData","fragment","labelText","decodeString","lineEnding","context","resource","setextHeadingLineSequence","setextHeadingText","$16f5c6747a84503c$var$configure","combined","$16f5c6747a84503c$var$extension","extension","right","events","tokenStack","setData","listStack","prepareList","lineIndex","firstBlankLineIndex","atMarker","containerBalance","listSpread","event","tailIndex","tailEvent","splice","handler","$16f5c6747a84503c$var$defaultOnError","offset","create","and","errorHandler","parent","onExitError","open","ordered","postprocess","document","write","preprocess","d","left","$1b472f46fc8ca74f$export$f84e8e69fd4488a5","includeImageAlt","$1b472f46fc8ca74f$var$one","$1b472f46fc8ca74f$var$node","Boolean","$1b472f46fc8ca74f$var$all","$9631a8efb162102f$export$98e6a39c04603d36","$9UGYc","$2oNzp","$lAK8r","$gxpzI","$l2tD0","$8MiTe","$6HWiY","constructs","combineExtensions","concat","parser","defined","lazy","flow","text","initial","from","createTokenizer","$737aacf765ba6d74$export$86a865d89ef3c690","$2Qp1S","$737aacf765ba6d74$var$hasOwnProperty","all","$737aacf765ba6d74$var$syntaxExtension","hook","maybe","$737aacf765ba6d74$var$constructs","existing","before","$2123da67b38b8197$export$869882364835d202","remove","items","chunkStart","unshift","$2123da67b38b8197$export$4cbf152802aa238","$1bf446438b8bfa65$export$a7db06668cad9adb","$jH5RB","$iUvtM","tokenize","effects","previous","contentStart","attempt","contentInitial","consume","factorySpace","lineStart","contentType","markdownLineEnding","$e56694df1d786fea$export$ae105c1eb063a0a2","ok","max","limit","size","markdownSpace","prefix","$dc45e01a14bb512b$export$d65d6b62c24d5436","$dc45e01a14bb512b$export$ca8b5b1a6c320e6e","$dc45e01a14bb512b$export$eca2752363989806","$dc45e01a14bb512b$export$75c76db11865a9f4","$dc45e01a14bb512b$export$35794a7d1db99380","$dc45e01a14bb512b$export$4397998b34fe597d","$dc45e01a14bb512b$export$67dbf494fc8394df","$dc45e01a14bb512b$export$a30284361b3814b7","$dc45e01a14bb512b$export$34a1dff1c0936953","$dc45e01a14bb512b$export$2c6cf65c1127992a","$dc45e01a14bb512b$export$a0ff789c034ffdf4","$dc45e01a14bb512b$export$aa04114dd888a7a0","$7No4A","$dc45e01a14bb512b$var$regexCheck","unicodePunctuationRegex","regex","test","fromCharCode","$5acfc86363294f46$export$85b5101f24802e8c","$fb80bf3aef2e1300$export$5a7bfc01df82fcd1","childFlow","childToken","lineStartOffset","continued","item","containerState","continuation","documentContinue","checkNewContainers","_closeFlow","closeFlow","indexBeforeExits","indexBeforeFlow","exitContainers","documentContinued","currentConstruct","concrete","flowStart","interrupt","_gfmTableDynamicInterruptHack","check","$fb80bf3aef2e1300$var$containerConstruct","thereIsANewContainer","thereIsNoNewContainer","now","containerContinue","_tokenizer","flowContinue","writeToChild","eof","stream","sliceStream","defineSkip","seen","nok","disable","null","$c0a39111b1e2f39f$export$ccc7b0636abaffc3","$7jf0e","$iJpmS","blankLine","flowInitial","afterConstruct","$5525f1ffc20239bb$export$d50d28ce3ab2a612","partial","$da301b88381bfdbf$export$a7db06668cad9adb","$jsYfy","contentEnd","$da301b88381bfdbf$var$continuationConstruct","contentContinue","subtokenize","prefixed","$e2bf5e361d23365c$export$12949d1dd00fddf4","otherIndex","otherEvent","subevents","more","jumps","_isInFirstContentOfListItem","$e2bf5e361d23365c$var$subcontent","eventIndex","startPosition","startPositions","tokenizer","childEvents","gaps","current","adjust","breaks","_gfmTasklistFirstContentOfListItem","_container","$f510c46d167f2895$export$50397835cbfdbc24","$f510c46d167f2895$export$22b082955e083ec3","$f510c46d167f2895$export$6f093cfa640b7166","resolveAll","$f510c46d167f2895$var$createResolver","$f510c46d167f2895$var$initializeFactory","field","notText","atBreak","$f510c46d167f2895$var$resolveAllLineSuffixes","extraResolver","tabs","chunks","bufferIndex","chunk","_index","_bufferIndex","$664175902a9bcd27$export$ae34f10ee4b29837","$km4eF","initialize","columnStart","resolveAllConstructs","accountForPotentialSkip","fields","constructFactory","construct","addResult","onsuccessfulcheck","expandTabs","$664175902a9bcd27$var$serializeChunks","atTab","main","chunkIndex","$664175902a9bcd27$var$sliceChunks","view","startIndex","startBufferIndex","endIndex","endBufferIndex","_","restore","onreturn","returnState","bogusState","listOfConstructs","constructIndex","handleListOfConstructs","def","handleConstruct","store","startPoint","startPrevious","startCurrentConstruct","startEventsIndex","startStack","resolveTo","$ed1925d082960da2$export$3ff61ec196ff408b","$4e23fc6993cb2e1b$export$5a7bfc01df82fcd1","$4e23fc6993cb2e1b$export$5a2181fb44b58173","$4e23fc6993cb2e1b$export$cf8bead395eff824","$4e23fc6993cb2e1b$export$ccc7b0636abaffc3","$4e23fc6993cb2e1b$export$22b082955e083ec3","$4e23fc6993cb2e1b$export$6f093cfa640b7166","$4e23fc6993cb2e1b$export$d44f260a3f9b69f5","$4e23fc6993cb2e1b$export$b9c0b60d74426aea","$4e23fc6993cb2e1b$export$e20fbacbb41798b","$6nTV3","$OcEpt","$gNBbl","$gEHeN","$2Qs41","$gs3o4","$aqw4N","$8zB3f","$bvMUE","$h2kyO","$kSTx0","$4vLKK","$bgjqA","$dz9VB","$8be8Q","$a9cNg","$hmr3Q","$1PP7G","$jEoWp","$5jHEg","headingAtx","setextUnderline","labelStartImage","attention","labelStartLink","labelEnd","resolver","$4a604472ee2b5b37$export$45b92471da762af7","$9oBa2","marker","attentionMarkers","classifyCharacter","sequence","after","close","_open","_close","group","openingSequence","closingSequence","nextEvents","$4a604472ee2b5b37$var$movePoint","insideSpan","$6d732e591ba9f10c$export$e3902bc0d835cad0","markdownLineEndingOrSpace","unicodeWhitespace","unicodePunctuation","$096e7bce554321fc$export$17ddf85e4c916ad6","asciiAlpha","schemeOrEmailAtext","asciiAtext","emailAtext","asciiAlphanumeric","schemeInsideOrEmailAtext","urlInside","asciiControl","emailAtSignOrDot","emailLabel","emailValue","$c3ae10810aeedc61$export$200dcd0a5903c968","$c201ebe1baa7ee0e$export$2005478564e78d96","asciiPunctuation","$212634ff078dd1a4$export$e31905600aaf3d8e","numeric","asciiHexDigit","asciiDigit","$2b251002bd854cfd$export$289b6a6320f709b4","$HyG4B","$2b251002bd854cfd$var$own","characterEntities","$082eea842a54ecda$export$ec810d1aafce79a7","AElig","AMP","Aacute","Abreve","Acirc","Acy","Afr","Agrave","Alpha","Amacr","And","Aogon","Aopf","ApplyFunction","Aring","Ascr","Assign","Atilde","Auml","Backslash","Barv","Barwed","Bcy","Because","Bernoullis","Beta","Bfr","Bopf","Breve","Bscr","Bumpeq","CHcy","COPY","Cacute","Cap","CapitalDifferentialD","Cayleys","Ccaron","Ccedil","Ccirc","Cconint","Cdot","Cedilla","CenterDot","Cfr","Chi","CircleDot","CircleMinus","CirclePlus","CircleTimes","ClockwiseContourIntegral","CloseCurlyDoubleQuote","CloseCurlyQuote","Colon","Colone","Congruent","Conint","ContourIntegral","Copf","Coproduct","CounterClockwiseContourIntegral","Cross","Cscr","Cup","CupCap","DD","DDotrahd","DJcy","DScy","DZcy","Dagger","Darr","Dashv","Dcaron","Dcy","Del","Delta","Dfr","DiacriticalAcute","DiacriticalDot","DiacriticalDoubleAcute","DiacriticalGrave","DiacriticalTilde","Diamond","DifferentialD","Dopf","Dot","DotDot","DotEqual","DoubleContourIntegral","DoubleDot","DoubleDownArrow","DoubleLeftArrow","DoubleLeftRightArrow","DoubleLeftTee","DoubleLongLeftArrow","DoubleLongLeftRightArrow","DoubleLongRightArrow","DoubleRightArrow","DoubleRightTee","DoubleUpArrow","DoubleUpDownArrow","DoubleVerticalBar","DownArrow","DownArrowBar","DownArrowUpArrow","DownBreve","DownLeftRightVector","DownLeftTeeVector","DownLeftVector","DownLeftVectorBar","DownRightTeeVector","DownRightVector","DownRightVectorBar","DownTee","DownTeeArrow","Downarrow","Dscr","Dstrok","ENG","ETH","Eacute","Ecaron","Ecirc","Ecy","Edot","Efr","Egrave","Element","Emacr","EmptySmallSquare","EmptyVerySmallSquare","Eogon","Eopf","Epsilon","Equal","EqualTilde","Equilibrium","Escr","Esim","Eta","Euml","Exists","ExponentialE","Fcy","Ffr","FilledSmallSquare","FilledVerySmallSquare","Fopf","ForAll","Fouriertrf","Fscr","GJcy","GT","Gamma","Gammad","Gbreve","Gcedil","Gcirc","Gcy","Gdot","Gfr","Gg","Gopf","GreaterEqual","GreaterEqualLess","GreaterFullEqual","GreaterGreater","GreaterLess","GreaterSlantEqual","GreaterTilde","Gscr","Gt","HARDcy","Hacek","Hat","Hcirc","Hfr","HilbertSpace","Hopf","HorizontalLine","Hscr","Hstrok","HumpDownHump","HumpEqual","IEcy","IJlig","IOcy","Iacute","Icirc","Icy","Idot","Ifr","Igrave","Im","Imacr","ImaginaryI","Implies","Int","Integral","Intersection","InvisibleComma","InvisibleTimes","Iogon","Iopf","Iota","Iscr","Itilde","Iukcy","Iuml","Jcirc","Jcy","Jfr","Jopf","Jscr","Jsercy","Jukcy","KHcy","KJcy","Kappa","Kcedil","Kcy","Kfr","Kopf","Kscr","LJcy","LT","Lacute","Lambda","Lang","Laplacetrf","Larr","Lcaron","Lcedil","Lcy","LeftAngleBracket","LeftArrow","LeftArrowBar","LeftArrowRightArrow","LeftCeiling","LeftDoubleBracket","LeftDownTeeVector","LeftDownVector","LeftDownVectorBar","LeftFloor","LeftRightArrow","LeftRightVector","LeftTee","LeftTeeArrow","LeftTeeVector","LeftTriangle","LeftTriangleBar","LeftTriangleEqual","LeftUpDownVector","LeftUpTeeVector","LeftUpVector","LeftUpVectorBar","LeftVector","LeftVectorBar","Leftarrow","Leftrightarrow","LessEqualGreater","LessFullEqual","LessGreater","LessLess","LessSlantEqual","LessTilde","Lfr","Ll","Lleftarrow","Lmidot","LongLeftArrow","LongLeftRightArrow","LongRightArrow","Longleftarrow","Longleftrightarrow","Longrightarrow","Lopf","LowerLeftArrow","LowerRightArrow","Lscr","Lsh","Lstrok","Lt","Map","Mcy","MediumSpace","Mellintrf","Mfr","MinusPlus","Mopf","Mscr","Mu","NJcy","Nacute","Ncaron","Ncedil","Ncy","NegativeMediumSpace","NegativeThickSpace","NegativeThinSpace","NegativeVeryThinSpace","NestedGreaterGreater","NestedLessLess","NewLine","Nfr","NoBreak","NonBreakingSpace","Nopf","Not","NotCongruent","NotCupCap","NotDoubleVerticalBar","NotElement","NotEqual","NotEqualTilde","NotExists","NotGreater","NotGreaterEqual","NotGreaterFullEqual","NotGreaterGreater","NotGreaterLess","NotGreaterSlantEqual","NotGreaterTilde","NotHumpDownHump","NotHumpEqual","NotLeftTriangle","NotLeftTriangleBar","NotLeftTriangleEqual","NotLess","NotLessEqual","NotLessGreater","NotLessLess","NotLessSlantEqual","NotLessTilde","NotNestedGreaterGreater","NotNestedLessLess","NotPrecedes","NotPrecedesEqual","NotPrecedesSlantEqual","NotReverseElement","NotRightTriangle","NotRightTriangleBar","NotRightTriangleEqual","NotSquareSubset","NotSquareSubsetEqual","NotSquareSuperset","NotSquareSupersetEqual","NotSubset","NotSubsetEqual","NotSucceeds","NotSucceedsEqual","NotSucceedsSlantEqual","NotSucceedsTilde","NotSuperset","NotSupersetEqual","NotTilde","NotTildeEqual","NotTildeFullEqual","NotTildeTilde","NotVerticalBar","Nscr","Ntilde","Nu","OElig","Oacute","Ocirc","Ocy","Odblac","Ofr","Ograve","Omacr","Omega","Omicron","Oopf","OpenCurlyDoubleQuote","OpenCurlyQuote","Or","Oscr","Oslash","Otilde","Otimes","Ouml","OverBar","OverBrace","OverBracket","OverParenthesis","PartialD","Pcy","Pfr","Phi","Pi","PlusMinus","Poincareplane","Popf","Pr","Precedes","PrecedesEqual","PrecedesSlantEqual","PrecedesTilde","Prime","Product","Proportion","Proportional","Pscr","Psi","QUOT","Qfr","Qopf","Qscr","RBarr","REG","Racute","Rang","Rarr","Rarrtl","Rcaron","Rcedil","Rcy","Re","ReverseElement","ReverseEquilibrium","ReverseUpEquilibrium","Rfr","Rho","RightAngleBracket","RightArrow","RightArrowBar","RightArrowLeftArrow","RightCeiling","RightDoubleBracket","RightDownTeeVector","RightDownVector","RightDownVectorBar","RightFloor","RightTee","RightTeeArrow","RightTeeVector","RightTriangle","RightTriangleBar","RightTriangleEqual","RightUpDownVector","RightUpTeeVector","RightUpVector","RightUpVectorBar","RightVector","RightVectorBar","Rightarrow","Ropf","RoundImplies","Rrightarrow","Rscr","Rsh","RuleDelayed","SHCHcy","SHcy","SOFTcy","Sacute","Sc","Scaron","Scedil","Scirc","Scy","Sfr","ShortDownArrow","ShortLeftArrow","ShortRightArrow","ShortUpArrow","Sigma","SmallCircle","Sopf","Sqrt","Square","SquareIntersection","SquareSubset","SquareSubsetEqual","SquareSuperset","SquareSupersetEqual","SquareUnion","Sscr","Star","Sub","Subset","SubsetEqual","Succeeds","SucceedsEqual","SucceedsSlantEqual","SucceedsTilde","SuchThat","Sum","Sup","Superset","SupersetEqual","Supset","THORN","TRADE","TSHcy","TScy","Tab","Tau","Tcaron","Tcedil","Tcy","Tfr","Therefore","Theta","ThickSpace","ThinSpace","Tilde","TildeEqual","TildeFullEqual","TildeTilde","Topf","TripleDot","Tscr","Tstrok","Uacute","Uarr","Uarrocir","Ubrcy","Ubreve","Ucirc","Ucy","Udblac","Ufr","Ugrave","Umacr","UnderBar","UnderBrace","UnderBracket","UnderParenthesis","Union","UnionPlus","Uogon","Uopf","UpArrow","UpArrowBar","UpArrowDownArrow","UpDownArrow","UpEquilibrium","UpTee","UpTeeArrow","Uparrow","Updownarrow","UpperLeftArrow","UpperRightArrow","Upsi","Upsilon","Uring","Uscr","Utilde","Uuml","VDash","Vbar","Vcy","Vdash","Vdashl","Vee","Verbar","Vert","VerticalBar","VerticalLine","VerticalSeparator","VerticalTilde","VeryThinSpace","Vfr","Vopf","Vscr","Vvdash","Wcirc","Wedge","Wfr","Wopf","Wscr","Xfr","Xi","Xopf","Xscr","YAcy","YIcy","YUcy","Yacute","Ycirc","Ycy","Yfr","Yopf","Yscr","Yuml","ZHcy","Zacute","Zcaron","Zcy","Zdot","ZeroWidthSpace","Zeta","Zfr","Zopf","Zscr","aacute","abreve","ac","acE","acd","acirc","acute","acy","aelig","af","afr","agrave","alefsym","aleph","alpha","amacr","amalg","amp","andand","andd","andslope","andv","ang","ange","angle","angmsd","angmsdaa","angmsdab","angmsdac","angmsdad","angmsdae","angmsdaf","angmsdag","angmsdah","angrt","angrtvb","angrtvbd","angsph","angst","angzarr","aogon","aopf","ap","apE","apacir","ape","apid","apos","approx","approxeq","aring","ascr","ast","asymp","asympeq","atilde","auml","awconint","awint","bNot","backcong","backepsilon","backprime","backsim","backsimeq","barvee","barwed","barwedge","bbrk","bbrktbrk","bcong","bcy","bdquo","becaus","because","bemptyv","bepsi","bernou","beta","beth","between","bfr","bigcap","bigcirc","bigcup","bigodot","bigoplus","bigotimes","bigsqcup","bigstar","bigtriangledown","bigtriangleup","biguplus","bigvee","bigwedge","bkarow","blacklozenge","blacksquare","blacktriangle","blacktriangledown","blacktriangleleft","blacktriangleright","blank","blk12","blk14","blk34","block","bne","bnequiv","bnot","bopf","bot","bottom","bowtie","boxDL","boxDR","boxDl","boxDr","boxH","boxHD","boxHU","boxHd","boxHu","boxUL","boxUR","boxUl","boxUr","boxV","boxVH","boxVL","boxVR","boxVh","boxVl","boxVr","boxbox","boxdL","boxdR","boxdl","boxdr","boxh","boxhD","boxhU","boxhd","boxhu","boxminus","boxplus","boxtimes","boxuL","boxuR","boxul","boxur","boxv","boxvH","boxvL","boxvR","boxvh","boxvl","boxvr","bprime","breve","brvbar","bscr","bsemi","bsim","bsime","bsol","bsolb","bsolhsub","bull","bullet","bump","bumpE","bumpe","bumpeq","cacute","cap","capand","capbrcup","capcap","capcup","capdot","caps","caret","caron","ccaps","ccaron","ccedil","ccirc","ccups","ccupssm","cdot","cedil","cemptyv","cent","centerdot","cfr","chcy","checkmark","chi","cir","cirE","circ","circeq","circlearrowleft","circlearrowright","circledR","circledS","circledast","circledcirc","circleddash","cire","cirfnint","cirmid","cirscir","clubs","clubsuit","colon","colone","coloneq","comma","commat","comp","compfn","complement","complexes","cong","congdot","conint","copf","coprod","copysr","crarr","cross","cscr","csub","csube","csup","csupe","ctdot","cudarrl","cudarrr","cuepr","cuesc","cularr","cularrp","cup","cupbrcap","cupcap","cupcup","cupdot","cupor","cups","curarr","curarrm","curlyeqprec","curlyeqsucc","curlyvee","curlywedge","curren","curvearrowleft","curvearrowright","cuvee","cuwed","cwconint","cwint","cylcty","dArr","dHar","dagger","daleth","darr","dash","dashv","dbkarow","dblac","dcaron","dcy","dd","ddagger","ddarr","ddotseq","deg","delta","demptyv","dfisht","dfr","dharl","dharr","diam","diamond","diamondsuit","diams","die","digamma","disin","div","divide","divideontimes","divonx","djcy","dlcorn","dlcrop","dollar","dopf","dot","doteq","doteqdot","dotminus","dotplus","dotsquare","doublebarwedge","downarrow","downdownarrows","downharpoonleft","downharpoonright","drbkarow","drcorn","drcrop","dscr","dscy","dsol","dstrok","dtdot","dtri","dtrif","duarr","duhar","dwangle","dzcy","dzigrarr","eDDot","eDot","eacute","easter","ecaron","ecir","ecirc","ecolon","ecy","edot","ee","efDot","efr","eg","egrave","egs","egsdot","el","elinters","ell","els","elsdot","emacr","empty","emptyset","emptyv","emsp13","emsp14","emsp","eng","ensp","eogon","eopf","epar","eparsl","eplus","epsi","epsilon","epsiv","eqcirc","eqcolon","eqsim","eqslantgtr","eqslantless","equals","equest","equiv","equivDD","eqvparsl","erDot","erarr","escr","esdot","esim","eta","eth","euml","euro","excl","exist","expectation","exponentiale","fallingdotseq","fcy","female","ffilig","fflig","ffllig","ffr","filig","fjlig","flat","fllig","fltns","fnof","fopf","forall","fork","forkv","fpartint","frac12","frac13","frac14","frac15","frac16","frac18","frac23","frac25","frac34","frac35","frac38","frac45","frac56","frac58","frac78","frasl","frown","fscr","gE","gEl","gacute","gamma","gammad","gap","gbreve","gcirc","gcy","gdot","ge","gel","geq","geqq","geqslant","ges","gescc","gesdot","gesdoto","gesdotol","gesl","gesles","gfr","gg","ggg","gimel","gjcy","gl","glE","gla","glj","gnE","gnap","gnapprox","gne","gneq","gneqq","gnsim","gopf","grave","gscr","gsim","gsime","gsiml","gt","gtcc","gtcir","gtdot","gtlPar","gtquest","gtrapprox","gtrarr","gtrdot","gtreqless","gtreqqless","gtrless","gtrsim","gvertneqq","gvnE","hArr","hairsp","half","hamilt","hardcy","harr","harrcir","harrw","hbar","hcirc","hearts","heartsuit","hellip","hercon","hfr","hksearow","hkswarow","hoarr","homtht","hookleftarrow","hookrightarrow","hopf","horbar","hscr","hslash","hstrok","hybull","hyphen","iacute","ic","icirc","icy","iecy","iexcl","iff","ifr","igrave","ii","iiiint","iiint","iinfin","iiota","ijlig","imacr","imagline","imagpart","imath","imof","imped","in","incare","infin","infintie","inodot","int","intcal","integers","intercal","intlarhk","intprod","iocy","iogon","iopf","iota","iprod","iquest","iscr","isin","isinE","isindot","isins","isinsv","isinv","it","itilde","iukcy","iuml","jcirc","jcy","jfr","jmath","jopf","jscr","jsercy","jukcy","kappa","kappav","kcedil","kcy","kfr","kgreen","khcy","kjcy","kopf","kscr","lAarr","lArr","lAtail","lBarr","lE","lEg","lHar","lacute","laemptyv","lagran","lambda","langd","langle","lap","laquo","larr","larrb","larrbfs","larrfs","larrhk","larrlp","larrpl","larrsim","larrtl","lat","latail","late","lates","lbarr","lbbrk","lbrace","lbrack","lbrke","lbrksld","lbrkslu","lcaron","lcedil","lceil","lcub","lcy","ldca","ldquo","ldquor","ldrdhar","ldrushar","ldsh","le","leftarrow","leftarrowtail","leftharpoondown","leftharpoonup","leftleftarrows","leftrightarrow","leftrightarrows","leftrightharpoons","leftrightsquigarrow","leftthreetimes","leg","leq","leqq","leqslant","les","lescc","lesdot","lesdoto","lesdotor","lesg","lesges","lessapprox","lessdot","lesseqgtr","lesseqqgtr","lessgtr","lesssim","lfisht","lfloor","lfr","lg","lgE","lhard","lharu","lharul","lhblk","ljcy","ll","llarr","llcorner","llhard","lltri","lmidot","lmoust","lmoustache","lnE","lnap","lnapprox","lne","lneq","lneqq","lnsim","loang","loarr","lobrk","longleftarrow","longleftrightarrow","longmapsto","longrightarrow","looparrowleft","looparrowright","lopar","lopf","loplus","lotimes","lowast","lowbar","loz","lozenge","lozf","lpar","lparlt","lrarr","lrcorner","lrhar","lrhard","lrm","lrtri","lsaquo","lscr","lsh","lsim","lsime","lsimg","lsqb","lsquo","lsquor","lstrok","lt","ltcc","ltcir","ltdot","lthree","ltimes","ltlarr","ltquest","ltrPar","ltri","ltrie","ltrif","lurdshar","luruhar","lvertneqq","lvnE","mDDot","macr","male","malt","maltese","mapsto","mapstodown","mapstoleft","mapstoup","mcomma","mcy","mdash","measuredangle","mfr","mho","micro","mid","midast","midcir","middot","minus","minusb","minusd","minusdu","mlcp","mldr","mnplus","models","mopf","mp","mscr","mstpos","mu","multimap","mumap","nGg","nGt","nGtv","nLeftarrow","nLeftrightarrow","nLl","nLt","nLtv","nRightarrow","nVDash","nVdash","nabla","nacute","nang","nap","napE","napid","napos","napprox","natur","natural","naturals","nbsp","nbump","nbumpe","ncap","ncaron","ncedil","ncong","ncongdot","ncup","ncy","ndash","ne","neArr","nearhk","nearr","nearrow","nedot","nequiv","nesear","nesim","nexist","nexists","nfr","ngE","nge","ngeq","ngeqq","ngeqslant","nges","ngsim","ngt","ngtr","nhArr","nharr","nhpar","ni","nis","nisd","niv","njcy","nlArr","nlE","nlarr","nldr","nle","nleftarrow","nleftrightarrow","nleq","nleqq","nleqslant","nles","nless","nlsim","nlt","nltri","nltrie","nmid","nopf","not","notin","notinE","notindot","notinva","notinvb","notinvc","notni","notniva","notnivb","notnivc","npar","nparallel","nparsl","npart","npolint","npr","nprcue","npre","nprec","npreceq","nrArr","nrarr","nrarrc","nrarrw","nrightarrow","nrtri","nrtrie","nsc","nsccue","nsce","nscr","nshortmid","nshortparallel","nsim","nsime","nsimeq","nsmid","nspar","nsqsube","nsqsupe","nsub","nsubE","nsube","nsubset","nsubseteq","nsubseteqq","nsucc","nsucceq","nsup","nsupE","nsupe","nsupset","nsupseteq","nsupseteqq","ntgl","ntilde","ntlg","ntriangleleft","ntrianglelefteq","ntriangleright","ntrianglerighteq","nu","num","numero","numsp","nvDash","nvHarr","nvap","nvdash","nvge","nvgt","nvinfin","nvlArr","nvle","nvlt","nvltrie","nvrArr","nvrtrie","nvsim","nwArr","nwarhk","nwarr","nwarrow","nwnear","oS","oacute","oast","ocir","ocirc","ocy","odash","odblac","odiv","odot","odsold","oelig","ofcir","ofr","ogon","ograve","ogt","ohbar","ohm","oint","olarr","olcir","olcross","oline","olt","omacr","omega","omicron","omid","ominus","oopf","opar","operp","oplus","or","orarr","ord","order","orderof","ordf","ordm","origof","oror","orslope","orv","oscr","oslash","osol","otilde","otimes","otimesas","ouml","ovbar","par","para","parallel","parsim","parsl","pcy","percnt","period","permil","perp","pertenk","pfr","phi","phiv","phmmat","phone","pi","pitchfork","piv","planck","planckh","plankv","plus","plusacir","plusb","pluscir","plusdo","plusdu","pluse","plusmn","plussim","plustwo","pm","pointint","popf","pound","pr","prE","prap","prcue","pre","prec","precapprox","preccurlyeq","preceq","precnapprox","precneqq","precnsim","precsim","prime","primes","prnE","prnap","prnsim","prod","profalar","profline","profsurf","propto","prsim","prurel","pscr","psi","puncsp","qfr","qint","qopf","qprime","qscr","quaternions","quatint","quest","questeq","quot","rAarr","rArr","rAtail","rBarr","rHar","race","racute","radic","raemptyv","rang","rangd","range","rangle","raquo","rarr","rarrap","rarrb","rarrbfs","rarrc","rarrfs","rarrhk","rarrlp","rarrpl","rarrsim","rarrtl","rarrw","ratail","ratio","rationals","rbarr","rbbrk","rbrace","rbrack","rbrke","rbrksld","rbrkslu","rcaron","rcedil","rceil","rcub","rcy","rdca","rdldhar","rdquo","rdquor","rdsh","real","realine","realpart","reals","rect","reg","rfisht","rfloor","rfr","rhard","rharu","rharul","rho","rhov","rightarrow","rightarrowtail","rightharpoondown","rightharpoonup","rightleftarrows","rightleftharpoons","rightrightarrows","rightsquigarrow","rightthreetimes","ring","risingdotseq","rlarr","rlhar","rlm","rmoust","rmoustache","rnmid","roang","roarr","robrk","ropar","ropf","roplus","rotimes","rpar","rpargt","rppolint","rrarr","rsaquo","rscr","rsh","rsqb","rsquo","rsquor","rthree","rtimes","rtri","rtrie","rtrif","rtriltri","ruluhar","rx","sacute","sbquo","sc","scE","scap","scaron","sccue","sce","scedil","scirc","scnE","scnap","scnsim","scpolint","scsim","scy","sdot","sdotb","sdote","seArr","searhk","searr","searrow","sect","semi","seswar","setminus","setmn","sext","sfr","sfrown","sharp","shchcy","shcy","shortmid","shortparallel","shy","sigma","sigmaf","sigmav","sim","simdot","sime","simeq","simg","simgE","siml","simlE","simne","simplus","simrarr","slarr","smallsetminus","smashp","smeparsl","smid","smile","smt","smte","smtes","softcy","sol","solb","solbar","sopf","spades","spadesuit","spar","sqcap","sqcaps","sqcup","sqcups","sqsub","sqsube","sqsubset","sqsubseteq","sqsup","sqsupe","sqsupset","sqsupseteq","squ","square","squarf","squf","srarr","sscr","ssetmn","ssmile","sstarf","star","starf","straightepsilon","straightphi","strns","sub","subE","subdot","sube","subedot","submult","subnE","subne","subplus","subrarr","subset","subseteq","subseteqq","subsetneq","subsetneqq","subsim","subsub","subsup","succ","succapprox","succcurlyeq","succeq","succnapprox","succneqq","succnsim","succsim","sum","sung","sup1","sup2","sup3","sup","supE","supdot","supdsub","supe","supedot","suphsol","suphsub","suplarr","supmult","supnE","supne","supplus","supset","supseteq","supseteqq","supsetneq","supsetneqq","supsim","supsub","supsup","swArr","swarhk","swarr","swarrow","swnwar","szlig","tau","tbrk","tcaron","tcedil","tcy","tdot","telrec","tfr","there4","therefore","theta","thetasym","thetav","thickapprox","thicksim","thinsp","thkap","thksim","thorn","tilde","times","timesb","timesbar","timesd","tint","toea","top","topbot","topcir","topf","topfork","tosa","tprime","trade","triangle","triangledown","triangleleft","trianglelefteq","triangleq","triangleright","trianglerighteq","tridot","trie","triminus","triplus","trisb","tritime","trpezium","tscr","tscy","tshcy","tstrok","twixt","twoheadleftarrow","twoheadrightarrow","uArr","uHar","uacute","uarr","ubrcy","ubreve","ucirc","ucy","udarr","udblac","udhar","ufisht","ufr","ugrave","uharl","uharr","uhblk","ulcorn","ulcorner","ulcrop","ultri","umacr","uml","uogon","uopf","uparrow","updownarrow","upharpoonleft","upharpoonright","uplus","upsi","upsih","upsilon","upuparrows","urcorn","urcorner","urcrop","uring","urtri","uscr","utdot","utilde","utri","utrif","uuarr","uuml","uwangle","vArr","vBar","vBarv","vDash","vangrt","varepsilon","varkappa","varnothing","varphi","varpi","varpropto","varr","varrho","varsigma","varsubsetneq","varsubsetneqq","varsupsetneq","varsupsetneqq","vartheta","vartriangleleft","vartriangleright","vcy","vdash","vee","veebar","veeeq","vellip","verbar","vert","vfr","vltri","vnsub","vnsup","vopf","vprop","vrtri","vscr","vsubnE","vsubne","vsupnE","vsupne","vzigzag","wcirc","wedbar","wedge","wedgeq","weierp","wfr","wopf","wp","wr","wreath","wscr","xcap","xcirc","xcup","xdtri","xfr","xhArr","xharr","xi","xlArr","xlarr","xmap","xnis","xodot","xopf","xoplus","xotime","xrArr","xrarr","xscr","xsqcup","xuplus","xutri","xvee","xwedge","yacute","yacy","ycirc","ycy","yen","yfr","yicy","yopf","yscr","yucy","yuml","zacute","zcaron","zcy","zdot","zeetrf","zeta","zfr","zhcy","zigrarr","zopf","zscr","zwj","zwnj","$bfa1e3841184db91$export$c23e4921f8d87e7c","closingFenceConstruct","sizeOpen","closingSequenceEnd","nonLazyLine","initialPrefix","sequenceOpen","infoOpen","openAfter","infoAfter","$797536ce4d4ef541$export$47910b7ab28d1853","afterStartPrefix","afterPrefix","$797536ce4d4ef541$var$indentedContent","$63de5539f73334db$export$d24f93e715f9df88","tailExitIndex","headEnterIndex","$861888066e94d267$export$69f215ed977cdb73","$DVYDN","$fDPPf","$hFl17","$e4FUu","factoryLabel","labelAfter","factoryWhitespace","factoryDestination","$861888066e94d267$var$titleConstruct","factoryTitle","$07809dac6ed252d2$export$2e6c8deaa96af245","literalType","literalMarkerType","rawType","stringType","balance","destinationEnclosedBefore","destinationRaw","destinationEnclosed","destinationEnclosedEscape","destinationRawEscape","$b632b306b4fd5043$export$7b768614d8ba97a7","markerType","labelEscape","$cdc6918eb8aa8f3b$export$f970569cc855e483","atFirstTitleBreak","atTitleBreak","titleEscape","$a3f1f2e26d47e9ab$export$1f27bd1aa33ce173","$24dbb37024226bd1$export$806d55e226cfcd08","toUpperCase","$c67292758c3a9417$export$86c573ab9e06f418","$f343ed25fab8a66c$export$3871e9deb360695c","fenceOpenInside","headingBreak","$348f19684487bb7f$export$476ac411cb7d0d8f","$gZx53","kind","startTag","declarationStart","tagCloseStart","continuationDeclarationInside","tagName","commentOpenInside","cdataOpenInside","htmlRawNames","htmlBlockNames","basicSelfClosing","completeAttributeNameBefore","completeClosingTagAfter","completeEnd","completeAttributeName","completeAttributeNameAfter","completeAttributeValueBefore","completeAttributeValueQuoted","completeAttributeValueUnquoted","completeAttributeValueQuotedAfter","completeAfter","continuationCommentInside","continuationRawTagOpen","continuationClose","continuationCharacterDataInside","$348f19684487bb7f$var$nextBlankConstruct","continuationAtLineEnding","htmlContinueStart","htmlLineEnd","continuationRawEndTag","$c5ec00f1b3028007$export$7364aee1c59d1879","$c5ec00f1b3028007$export$948e66da505d080","$8330424d747ed971$export$398af27f284914fe","declarationOpen","instruction","tagOpen","commentOpen","cdataOpen","declaration","commentStart","commentStartDash","comment","commentClose","atLineEnding","cdata","cdataClose","cdataEnd","instructionClose","tagClose","tagCloseBetween","tagOpenBetween","tagOpenAttributeName","tagOpenAttributeNameAfter","tagOpenAttributeValueBefore","tagOpenAttributeValueQuoted","tagOpenAttributeValueUnquoted","tagOpenAttributeValueQuotedAfter","$9e063ebe1e586afe$export$470a5dafbbf62654","labelStart","_balanced","_inactive","balanced","afterLabelEnd","$9e063ebe1e586afe$var$resourceConstruct","$9e063ebe1e586afe$var$fullReferenceConstruct","$9e063ebe1e586afe$var$collapsedReferenceConstruct","media","destinationAfter","afterLabel","$5f4a520d3aad06eb$export$3d754936e25aa5f5","$01e81346ffe0e376$export$5c0cee0701a3b584","$ca397b7ad9fc1681$export$8e62e0ad51c97b2","$156235cc4d370751$export$8837f4fc672e936d","initialSize","inside","onBlank","$156235cc4d370751$var$listItemPrefixWhitespaceConstruct","endOfPrefix","otherPrefix","initialBlankLine","furtherBlankLines","notInCurrentItem","$156235cc4d370751$var$indentConstruct","$3df095c4dce56453$export$ba7b13e047416c03","$e4e5198b081c05d3$export$e104e2de391dfde9","$faa22b241d1ff8fd$export$fc37fe19dfda43ee","$faa22b241d1ff8fd$var$search","atCarriageReturn","endPosition","lastIndex","Math","ceil","$261393ead1603790$export$bd0e6e1378a871d7","$c5e8f98ad61a9793$export$15a69557afac2c20","base","$66b46fe490d28799$export$a0fb664af7d0cc44","$66b46fe490d28799$var$characterEscapeOrReference","$66b46fe490d28799$var$decode","$0","$1","$2","head","hex","$f192f06803e471a7$export$2e2bcd8739ae039","$82jGJ","toHast","$5d9dc8503281e181$export$c0e4c5cf07538633","$1j7pP","$56qaC","createState","one","foot","footer","$0f3d515b9a22cf98$export$adb608be33961c98","$eznPp","listItems","footnoteOrder","footnoteById","safeId","normalizeUri","referenceIndex","backReferences","footnoteCounts","backReference","properties","clobberPrefix","dataFootnoteBackref","ariaLabel","footnoteBackLabel","tailTail","wrap","patch","dataFootnotes","footnoteLabelTagName","footnoteLabelProperties","footnoteLabel","$a9b6d15784ed8a88$export$e42a3e39590d28b5","skip","encodeURIComponent","$b08403b79a57c87d$export$c564cdbbe6da493","$b08403b79a57c87d$var$characterReferences","$3b71d02d19a2f9fc$export$e6a0daad8304de","$ei8wA","$40w8i","$8bjnJ","$kCihy","$1u0y6","$3b71d02d19a2f9fc$var$own","dangerous","unknownHandler","passThrough","handlers","definitions","$3b71d02d19a2f9fc$var$patch","applyData","$3b71d02d19a2f9fc$var$applyData","$3b71d02d19a2f9fc$export$80bf7733f1207381","$3b71d02d19a2f9fc$export$84bf76cd7afc7469","$3b71d02d19a2f9fc$export$4997ffc0176396a6","augment","visit","hName","hProperties","hChildren","ctx","generated","pointStart","pointEnd","$3b71d02d19a2f9fc$var$defaultUnknownHandler","nodes","loose","$a6795beeb14361e9$export$bf638b60ea8b89b7","$7xAT4","visitor","reverse","visitParents","parents","$57d83a7e99fe1db8$export$70008a21eb6de899","$cXrlj","$dwwhP","is","convert","step","factory","color","subresult","grandparents","$96f0346b9b041ae6$export$9c68d69a4c5bbcf9","$96f0346b9b041ae6$var$ok","$96f0346b9b041ae6$var$castFactory","$96f0346b9b041ae6$var$anyFactory","tests","checks","$9d874ef8a8ef080d$export$35e9368ef982300f","$2eb0166faf454f4f$export$771bf3e4949bfbee","$2eb0166faf454f4f$export$da309cdce9dc2a25","$2eb0166faf454f4f$export$5880b8b5730aff45","$2eb0166faf454f4f$var$point","$5f4e629f12acb78a$export$41ad1363166ec91a","$f02589b0b57bcb5b$export$d79264f26953ec1","$f02589b0b57bcb5b$var$own","cache","$f02589b0b57bcb5b$var$clean","$114904d24886f596$export$455ce229eb3d2472","$bBTWt","$gAkBB","$aQ0We","$1eNIu","$6Pou9","$lzRR1","$4R9bv","$g6bry","$2ude9","$luOdh","$3ONqI","$ginya","$jcqku","$lTpT2","$lhaRl","$aA78B","$kaiJ7","$9TBfz","$d1czY","$84G49","$auLC5","$bEKLo","$ksz7P","$Sxzp6","blockquote","break","delete","strikethrough","footnoteReference","footnote","imageReference","inlineCode","linkReference","root","table","tableCell","tableRow","toml","$114904d24886f596$var$ignore","yaml","footnoteDefinition","$873e8b602d67e1eb$export$67dc04e652a298ca","$c12ffdf45974319a$export$371da9dd35aba193","$7e3f7d005d5ee31c$export$6565f9f03506010b","$0e6da9eea1159b5c$export$19426ff118fe8be","$4f8a7fc2c9259b58$export$bef81ba411953b51","$fb56a43294cb554f$export$7f87ee744075c1ba","counter","reuseCounter","dataFootnoteRef","ariaDescribedBy","$38933c847d32fb3a$export$3b6a720baa2c20ec","no","$bb86154deb79b98e$export$46e4a324ac90507f","$1cf8a4c88312066a$export$c0bb0b647f701bb5","$fa63599826cf80b6$export$f281796f6bc3b8db","$3Hi5O","revert","$2b136c1710f10951$export$3fdd26f3d9e7dc78","subtype","suffix","contents","$2c7c625ff27de5b7$export$5c452ff88e35e47d","$bdd09856e8ba33ae$export$91b9bee19a0d8569","$dfa38fce9f7f6b8c$export$e6c469b1b7b2bc6a","$ff02d09ce4744195$export$9c30223ca0a664fb","$f7d39bf347298f3f$export$76c7e83ecc9cdf05","results","$f7d39bf347298f3f$var$listLoose","$f7d39bf347298f3f$var$listItemLoose","disabled","child","$7b42cd949e6c60f9$export$8837f4fc672e936d","$eae3449019415a3a$export$9c206ddddb32a9b","$7346253959989240$export$e8e78c978b129247","$97a52058d14c61a8$export$59ae2c325a998f89","$5e0f53d9d07017d8$export$9852986a3ec5f6a0","rows","firstRow","shift","tableContent","body","$7a41a3b926310dff$export$ce666bf02318c957","siblings","rowIndex","align","cellIndex","cells","cell","alignValue","$87c7b463ad5582bc$export$e1e720e5f4603e6a","$ee51ab4e98d30870$export$6f093cfa640b7166","$4AQW1","trimLines","$358395fcbf5a2cfd$export$a771f20bdd13def9","search","last","lines","$358395fcbf5a2cfd$var$trimLine","codePointAt","$0a3f1591cf32526f$export$ba7b13e047416c03","$lNqgI","$9a4d6a57aaaab11e$var$emptyFunction","$9a4d6a57aaaab11e$var$emptyFunctionWithReset","resetWarningCache","shim","propName","componentName","location","propFullName","secret","err","getShim","isRequired","ReactPropTypes","array","bigint","number","symbol","element","elementType","instanceOf","objectOf","oneOf","shape","exact","checkPropTypes","PropTypes","$7fc12be348255554$export$c0bb0b647f701bb5","$7fc12be348255554$export$7ed1367e7fa1ad68","$8K29K","$cXEVp","$2mSAN","$8TXBj","$7ejLl","$cwo9C","$lF5RX","merge","xml","xlink","xmlns","aria","svg","$65d44acdf87d3821$export$4950aa0f605343fb","$2V6iF","space","property","normal","Schema","$2205caaf944f60ef$export$19342e026b58ebb7","$96fabd8cd2ed1feb$export$2bd1230ec7600845","$jbPNJ","transform","xLinkActuate","xLinkArcRole","xLinkHref","xLinkRole","xLinkShow","xLinkTitle","xLinkType","$df873a045ab9997d$export$185802fd694ee1f5","$4GEAW","$lqZ1V","$df873a045ab9997d$var$own","DefinedInfo","attributes","mustUseProperty","normalize","attribute","$369a92eee5cf5c65$export$a3295358bff77e","$f9ab5dffd32c2b27$export$ea6b9f0064e88c9b","$imkUs","$bhH9I","$f9ab5dffd32c2b27$var$checks","keys","Info","mask","$d5da804e63e4f031$export$c4868e4a24d48fad","boolean","booleanish","overloadedBoolean","commaSeparated","spaceSeparated","commaOrSpaceSeparated","$8372c20d7637626a$export$4a21f16c33752377","$8372c20d7637626a$export$55e9e1fbc638dc8f","$8372c20d7637626a$export$242ac3d3042558aa","$8372c20d7637626a$export$98e628dec113755e","$8372c20d7637626a$export$ab8645c862eb5a3e","$8372c20d7637626a$export$9c8d678629b3d3","$8372c20d7637626a$export$2ad25cfebf36cacd","$8372c20d7637626a$var$powers","$8372c20d7637626a$var$increment","$1b97fbcaee557873$export$f2913fe8983302e","xmlLang","xmlBase","xmlSpace","$67b1b149c061c281$export$e20c24a128671213","$4PxUO","xmlnsxlink","caseInsensitiveTransform","xmlnsXLink","$38463bbd80687601$export$32b9e4cec9c208e1","$5rtXf","caseSensitiveTransform","$3f66b5b5be89dedb$export$5b10b3bc32d7efbc","$54392ba55dc44eaa$export$4d2d26490572750a","ariaActiveDescendant","ariaAtomic","ariaAutoComplete","ariaBusy","ariaChecked","ariaColCount","ariaColIndex","ariaColSpan","ariaControls","ariaCurrent","ariaDetails","ariaDisabled","ariaDropEffect","ariaErrorMessage","ariaExpanded","ariaFlowTo","ariaGrabbed","ariaHasPopup","ariaHidden","ariaInvalid","ariaKeyShortcuts","ariaLabelledBy","ariaLevel","ariaLive","ariaModal","ariaMultiLine","ariaMultiSelectable","ariaOrientation","ariaOwns","ariaPlaceholder","ariaPosInSet","ariaPressed","ariaReadOnly","ariaRelevant","ariaRequired","ariaRoleDescription","ariaRowCount","ariaRowIndex","ariaRowSpan","ariaSelected","ariaSetSize","ariaSort","ariaValueMax","ariaValueMin","ariaValueNow","ariaValueText","role","$91db35b5689628e4$export$c0bb0b647f701bb5","acceptcharset","classname","htmlfor","httpequiv","abbr","accept","acceptCharset","accessKey","action","allow","allowFullScreen","allowPaymentRequest","allowUserMedia","as","async","autoCapitalize","autoComplete","autoFocus","autoPlay","capture","charSet","cite","cols","colSpan","contentEditable","controls","controlsList","coords","crossOrigin","dateTime","decoding","defer","dir","dirName","download","draggable","encType","enterKeyHint","form","formAction","formEncType","formMethod","formNoValidate","formTarget","headers","height","hidden","high","hrefLang","htmlFor","httpEquiv","imageSizes","imageSrcSet","inputMode","integrity","isMap","itemId","itemProp","itemRef","itemScope","itemType","loading","loop","low","manifest","maxLength","method","min","minLength","multiple","muted","nonce","noModule","noValidate","onAbort","onAfterPrint","onAuxClick","onBeforeMatch","onBeforePrint","onBeforeUnload","onBlur","onCancel","onCanPlay","onCanPlayThrough","onChange","onClick","onClose","onContextLost","onContextMenu","onContextRestored","onCopy","onCueChange","onCut","onDblClick","onDrag","onDragEnd","onDragEnter","onDragExit","onDragLeave","onDragOver","onDragStart","onDrop","onDurationChange","onEmptied","onEnded","onError","onFocus","onFormData","onHashChange","onInput","onInvalid","onKeyDown","onKeyPress","onKeyUp","onLanguageChange","onLoad","onLoadedData","onLoadedMetadata","onLoadEnd","onLoadStart","onMessage","onMessageError","onMouseDown","onMouseEnter","onMouseLeave","onMouseMove","onMouseOut","onMouseOver","onMouseUp","onOffline","onOnline","onPageHide","onPageShow","onPaste","onPause","onPlay","onPlaying","onPopState","onProgress","onRateChange","onRejectionHandled","onReset","onResize","onScroll","onScrollEnd","onSecurityPolicyViolation","onSeeked","onSeeking","onSelect","onSlotChange","onStalled","onStorage","onSubmit","onSuspend","onTimeUpdate","onToggle","onUnhandledRejection","onUnload","onVolumeChange","onWaiting","onWheel","optimum","pattern","ping","placeholder","playsInline","poster","preload","readOnly","referrerPolicy","rel","required","reversed","rowSpan","sandbox","scope","scoped","seamless","selected","sizes","slot","span","spellCheck","srcDoc","srcLang","srcSet","tabIndex","translate","typeMustMatch","useMap","width","aLink","archive","axis","background","bgColor","border","borderColor","bottomMargin","cellPadding","cellSpacing","char","charOff","classId","clear","codeBase","codeType","compact","declare","face","frame","frameBorder","hSpace","leftMargin","longDesc","lowSrc","marginHeight","marginWidth","noResize","noHref","noShade","noWrap","profile","prompt","rev","rightMargin","rules","scheme","scrolling","standby","summary","topMargin","valueType","version","vAlign","vLink","vSpace","allowTransparency","autoCorrect","autoSave","disablePictureInPicture","disableRemotePlayback","security","unselectable","$fc51face202e8fdd$export$7ed1367e7fa1ad68","accentHeight","alignmentBaseline","arabicForm","baselineShift","capHeight","clipPath","clipRule","colorInterpolation","colorInterpolationFilters","colorProfile","colorRendering","dataType","dominantBaseline","enableBackground","fillOpacity","fillRule","floodColor","floodOpacity","fontFamily","fontSize","fontSizeAdjust","fontStretch","fontStyle","fontVariant","fontWeight","glyphName","glyphOrientationHorizontal","glyphOrientationVertical","horizAdvX","horizOriginX","horizOriginY","imageRendering","letterSpacing","lightingColor","markerEnd","markerMid","markerStart","navDown","navDownLeft","navDownRight","navLeft","navNext","navPrev","navRight","navUp","navUpLeft","navUpRight","onActivate","onBegin","onEnd","onFocusIn","onFocusOut","onMouseWheel","onRepeat","onShow","onZoom","overlinePosition","overlineThickness","paintOrder","panose1","pointerEvents","renderingIntent","shapeRendering","stopColor","stopOpacity","strikethroughPosition","strikethroughThickness","strokeDashArray","strokeDashOffset","strokeLineCap","strokeLineJoin","strokeMiterLimit","strokeOpacity","strokeWidth","textAnchor","textDecoration","textRendering","typeOf","underlinePosition","underlineThickness","unicodeBidi","unicodeRange","unitsPerEm","vAlphabetic","vHanging","vIdeographic","vMathematical","vectorEffect","vertAdvY","vertOriginX","vertOriginY","wordSpacing","writingMode","xHeight","playbackOrder","timelineBegin","about","accumulate","additive","alphabetic","amplitude","ascent","attributeName","attributeType","azimuth","bandwidth","baseFrequency","baseProfile","bbox","begin","bias","by","calcMode","clip","clipPathUnits","contentScriptType","contentStyleType","cursor","cx","cy","defaultAction","descent","diffuseConstant","direction","display","dur","divisor","dx","dy","edgeMode","editable","elevation","exponent","externalResourcesRequired","fill","filter","filterRes","filterUnits","focusable","focusHighlight","format","fr","fx","fy","g1","g2","glyphRef","gradientTransform","gradientUnits","hanging","hatchContentUnits","hatchUnits","ideographic","initialVisibility","in2","intercept","k","k1","k2","k3","k4","kernelMatrix","kernelUnitLength","keyPoints","keySplines","keyTimes","kerning","lengthAdjust","limitingConeAngle","local","markerHeight","markerUnits","markerWidth","maskContentUnits","maskUnits","mathematical","mediaCharacterEncoding","mediaContentEncodings","mediaSize","mediaTime","mode","numOctaves","observer","opacity","operator","orient","orientation","overflow","overlay","pathLength","patternContentUnits","patternTransform","patternUnits","phase","pitch","points","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","preserveAspectRatio","primitiveUnits","propagate","r","radius","refX","refY","repeatCount","repeatDur","requiredExtensions","requiredFeatures","requiredFonts","requiredFormats","restart","rotate","ry","scale","seed","side","slope","snapshotTime","specularConstant","specularExponent","spreadMethod","spacing","startOffset","stdDeviation","stemh","stemv","stitchTiles","stroke","surfaceScale","syncBehavior","syncBehaviorDefault","syncMaster","syncTolerance","syncToleranceDefault","systemLanguage","tableValues","targetX","targetY","textLength","transformBehavior","u1","u2","unicode","viewBox","viewTarget","visibility","widths","x","x1","x2","xChannelSelector","y","y1","y2","yChannelSelector","z","zoomAndPan","$5fd6180ccffdcd4c$export$71aa6c912b956294","$5fd6180ccffdcd4c$var$valid","$5fd6180ccffdcd4c$var$dash","$5fd6180ccffdcd4c$var$cap","Type","charAt","rest","$5fd6180ccffdcd4c$var$camelcase","dashes","$5fd6180ccffdcd4c$var$kebab","$de01df0dd0de2012$export$d8abd7e5fb6871f9","$105f61fb909d5bd6$export$2e2bcd8739ae039","parent_","$cf0d324ac74956f1$export$4b745c302603ab5d","childIndex","$cf0d324ac74956f1$var$toReact","$10YAt","uriTransformer","parentSchema","$cf0d324ac74956f1$var$own","$cf0d324ac74956f1$var$addProperty","$8e8kD","find","$aydpb","$9LDtD","$cf0d324ac74956f1$var$parseStyle","$aKvL7","$cf0d324ac74956f1$var$styleReplacer","$j3JRp","hastToReact","component","basic","$5EgQh","isValidElementType","level","input","$cf0d324ac74956f1$var$getInputElement","$cf0d324ac74956f1$var$getElementsBeforeCount","textAlign","isHeader","sourcePosition","siblingCount","$cf0d324ac74956f1$var$tableElements","has","$2h0WQ","whitespace","Set","count","$1a7de79656976693$export$7af1228ff777d175","$71c7202b4e4c47aa$export$fac44ee5b035f737","trim","$7ae77a5ec40be267$export$fac44ee5b035f737","padRight","padLeft","$8a48ffc0108afa92$export$2e2bcd8739ae039","$c2Dp1","$5448fd54a0960326$var$StyleToObject","declarations","hasIterator","len","$8c443c74d39aad73$var$COMMENT_REGEX","$8c443c74d39aad73$var$NEWLINE_REGEX","$8c443c74d39aad73$var$WHITESPACE_REGEX","$8c443c74d39aad73$var$PROPERTY_REGEX","$8c443c74d39aad73$var$COLON_REGEX","$8c443c74d39aad73$var$VALUE_REGEX","$8c443c74d39aad73$var$SEMICOLON_REGEX","$8c443c74d39aad73$var$TRIM_REGEX","$8c443c74d39aad73$var$trim","str","lineno","updatePosition","Position","errorsList","msg","filename","silent","re","m","comments","c","$8c443c74d39aad73$var$FORWARD_SLASH","$8c443c74d39aad73$var$ASTERISK","$8c443c74d39aad73$var$EMPTY_STRING","decl","decls","val","ret","$0bd4c9e9b9330ba0$export$b83532a10e2e268b","$0bd4c9e9b9330ba0$var$protocols","uri","first","$815c9a1adfb144b5$export$2b55d7630a748f79","$815c9a1adfb144b5$export$e13597a754cb43a1"],"version":3,"file":"postsContent.component.9600151c.js.map"}